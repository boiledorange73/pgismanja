<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第7章 性能向上に関する技法</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="PostGIS 2.2.0devマニュアル日本語訳"><link rel="up" href="index.html" title="PostGIS 2.2.0devマニュアル日本語訳"><link rel="prev" href="ch06.html" title="第6章 PostGISを使う: アプリケーションを構築する"><link rel="next" href="reference.html" title="第8章 PostGISリファレンス"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第7章 性能向上に関する技法</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr></table><hr></div><div class="chapter" title="第7章 性能向上に関する技法"><div class="titlepage"><div><div><h2 class="title"><a name="performance_tips"></a>第7章 性能向上に関する技法</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="performance_tips.html#small_tables_large_objects">7.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance_tips.html#idp69692880">7.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp69695696">7.1.2. 応急処置</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance_tips.html#database_clustering">7.2. ジオメトリインデクスでCLUSTERを実行する</a></span></dt><dt><span class="sect1"><a href="performance_tips.html#avoiding_dimension_conversion">7.3. 次元変換の回避</a></span></dt><dt><span class="sect1"><a href="performance_tips.html#database_tuning_configuration">7.4. コンフィギュレーションのチューン</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance_tips.html#idp69699664">7.4.1. 起動時</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp69710800">7.4.2. 実行時</a></span></dt></dl></dd></dl></div><div class="sect1" title="7.1. 大きなジオメトリを持つ小さなテーブル"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="small_tables_large_objects"></a>7.1. 大きなジオメトリを持つ小さなテーブル</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="performance_tips.html#idp69692880">7.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp69695696">7.1.2. 応急処置</a></span></dt></dl></div><div class="sect2" title="7.1.1. 問題の説明"><div class="titlepage"><div><div><h3 class="title"><a name="idp69692880"></a>7.1.1. 問題の説明</h3></div></div></div><p>現版のPostgreSQL(8.0を含む)では、TOASTテーブルに従うクエリオプティマイザの弱さに苦しみます。 TOASTテーブルは、(長いテキスト、イメージ、多数の頂点を持つ複合ジオメトリといった)通常のデータページに適合しない、(データサイズという意味では)巨大な値を納めるための「拡張部屋」の一種です。詳細情報は <a class="ulink" href="http://www.postgresql.org/docs/current/static/storage-toast.html" target="_top">the PostgreSQL Documentation for TOAST</a>をご覧ください。</p><p>(高解像度で全てのヨーロッパの国の境界を含むテーブルのような)大きなジオメトリがあるうえ、行がそう多くないテーブルを持つようになると、この問題が出てきます。テーブル自体は小さいのですが、多くのTOASTスペースを使います。例として、テーブル自体は概ね80行で3データページしか使わなくてもTOASTテーブルで8225ページを使うとします。</p><p>ここで、ジオメトリ演算子の&amp;&amp;を使って、ほとんどマッチしないようなバウンダリボックスを検索するクエリを出してみます。クエリオプティマイザにはテーブルは3ページ80行しかないように見えます。オプティマイザは、小さなテーブルを順に走査する方がインデクスを使うよりも早いと見積もります。そして、GiSTインデクスは無視すると決めます。通常なら、この見積もりは正しいです。しかし、この場合は&amp;&amp;演算子が全てのジオメトリをディスクから呼び出しでバウンディングボックスと比較しなければならなくなり、ゆえに、全てのTOASTページもまた呼び出す必要があります。</p><p>このバグに苦しむかどうかを見るには、PostgreSQLの"EXPLAIN ANALYZE"コマンドを使います。詳しい情報と技術に関する詳細については、postgres performance mailing list のスレッド(http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php)をご覧下さい。</p></div><div class="sect2" title="7.1.2. 応急処置"><div class="titlepage"><div><div><h3 class="title"><a name="idp69695696"></a>7.1.2. 応急処置</h3></div></div></div><p>PostgreSQLコミュニティでは、TOASTを意識したクエリ見積もりを作ることで、この問題を解決しようとしています。今のところは、2つの応急処置があります。</p><p>ひとつは、クエリプランナにインデクスの使用を強制することです。クエリを発行する前に"SET enable_seqscan TO off;"をサーバに送信します。これは基本的にクエリプランナに対して可能な限り順に走査することを避けるよう強制します。そのためGiSTインデクスを通常使うようになります。しかし、このフラグは接続するたびに設定しなければならず、他のケースにおいてはクエリプランナに誤った見積もりをさせることになるので、 "SET enable_seqscan TO on;"をクエリの後に送信すべきです。</p><p>もうひとつは、順に走査することをクエリプランナが考える程度に早くすることです。これは、バウンダリボックスの「キャッシュ」を行う追加カラムを作成し、このカラムにマッチさせるようにすることで達成することができます。ここでの例では次のようになります。</p><pre class="programlisting">SELECT AddGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2'); 
UPDATE mytable SET bbox = ST_Envelope(ST_Force2D(the_geom));</pre><p>そして、次のように、&amp;&amp;演算子をgeom_columnに対して行っていたものをbboxに変更します。</p><pre class="programlisting">SELECT geom_column 
FROM mytable 
WHERE bbox &amp;&amp; ST_SetSRID('BOX3D(0 0,1 1)'::box3d,4326);</pre><p>もちろん、mytableの行を変更または追加したら、bboxを「同期」するようにしなければなりません。最もすっきりした方法はトリガです。もしくは、アプリケーションを変更してbboxカラムの現状を保持するか、テーブル更新後にいつもUPDATEクエリを実行するかでも対応できます。</p></div></div><div class="sect1" title="7.2. ジオメトリインデクスでCLUSTERを実行する"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database_clustering"></a>7.2. ジオメトリインデクスでCLUSTERを実行する</h2></div></div></div><p>読み込むことがほとんどで、かつほとんどのクエリでひとつのインデクスを使うようなテーブルのために、PostgreSQLはCLUSTERコマンドを提供しています。このコマンドは、全てのデータ行を、インデクス基準にあわせて物理的に再整理するので、2つの性能の利点を生みます。ひとつは、インデクスの範囲走査のために、データテーブルのシーク回数が劇的に減少することです。ふたつめは、いくつかの小さなインデクス間隔に集中する場合には、データ行が分布するデータページがより少なくなるので、より効率的なキャッシュを持つことです(この点で、PostgreSQLマニュアルのCLUSTERコマンドのドキュメントを読むように仕向けられていると感じて下さい)。</p><p>しかし、GiSTインデクスは単純にNULL値を無視するため現在のところPostGISのGiSTインデクスのクラスタリングはできず、次のようなエラーメッセージを得ます。</p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table; 
ERROR: cannot cluster when index access method does not handle null values
(エラー: インデクスアクセスメソッドがNULL値を扱わない場合クラスタ化できません)
HINT: You may be able to work around this by marking column "the_geom" NOT NULL.
(ヒント: 列"the_geom"をNOT NULLとすることで、これを回避できるかもしれません)</pre><p>ヒントメッセージにある通り、テーブルに"not null"制限を追加することで、この欠陥にとりあえず対応できます。例を示します。</p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null; 
ALTER TABLE</pre><p>もちろん、ジオメトリカラムで実際にNULL値が必要な場合、この対応はできません。さらには、制限を追加するには上の方法を使わなければならず、"ALTER TABLE blubb ADD CHECK (geometry is not null);"のようなCHECK制限は使えません。 </p></div><div class="sect1" title="7.3. 次元変換の回避"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="avoiding_dimension_conversion"></a>7.3. 次元変換の回避</h2></div></div></div><p>ときどき、テーブルで3次元、4次元のデータを持つのに、常にOpenGIS準拠のST_AsText()またはST_AsBinary()関数を使ってアクセスして 2次元ジオメトリを出力させるようなことが起きます。内部でST_Force_2d()関数を呼んでいるために発生しますが、これは、大きなジオメトリでは重大なオーバヘッドを誘引することになります。このオーバヘッドを回避するには、一度追加された次元を前もって落とし、かつこれを永続化するのが適当かも知れません。</p><pre class="programlisting">UPDATE mytable SET the_geom = ST_Force2D(the_geom); 
VACUUM FULL ANALYZE mytable;</pre><p>AddGeometryColumn()を使ってジオメトリカラムを追加した場合、ジオメトリの次元に関する制限があることに注意してください。この制限を迂回するには、制限の削除が必要になります。geometry_columnsテーブル内のエントリを更新して、その後で制限を再作成することを忘れないで下さい。</p><p>大きなテーブルの場合、WHERE節、およびプライマリキー若しくは他の適切な基準によってテーブルの一部へのUPDATEを制限させて、UPDATEの実行の間に単に"VACUUM;"と実行することで、UPDATEをより小さい塊に分割するのが賢いやり方かもしれません。これにより、テンポラリディスクスペースが劇的に減少します。さらに、次元混合のジオメトリを持つ場合、"WHERE dimension(the_geom)
&gt;2"によってUPDATEを制限することで、2次元で書かれているジオメトリの再書き込みをスキップさせることができます。</p></div><div class="sect1" title="7.4. コンフィギュレーションのチューン"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database_tuning_configuration"></a>7.4. コンフィギュレーションのチューン</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="performance_tips.html#idp69699664">7.4.1. 起動時</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp69710800">7.4.2. 実行時</a></span></dt></dl></div><p>この技法は、FOSS4G 2007カンファレンスでのKevin Neufeldさんのプレゼンテーション「PostGISパワーユーザのための技法(Tips for the PostGIS Power User)」から得たものです。 PostGISの使用(たとえば、「静的データと複雑な解析」対「よくアップデートされるデータと多数のユーザ」など)に依存して、これらの変更によって、クエリがはっきり速度向上するようになります。</p><p>詳細情報(およびよりよい書式)については、オリジナルのプレゼンテーションが<a class="ulink" href="http://2007.foss4g.org/presentations/view.php?abstract_id=117" target="_top"> http://2007.foss4g.org/presentations/view.php?abstract_id=117</a>にあります。  </p><div class="sect2" title="7.4.1. 起動時"><div class="titlepage"><div><div><h3 class="title"><a name="idp69699664"></a>7.4.1. 起動時</h3></div></div></div><p> これらの設定はpostgresql.conf内にあります。  </p><p>
          <a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-CHECKPOINT-SEGMENTS" target="_top">checkpoint_segments</a>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>自動WALチェックポイント間のログファイルのセグメント(1セグメントは通常16MB)の数です。デフォルトは3です。  </p></li><li class="listitem"><p>書き込み処理が多いデータベースごとに少なくとも10から30を設定します。大きいデータベース負荷がかかる場合は増やします。この話題に関する別の記事として、<a class="ulink" href="http://www.westnet.com/~gsmith/content/postgresql/chkp-bgw-83.htm" target="_top">Greg Smith: Checkpoint and Background writer</a>は読む価値があります。  </p></li><li class="listitem"><p>できればxlogは別のディスク装置に保存します。 </p></li></ul></div><p>
           <a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-query.html#GUC-CONSTRAINT-EXCLUSION" target="_top">constraint_exclusion</a>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>デフォルト: off (PostgreSQL 8.4より前の場合。PostgreSQL 8.4以上はpartitionに設定)  </p></li><li class="listitem"><p>一般的にテーブルのパーティショニングに使われます。PostgreSQL 8.4より前を使用している場合、"on"にして、クエリプランナに対して求めるような最適化をさせます。 PostgreSQL 8.4からは、デフォルトは"partition"になっています。この場合、制約やテーブルが継承階層の中にあって、クエリプランナに他のペナルティを与えない場合に、制約を考慮に入れたテーブルの解析を強制します。PostgreSQL 8.4以上ではこれが理想的です。  </p></li></ul></div><p>
           <a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-SHARED-BUFFERS" target="_top">shared_buffers</a>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>デフォルト: ~32MB  </p></li><li class="listitem"><p>有効RAMの1/3から3/4程度にします。  </p></li></ul></div></div><div class="sect2" title="7.4.2. 実行時"><div class="titlepage"><div><div><h3 class="title"><a name="idp69710800"></a>7.4.2. 実行時</h3></div></div></div><p><a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-WORK-MEM" target="_top">work_mem</a>(並べ替えや複雑なクエリに使われるメモリ) </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>デフォルトt: 1MB  </p></li><li class="listitem"><p>大きなデータベースの場合や、複雑なクエリの場合、RAMが多い場合は値を大きくするように調整します。  </p></li><li class="listitem"><p>同時接続ユーザ数が多い場合や、RAMが少ない場合には値を小さくするように調整します。  </p></li><li class="listitem"><p>たくさんのRAMを持ち、少数の開発者しかいない場合は次のようにします。  </p><pre class="programlisting">SET work_mem TO 1200000;
                </pre><p>
            </p></li></ul></div><p><a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM" target="_top">maintenance_work_mem</a>(VACUUM, CREATE INDEX等で使われるメモリ) </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>デフォルト: 16MB  </p></li><li class="listitem"><p>一般的には低すぎます - メモリスワップの間、入出力が拘束され、オブジェクトがロックされます。  </p></li><li class="listitem"><p>本番サーバでは32MBから256MBが推奨ですが、同時接続ユーザ数に依存します。たくさんのRAMを持ち、少数の開発者しかいない場合は次のようにします。 </p><pre class="programlisting">SET maintainence_work_mem TO 1200000;
                </pre><p>
            </p></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">戻る</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第6章 PostGISを使う: アプリケーションを構築する </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第8章 PostGISリファレンス</td></tr></table></div></body></html>
