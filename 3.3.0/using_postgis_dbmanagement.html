<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 4. データ管理</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.3.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.3.0 マニュアル"><link rel="prev" href="postgis_administration.html" title="Chapter 3. PostGIS管理"><link rel="next" href="using_postgis_query.html" title="Chapter 5. 空間クエリ"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. データ管理</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="postgis_administration.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="using_postgis_query.html">Next</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="using_postgis_dbmanagement"></a>Chapter 4. データ管理</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#RefObject">4.1. 空間データ モデル</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OGC_Geometry">4.1.1. OGC ジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#SQL_MM_Part3">4.1.2. SQL/MM Part 3 - 曲線</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OpenGISWKBWKT">4.1.3. WKTとWKB</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#PostGIS_Geometry">4.2. ジオメトリデータタイプ</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#EWKB_EWKT">4.2.1. PostGIS EWKBとEWKT</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#PostGIS_Geography">4.3. ジオグラフィデータタイプ</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Geography_Tables">4.3.1. ジオグラフィテーブルの生成</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Use_Geography_Tables">4.3.2. ジオグラフィテーブルの使用</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_GeographyVSGeometry">4.3.3. ジオグラフィ型を使用すべき時</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_Geography_AdvancedFAQ">4.3.4. ジオグラフィに関する高度なよくある質問</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#OGC_Validity">4.4. ジオメトリ検証</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Simple_Geometry">4.4.1. 単純ジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Valid_Geometry">4.4.2. 妥当なジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Managing_Validity">4.4.3. 妥当性の管理</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#spatial_ref_sys">4.5. 空間参照系</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spatial_ref_sys_table">4.5.1. SPATIAL_REF_SYSテーブル</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#user-spatial-ref-sys">4.5.2. ユーザ定義空間参照系</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#idp53141968">4.6. 空間テーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Spatial_Table">4.6.1. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#geometry_columns">4.6.2. GEOMETRY_COLUMNSビュー</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Manual_Register_Spatial_Column">4.6.3. 手動でジオメトリカラムをgeometry_columnsに登録する</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#loading-data">4.7. 空間データのロード</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#load-data-sql">4.7.1. SQLを使ってロードする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#shp2pgsql_usage">4.7.2. シェープファイルローダを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#extracting-data">4.8. 空間データの抽出</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#extract-data-sql">4.8.1. SQLを使ってデータを抽出する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#pgsql2shp-usage">4.8.2. ダンパを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#build-indexes">4.9. 空間インデックス</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#gist_indexes">4.9.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#brin_indexes">4.9.2. BRINインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spgist_indexes">4.9.3. SP-GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#tuning-index-usage">4.9.4. インデックス使用のチューニング</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. 空間データ モデル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OGC_Geometry">4.1.1. OGC ジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#SQL_MM_Part3">4.1.2. SQL/MM Part 3 - 曲線</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OpenGISWKBWKT">4.1.3. WKTとWKB</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="OGC_Geometry"></a>4.1.1. OGC ジオメトリ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#Point">4.1.1.1. ポイント (Point)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#LineString">4.1.1.2. ラインストリング (LineString)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#LinearRing">4.1.1.3. リニアリング (LinearRing)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#Polygon">4.1.1.4. ポリゴン (Polygon)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#MultiPoint">4.1.1.5. マルチポイント (MultiPoint)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#MultiLineString">4.1.1.6. マルチラインストリング (MultiLineString)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#MultiPolygon">4.1.1.7. マルチポリゴン (MultiPolygon)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#GeometryCollection">4.1.1.8. ジオメトリコレクション (GeometryCollection)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#PolyhedralSurface">4.1.1.9. 多面体サーフェス (PolyhedralSurface)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#Triangle">4.1.1.10. 三角形 (Triangle)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#TIN">4.1.1.11. TIN</a></span></dt></dl></div><p>Open Geospatial Consortium (OGC)は、地理空間データのモデルを提供するために<a class="ulink" href="https://www.ogc.org/standards/sfa" target="_top"><span class="emphasis"><em>Simple Features Access</em></span></a> (SFA)標準を開発しました。これは、<span class="bold"><strong>ジオメトリ (Geometry)</strong></span>の基本的な空間タイプを、空間解析処理実行のための操作や変換といった演算に沿って定義します。 </p><p>ジオメトリは<span class="emphasis"><em>抽象的な</em></span>タイプです。ジオメトリ値は複数ある<span class="emphasis"><em>具体的な</em></span>サブタイプの一つに属します。サブタイプは様々な種類の様々な次元のジオメトリの形状を表現するものです。これらには<span class="bold"><strong>原子的な</strong></span>タイプである<a class="link" href="using_postgis_dbmanagement.html#Point" title="4.1.1.1. ポイント (Point)">ポイント (Point)</a>、<a class="link" href="using_postgis_dbmanagement.html#LineString" title="4.1.1.2. ラインストリング (LineString)">ラインストリング (LineString)</a>、<a class="link" href="using_postgis_dbmanagement.html#LinearRing" title="4.1.1.3. リニアリング (LinearRing)">リニアリング (LinearRing)</a>、<a class="link" href="using_postgis_dbmanagement.html#Polygon" title="4.1.1.4. ポリゴン (Polygon)">ポリゴン (Polygon)</a>があります。また、<a class="link" href="using_postgis_dbmanagement.html#MultiPoint" title="4.1.1.5. マルチポイント (MultiPoint)">マルチポイント (MultiPoint)</a>、<a class="link" href="using_postgis_dbmanagement.html#MultiLineString" title="4.1.1.6. マルチラインストリング (MultiLineString)">マルチラインストリング (MultiLineString)</a>、<a class="link" href="using_postgis_dbmanagement.html#MultiPolygon" title="4.1.1.7. マルチポリゴン (MultiPolygon)">マルチポリゴン (MultiPolygon)</a>、<a class="link" href="using_postgis_dbmanagement.html#GeometryCollection" title="4.1.1.8. ジオメトリコレクション (GeometryCollection)">ジオメトリコレクション (GeometryCollection)</a>の<span class="bold"><strong>コレクション (collection)</strong></span> (訳注: 「マルチ系」と書いている場合があります)タイプがあります。 <a class="ulink" href="https://portal.ogc.org/files/?artifact_id=25355" target="_top"><span class="emphasis"><em>Simple Features Access - Part 1: Common architecture v1.2.1</em></span></a>では<a class="link" href="using_postgis_dbmanagement.html#PolyhedralSurface" title="4.1.1.9. 多面体サーフェス (PolyhedralSurface)">多面体サーフェス (PolyhedralSurface)</a>、<a class="link" href="using_postgis_dbmanagement.html#Triangle" title="4.1.1.10. 三角形 (Triangle)">三角形 (Triangle)</a>、<a class="link" href="using_postgis_dbmanagement.html#TIN" title="4.1.1.11. TIN">TIN</a>が追加されています。 </p><p>ジオメトリは2次元デカルト平面上の形状をモデル化しています。多面体サーフェス、三角形、TINは3次元空間内の形状を表現することもできます。形状のサイズと位置は<span class="bold"><strong>座標</strong></span>によって指定されます。それぞれの座標は、平面上で位置を判定するXとYの<span class="bold"><strong>座標軸</strong></span>値を持っています。形状はポイントと線分から構築され、ポイントは単一の座標で定められ、線分は二つの座標値から定められます。 </p><p>座標は任意軸ZとMを持つことができます。Z軸はしばしば標高を示すために使われます。M軸は計測値が入りますが、計測値は時間であったり距離であったりします。Z値またはM値はジオメトリ値の中にあり、ジオメトリの各ポイントで定義されているものです。ジオメトリがZ値またはM値を持っている場合には<span class="bold"><strong>座標次元</strong></span>は三次元です。Z値とM値の両方を持っている場合には四次元です。 </p><p>ジオメトリ値は、そのジオメトリが組み込まれている座標系を示す<span class="bold"><strong>空間参照系</strong></span>に関連付けられます。空間参照系はジオメトリのSRID番号で識別されます。
X軸とY軸の単位は空間参照系によって決まります。<span class="bold"><strong>平面</strong></span>参照系では伝統的にX座標値とY座標値が東、北をそれぞれ示します。<span class="bold"><strong>地理</strong></span>参照系では、経度と緯度を表現しています。
SRIDが0の場合には、軸の単位が無い、無限の直交平面を表します。<a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. 空間参照系">Section 4.5, “空間参照系”</a>を参照して下さい。 </p><p>ジオメトリの<span class="bold"><strong>次元</strong></span>は、ジオメトリタイプのプロパティです。ポイントタイプは0次元、ラインタイプは1次元、ポリゴンタイプは2次元、コレクションは要素の次元の最大値、となります。 </p><p>ジオメトリ値は<span class="bold"><strong>empty</strong></span>になることがあります。空値とは、非マルチ系ジオメトリの場合は頂点を持っていないという意味で、コレクションでは要素を持っていないという意味です。 </p><p>ジオメトリ値の重要なプロパティは<span class="bold"><strong>範囲 (extent)</strong></span>または<span class="bold"><strong>バウンディングボックス (bounding box)</strong></span>です。OGCモデルでは<span class="bold"><strong>エンベロープ (envelope)</strong></span>と呼ばれています。これは、ジオメトリの座標を囲む2次元または3次元のボックスです。ジオメトリの座標空間内の範囲を表現するための、また、二つのジオメトリの相互関係をチェックするための、効率の良い方法です。 </p><p>ジオメトリモデルでは、<a class="xref" href="using_postgis_query.html#DE-9IM" title="5.1.1. Dimensionally Extended 9-Intersection Model">Section 5.1.1, “Dimensionally Extended 9-Intersection Model”</a>に示されている通り、トポロジ空間関係を評価することができます。これに対応するために、<span class="bold"><strong>内部 (interior)</strong></span>、<span class="bold"><strong>境界 (boundary)</strong></span>、<span class="bold"><strong>外部 (exterior)</strong></span>の概念が、ジオメトリタイプ毎に定義されます。ジオメトリはトポロジ的に閉じていて、常に境界を持っています。境界の次元はジオメトリの次元より1小さくなります。 </p><p>OGCジオメトリモデルは、ジオメトリタイプ毎に妥当性規則が定義されています。これらの規則によって、ジオメトリ値が現実的な状況を示すようになります (たとえば、外部に穴を持つポリゴンを指定できますが、ジオメトリ的に無意味であり、よって不正とします)。PostGISは不正なジオメトリ値を格納、操作することができます。これによって、必要なら修正できることになります。<a class="xref" href="using_postgis_dbmanagement.html#OGC_Validity" title="4.4. ジオメトリ検証">Section 4.4, “ジオメトリ検証”</a>を参照して下さい。 </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Point"></a>4.1.1.1. ポイント (Point)</h4></div></div></div><p>ポイントは、座標空間内の一つの位置を表現する0次元ジオメトリです。</p><pre class="programlisting">POINT (1 2)
POINT Z (1 2 3)
POINT ZM (1 2 3 4)
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="LineString"></a>4.1.1.2. ラインストリング (LineString)</h4></div></div></div><p>ラインストリングは連続する一連の線分で形成される1次元のラインです。線分はそれぞれ2点で定義付けられ、ある線分の終点は次の線分の始点を形成します。OGC妥当なラインストリングには、0または2以上のポイントがあります。ただしPostGISはラインストリングの一つのポイントを許容します。ラインストリングは、自身とクロスする場合があります (自己交差)。始端と終端とが同じ場合にはラインストリングは<span class="bold"><strong>閉じた</strong></span>ことになります。自己交差しない場合には、ラインストリングは<span class="bold"><strong>単純</strong></span>です。 </p><pre class="programlisting">LINESTRING (1 2, 3 4, 5 6)</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="LinearRing"></a>4.1.1.3. リニアリング (LinearRing)</h4></div></div></div><p>リニアリングは閉じていて、かつ単純なラインスリングです。始端と終端は同じでなければなりませんし、ラインは自己交差してはなりません。</p><pre class="programlisting">LINEARRING (0 0 0, 4 0 0, 4 4 0, 0 4 0, 0 0 0)</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Polygon"></a>4.1.1.4. ポリゴン (Polygon)</h4></div></div></div><p>ポリゴンは2次元平面領域です。一つの外側の境界 (殻)と0個以上の内の境界 (穴)とで区切られています。それぞれの境界は<a class="link" href="using_postgis_dbmanagement.html#LinearRing" title="4.1.1.3. リニアリング (LinearRing)">リニアリング</a>です。 </p><pre class="programlisting">POLYGON ((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="MultiPoint"></a>4.1.1.5. マルチポイント (MultiPoint)</h4></div></div></div><p>マルチポイントはポイントのコレクションです。</p><pre class="programlisting">MULTIPOINT ( (0 0), (1 2) )</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="MultiLineString"></a>4.1.1.6. マルチラインストリング (MultiLineString)</h4></div></div></div><p>マルチラインストリングはラインストリングのコレクションです。各要素が閉じている場合には、そのマルチラインストリングは閉じています。 </p><pre class="programlisting">MULTILINESTRING ( (0 0,1 1,1 2), (2 3,3 2,5 4) )</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="MultiPolygon"></a>4.1.1.7. マルチポリゴン (MultiPolygon)</h4></div></div></div><p>マルチポリゴンは相互にオーバラップも隣接もしていないポリゴンのコレクションです。コレクション内のポリゴンの接触は有限数のポイントでのみ可能です。 </p><pre class="programlisting">MULTIPOLYGON (((1 5, 5 5, 5 1, 1 1, 1 5)), ((6 5, 9 1, 6 1, 6 5)))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="GeometryCollection"></a>4.1.1.8. ジオメトリコレクション (GeometryCollection)</h4></div></div></div><p>ジオメトリコレクションは、ジオメトリの異種 (混合)のコレクションです。</p><pre class="programlisting">GEOMETRYCOLLECTION ( POINT(2 3), LINESTRING(2 3, 3 4))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="PolyhedralSurface"></a>4.1.1.9. 多面体サーフェス (PolyhedralSurface)</h4></div></div></div><p>多角形はサーフェスは、パッチまたはエッジを共有する面の隣接するコレクションです。それぞれのパッチは平面ポリゴンです。ポリゴンがZ値を持つ場合には、サーフェスは3次元になります。</p><pre class="programlisting">POLYHEDRALSURFACE Z (
  ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
  ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),
  ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
  ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),
  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Triangle"></a>4.1.1.10. 三角形 (Triangle)</h4></div></div></div><p>三角形は三つの異なる非共線頂点で定義されるポリゴンです。三角形はポリゴンですので、四つの座標で指定され、一つ目と四つ目は同じです。 </p><pre class="programlisting">TRIANGLE ((0 0, 0 9, 9 0, 0 0))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="TIN"></a>4.1.1.11. TIN</h4></div></div></div><p>TINは<a class="ulink" href="https://en.wikipedia.org/wiki/Triangulated_irregular_network" target="_top">Triangulated Irregular Network</a>を表現する、オーバラップしない<a class="link" href="using_postgis_dbmanagement.html#Triangle" title="4.1.1.10. 三角形 (Triangle)">三角形</a>のコレクションです。 </p><pre class="programlisting">TIN Z ( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="SQL_MM_Part3"></a>4.1.2. SQL/MM Part 3 - 曲線</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#CircularString">4.1.2.1. 曲線ストリング (CircularStringCircularString)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#CompoundCurve">4.1.2.2. 複合曲線 (CompoundCurve)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#CurvePolygon">4.1.2.3. 曲線ポリゴン (CurvePolygon)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#MultiCurve">4.1.2.4. マルチ曲線 (Multicurve)</a></span></dt><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#MultiSurface">4.1.2.5. マルチサーフェス (MultiSurface)</a></span></dt></dl></div><p><a class="ulink" href="https://www.iso.org/obp/ui/#iso:std:iso-iec:13249:-3:ed-5:v1:en" target="_top"><span class="emphasis"><em>ISO/IEC 13249-3 SQL Multimedia - Spatial</em></span></a>標準 (SQL/MM) は、OGC SFAを拡張して、曲線ジオメトリを含むサブタイプを定義しています。SQL/MMタイプはXYM, XYZ, XYZMに対応します。 </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>SQL-MM実装での全ての浮動小数点数の比較では、所定の丸め誤差があります。現在は1E-8です。</p></td></tr></table></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="CircularString"></a>4.1.2.1. 曲線ストリング (CircularStringCircularString)</h4></div></div></div><p>曲線ストリングは、基本的な曲線タイプです。線形の世界のラインストリングに似ています。単一の円弧線分は、始点、終点 (1番目と3番目)、弧の他の点の三つの点で定義されます。閉じた円を指定するには、開始点と終了点を同じにし、中間点を対称点 (円弧の中心)に置きます。連続する円弧では、前の円弧の終端と次の円弧の始端とが同じです。よって曲線ストリングは1以上の奇数個のポイントを持つことになります。</p><pre class="programlisting">CIRCULARSTRING(0 0, 1 1, 1 0)

CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="CompoundCurve"></a>4.1.2.2. 複合曲線 (CompoundCurve)</h4></div></div></div><p>複合曲線は、曲線区間と直線区間の両方を含むことができる単一の連続した曲線です。このことは、整形された要素を持つことに加えて、全ての要素の最後のポイントは次の要素の最初のポイントでなければならないことを意味します。</p><pre class="programlisting">COMPOUNDCURVE( CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="CurvePolygon"></a>4.1.2.3. 曲線ポリゴン (CurvePolygon)</h4></div></div></div><p>曲線ポリゴンは、外側の輪がひとつで0以上の内側のリングがある点はポリゴンに似ています。違いは、ポリゴンのリングはラインストリングですが曲線ポリゴンのリングは曲線ストリングまたは複合ストリングである点です。 </p><p>PostGIS 1.4から、PostGISで曲線ポリゴンで複合曲線をサポートするようになりました。</p><pre class="programlisting">CURVEPOLYGON(
  CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),
  (1 1, 3 3, 3 1, 1 1) )</pre><p>例: CIRCULARSTRINGとLINESTRINGからなるCOMPOUNDCURVEで定義される外殻を持ち、CIRCULARSTRINGで定義される穴を持つCURVEPOLYGON</p><pre class="programlisting">CURVEPOLYGON(
  COMPOUNDCURVE( CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),
                 (4 3, 4 5, 1 4, 0 0)),
  CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="MultiCurve"></a>4.1.2.4. マルチ曲線 (Multicurve)</h4></div></div></div><p>マルチ曲線は曲線のコレクションで、ラインストリング、曲線ストリング、複合曲線を含むことができます。</p><pre class="programlisting">MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4))</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="MultiSurface"></a>4.1.2.5. マルチサーフェス (MultiSurface)</h4></div></div></div><p>マルチサーフェスはサーフェスのコレクションです。サーフェスは(線形)ポリゴンまたは曲線ポリゴンとなることができます。</p><pre class="programlisting">MULTISURFACE(
  CURVEPOLYGON(
    CIRCULARSTRING( 0 0, 4 0, 4 4, 0 4, 0 0),
    (1 1, 3 3, 3 1, 1 1)),
  ((10 10, 14 12, 11 10, 10 10), (11 11, 11.5 11, 11 11.5, 11 11)))</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="OpenGISWKBWKT"></a>4.1.3. WKTとWKB</h3></div></div></div><p>OGC SFA仕様では、ジオメトリ値を外部で使用するための表現として二つの標準書式が定義されています。Well-Known Text (WKT)とWell-Known Binary (WKB)です。WKTとWKBは両方ともそのオブジェクトを定義するタイプと座標に関する情報を含んでいます。</p><p>Well-Known Text (WKT)で空間データの標準的な文字表現が可能です。空間オブジェクトのWKT表現の例を次に挙げます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0)</p></li><li class="listitem"><p>POINT Z (0 0 0)</p></li><li class="listitem"><p>POINT ZM (0 0 0 0)</p></li><li class="listitem"><p>POINT EMPTY</p></li><li class="listitem"><p>LINESTRING(0 0,1 1,1 2)</p></li><li class="listitem"><p>LINESTRING EMPTY</p></li><li class="listitem"><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li class="listitem"><p>MULTIPOINT((0 0),(1 2))</p></li><li class="listitem"><p>MULTIPOINT Z ((0 0 0),(1 2 3))</p></li><li class="listitem"><p>MULTIPOINT EMPTY</p></li><li class="listitem"><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION EMPTY</p></li></ul></div><p>WKTの入出力は関数<a class="xref" href="ST_AsText.html" title="ST_AsText">ST_AsText</a>と<a class="xref" href="ST_GeomFromText.html" title="ST_GeomFromText">ST_GeomFromText</a>によって提供されます。</p><pre class="programlisting">text WKT = ST_AsText(geometry);
geometry = ST_GeomFromText(text WKT, SRID);</pre><p>例えば、WKTとSRIDからの空間オブジェクトの生成と挿入のステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre><p>Well-Known Binary (WKB)は、空間データのバイナリデータ (バイト列)で、移植可能かつ正確な表現です。空間オブジェクトのWKB表現を次に挙げます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>WKT: POINT(1 1)</p><p>WKB: 0101000000000000000000F03F000000000000F03</p></li><li class="listitem"><p>WKT: LINESTRING (2 2, 9 9)</p><p>WKB: 0102000000020000000000000000000040000000000000004000000000000022400000000000002240</p></li></ul></div><p>WKBの入出力は関数<a class="xref" href="ST_AsBinary.html" title="ST_AsBinary">ST_AsBinary</a>と<a class="xref" href="ST_GeomFromWKB.html" title="ST_GeomFromWKB">ST_GeomFromWKB</a>が提供されています。次のように使います。</p><pre class="programlisting">bytea WKB = ST_AsBinary(geometry);
geometry = ST_GeomFromWKB(bytea WKB, SRID);
</pre><p>たとえば、WKBから空間オブジェクトの生成、挿入は次のようにします。</p><pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromWKB('\x0101000000000000000000f03f000000000000f03f', 312), 'A Place');</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PostGIS_Geometry"></a>4.2. ジオメトリデータタイプ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#EWKB_EWKT">4.2.1. PostGIS EWKBとEWKT</a></span></dt></dl></div><p>PostGISは、<code class="varname">geometry</code>というPostgreSQIデータ型を定義して、OGC Simple Features model を実装しています。これで、内部タイプコード (<a class="xref" href="GeometryType.html" title="GeometryType">GeometryType</a>と<a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>参照)で全てのジオメトリのサブタイプを表現します。これにより、カラム型で定義されたテーブルの行として、空間地物をモデリングすることが可能となります。 </p><p><code class="varname">geometry</code>データ型は<span class="emphasis"><em>透過</em></span>です。ジオメトリ値に関する関数から全てにアクセスできることを意味します。関数によって、ジオメトリオブジェクトの生成、全ての内部フィールドへのアクセスと更新、新しいジオメトリ値の計算が可能です。PostGISは、OGC <a class="ulink" href="https://portal.ogc.org/files/?artifact_id=25354" target="_top"><span class="emphasis"><em>Simple feature access - Part 2: SQL option</em></span></a> (SFS)仕様で定義されている全ての関数に、他の多数の関数とあわせて対応しています。関数の完全な一覧は<a class="xref" href="reference.html" title="Chapter 8. PostGISリファレンス">Chapter 8, <i>PostGISリファレンス</i></a>をご覧下さい。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>PostGISは、空間関数にプリフィクス"ST_"を付けて、SFA標準に従っています。これは、"Spatial and Temporal (空間と時間)"を示していますが、標準の時間の部分はまだ開発していません。その代わりに"Spatial Type (空間タイプ)"と解釈できます。 </p></td></tr></table></div><p>SFA標準は、空間オブジェクトは空間参照系識別子 (SRID)を含むと規程しています。SRIDは、空間オブジェクトをデータベースに挿入するために生成した時に求められます (デフォルトとして0になるかも知れません)。<a class="xref" href="ST_SRID.html" title="ST_SRID">ST_SRID</a>と<a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. 空間参照系">Section 4.5, “空間参照系”</a>をご覧下さい。</p><p>ジオメトリのクエリを効率的にするため、PostGISでは様々な種類の空間インデクスを定義しています。詳細については<a class="xref" href="using_postgis_dbmanagement.html#build-indexes" title="4.9. 空間インデックス">Section 4.9, “空間インデックス”</a>と<a class="xref" href="using_postgis_query.html#using-query-indexes" title="5.2. 空間インデックスを使う">Section 5.2, “空間インデックスを使う”</a>をご覧下さい。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="EWKB_EWKT"></a>4.2.1. PostGIS EWKBとEWKT</h3></div></div></div><p>OGC SFA仕様は、まず2次元ジオメトリのみに対応しました。また、入出力表現にジオメトリのSRIDは取り入れていまません。OGC SFA仕様 1.2.1 (ISO 19125標準に準拠)では3次元 (XYZ)とM値 (XYMとXYZM)座標に対応するようになりましたが、SIRD値の取り込みは依然行われていません。</p><p>これらの制限のため、PostGISでは拡張書式であるEWKBとEWKTを定義しました。3次元 (XYZ, XYM)と4次元 (XYZN)座標系に対応し、SRID情報を取り込めるようにしました。すべてのジオメトリ情報を含めたので、PostGISはEWKBを格納用書式 (DUMPファイル等)として使えるようになりました。 </p><p>PostGISデータオブジェクトの「カノニカルな形式」のためにEWKBとEWKTを使います。入力では、バイナリデータのカノニカルな形式はEWKB、テキストデータについてはEWKBかEWKTが受け付けられます。これにより、HEXEWKBまたはEWKTのテキスト値から<code class="varname">::geometry</code>を使用してキャストを行い、ジオメトリ値が生成できるようになりました。出力では、バイナリのカノニカルな形式はEWKBで、テキストはHEXEWKB (HEXエンコードを施したEWKB)です。 </p><p>たとえば、この手続きでは、EWKTテキスト値からのキャストでジオメトリを生成して、HEXWKBのカノニカルな形式を使った出力を行います。</p><pre class="programlisting">SELECT 'SRID=4;POINT(0 0)'::geometry;
  geometry
  ----------------------------------------------------
  01010000200400000000000000000000000000000000000000
</pre><p>PostGIS EWKT出力はOGC WKTと次の通り相違点があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>XYZジオメトリでZ修飾子が省略されます。</p><p>OGC: POINT Z (1 2 3)</p><p>EWKT: POINT (1 2 3)</p></li><li class="listitem"><p>M値を含むXYMジオメトリ:</p><p>OGC: POINT M (1 2 3)</p><p>EWKT: POINTM (1 2 3)</p></li><li class="listitem"><p>4次元ジオメトリでZM修飾子を省略:</p><p>OGC: POINT ZM (1 2 3 4)</p><p>EWKT: POINT (1 2 3 4)</p></li></ul></div><p>EWKTは、次のようにOGC/ISO書式で発生しうる過剰次元と不整合を回避しています。 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT ZM (1 1)</p></li><li class="listitem"><p>POINT ZM (1 1 1)</p></li><li class="listitem"><p>POINT (1 1 1 1)</p></li></ul></div><div class="caution"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>PostGISの拡張書式はOGC書式の上位互換であり、全ての妥当なOGC WKB/WKTは妥当なEWKB/EWKTでもあります。しかし、OGCがPostGISの定義と衝突する方法で書式を拡張した場合には、将来的に書式を変更する可能性があります。ゆえに、この互換性に*頼るべきではありません*。</p></td></tr></table></div><p>空間オブジェクトのEWKTテキスト表現の例:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0 0) -- XYZ</p></li><li class="listitem"><p>SRID=32632;POINT(0 0) -- SRID付きXY</p></li><li class="listitem"><p>POINTM(0 0 0) -- XYM</p></li><li class="listitem"><p>POINT(0 0 0 0) -- XYZM</p></li><li class="listitem"><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID付きXYM</p></li><li class="listitem"><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))</p></li><li class="listitem"><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )</p></li><li class="listitem"><p>MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )</p></li><li class="listitem"><p>POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</p></li><li class="listitem"><p>TRIANGLE ((0 0, 0 10, 10 0, 0 0))</p></li><li class="listitem"><p>TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</p></li></ul></div><p>これらの書式を使う入出力は次の関数を使うと有効です。</p><pre class="programlisting">バイト配列 EWKB = ST_AsEWKB(geometry);
テキスト EWKT = ST_AsEWKT(geometry);
ジオメトリ = ST_GeomFromEWKB(bytea EWKB);
ジオメトリ = ST_GeomFromEWKT(text EWKT);</pre><p>たとえば、EWKTを使ってPostGISの空間オブジェクトを作成し挿入するステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PostGIS_Geography"></a>4.3. ジオグラフィデータタイプ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Geography_Tables">4.3.1. ジオグラフィテーブルの生成</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Use_Geography_Tables">4.3.2. ジオグラフィテーブルの使用</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_GeographyVSGeometry">4.3.3. ジオグラフィ型を使用すべき時</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_Geography_AdvancedFAQ">4.3.4. ジオグラフィに関する高度なよくある質問</a></span></dt></dl></div><p><code class="varname">geography</code>データタイプによって地理座標 ("geographic", "geodetic", "lat/lon", "lon/lat"など)上の空間地物表現にネイティブに対応できます。地理座標系は角度 (度)単位で表現される球面座標系です。 </p><p>PostGISジオメトリ型の基礎は平面です。平面上の2点間の最短経路は直線です。ジオメトリに関する関数 (面積、距離、長さ、インタセクション等)は直線ベクトルとデカルト平面を使って計算しています。これで実装が簡単になり実行速度も上がりますが、地球の球面の上にあるデータについては不正確になります。 </p><p>PostGISジオグラフィというデータ型は球面モデルに基づいています。球面上の2点の最短経路は大円の弧にあたります。ジオグラフィの関数 (面積、距離、長さ、インタセクション等)は球面上の弧を使います。球面上の世界の形状を考慮に入れるので、より正確な結果が得られます。</p><p>基礎となる数学はより複雑になるため、ジオグラフィ型で定義された関数はジオメトリ型で定義された関数よりも少なくなります。時間が経つにつれて新しいアルゴリズムが追加されて、ジオグラフィの機能が拡大していきます。回避策として、ジオメトリ型とジオグラフィ型との相互変換が可能です。</p><p>ジオグラフィ型は、ジオメトリ型のように、空間参照系識別子 (SRID)を介して空間参照系と関連付けられます。<code class="varname">spatial_ref_sys</code>テーブルで定義されているあらゆる地理空間参照系 (経度/緯度を使う)が使えます (PostGIS 2.2より前ではジオグラフィ型はWGS 84地理座標系 (SRID:4326)にのみ対応していました)。<a class="xref" href="using_postgis_dbmanagement.html#user-spatial-ref-sys" title="4.5.2. ユーザ定義空間参照系">Section 4.5.2, “ユーザ定義空間参照系”</a>に書いている通り、独自の空間参照系を追加することもできます。</p><p>計測関数 (例 <a class="xref" href="ST_Distance.html" title="ST_Distance">ST_Distance</a>、<a class="xref" href="ST_Length.html" title="ST_Length">ST_Length</a>、<a class="xref" href="ST_Perimeter.html" title="ST_Perimeter">ST_Perimeter</a>、<a class="xref" href="ST_Area.html" title="ST_Area">ST_Area</a>)によって返されるものの単位と、<a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a>の引数で与えられる距離との、空間参照系の単位は、メートルです。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Create_Geography_Tables"></a>4.3.1. ジオグラフィテーブルの生成</h3></div></div></div><p>ジオグラフィデータを格納するテーブルは、SQLステートメント<a class="ulink" href="https://www.postgresql.org/docs/current/sql-createtable.html" target="_top">CREATE TABLE</a>に<code class="varname">geography</code>型のカラムを付けることで生成することができます。2次元ラインストリングをWGS84地理座標系 (SRID 4326)で保存するジオグラフィカラムを持つテーブルを生成する例を次に示します。</p><pre class="programlisting">CREATE TABLE global_points (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    location geography(POINT,4326)
  );</pre><p>二つの任意の型修飾子に対応するジオグラフィ型:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>空間の型修飾子は、カラム内で許される形状の種類や次元を規制します。値によって空間型はPOINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTIONが可能です。ジオグラフィ型は曲線や三角形、多面体サーフェスに対応していません。型修飾子に後置詞Z、M、ZMを付けることで、座標次元の制約に対応しています。たとえば、'LINESTRINGM'は、3次元で3番目の軸はMであるラインストリングのみを許します。同様に'POINTZM'では4次元 (XYZM)データが求められます。 </p></li><li class="listitem"><p>SRID修飾子は空間参照系(SRID)を特定の数値になるよう制約します。省略した場合には、デフォルトは4326 (WGS84地理座標系)となり、全ての計算はWGS84を使ったものになります。 </p></li></ul></div><p></p><p>ジオグラフィカラムを持つテーブルの生成の例を次に挙げます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>SRIDがデフォルトの4326 (WGS84 経度/緯度)である2次元ポイントジオグラフィを持つテーブルの生成:</p><pre class="programlisting">CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );</pre></li><li class="listitem"><p>NAD83緯度/経度の2次元ポイントジオグラフィを持つテーブルの生成:</p><pre class="programlisting">CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog geography(POINT,4269) );</pre></li><li class="listitem"><p>SRIDを4326で明示した3次元 (XYZ)ポイントジオグラフィを持つテーブルの生成:</p><pre class="programlisting">CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog geography(POINTZ,4326) );</pre></li><li class="listitem"><p>SRIDがデフォルトの4326である2次元ラインストリングジオグラフィを持つテーブルの生成:</p><pre class="programlisting">CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );</pre></li><li class="listitem"><p>SRIDがデ4326 (NAD 1927 経度/緯度)である2次元ポリゴンジオグラフィを持つテーブルの生成:</p><pre class="programlisting">CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog geography(POLYGON,4267) );</pre></li></ul></div><p>ジオグラフィカラムは<code class="varname">geography_columns</code>システムビューに登録されます。<code class="varname">geography_columns</code>ビューにクエリを出してテーブルを見るには、次の通りにします。</p><pre class="programlisting">SELECT * FROM geography_columns;</pre><p>空間インデックスはジオメトリカラムと同じように機能します。PostGISは、カラム型がジオグラフィであると通知したうえで、ジオメトリに使う通常の平面用インデックスでなく、球面を基にした適切なインデックスを生成します。</p><pre class="programlisting">-- testテーブルに球面インデックスを作成
CREATE INDEX global_points_gix ON global_points USING GIST ( location );</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Use_Geography_Tables"></a>4.3.2. ジオグラフィテーブルの使用</h3></div></div></div><p>ジオメトリと同じ方法でジオグラフィテーブルにデータを挿入できます。ジオメトリデータは、SRID 4326の場合には、ジオグラフィ型に自動キャストされます。<a class="link" href="using_postgis_dbmanagement.html#EWKB_EWKT" title="4.2.1. PostGIS EWKBとEWKT">EWKTとEWKB</a>書式はジオグラフィ値を指定するために使うことができます。</p><pre class="programlisting">-- testテーブルにデータを追加する
INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;POINT(-110 30)');
INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;POINT(-109 29)');
INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;POINT(0 49)');
</pre><p><code class="varname">spatial_ref_sys</code>テーブルにある地理 (経度/緯度)参照系は、ジオグラフィのSRIDとして指定することができます。非地理座標系を使うとエラーが発生します。 </p><pre class="programlisting">-- NAD 83 経度/緯度
SELECT 'SRID=4269;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AD1000000000000000C05EC00000000000004140
</pre><pre class="programlisting">-- NAD27 経度/緯度
SELECT 'SRID=4267;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AB1000000000000000C05EC00000000000004140
</pre><pre class="programlisting">-- NAD83 UTM zone メートル単位 - メートル単位の平面投影法なのでエラーが発生します
SELECT 'SRID=26910;POINT(-123 34)'::geography;

ERROR:  Only lon/lat coordinate systems are supported in geography.
</pre><p>クエリと計測関数はメートル単位となります。そのため距離パラメータはメートル (面積の場合は平方メートル)単位となります。</p><pre class="programlisting">-- 1000km範囲の距離に関するクエリ
SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;POINT(-110 29)'::geography, 1000000);</pre><p>シアトルからロンドンへの (LINESTRING(-122.33 47.606, 0.0 51.5))大円航路を行く航空機がレイキャビク (POINT(-21.96 64.15)) にどれだけ近づくかを計算することで、ジオグラフィの力を見ことができます (<a class="ulink" href="http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR" target="_top">航路の地図表示</a>)。 </p><p>ジオグラフィ型は、レイキャビクとシアトル－ロンドン間の大円航路との距離について、球面上で122.235 kmという本当の最短距離を計算します。</p><pre class="programlisting">-- GEOGRAPHYを使った距離計算
SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)'::geography);
   st_distance
-----------------
 122235.23815667</pre><p>ジオメトリ型では、平面の世界地図上で見て、レイキャビクとシアトル－ロンドン間の直線とのデカルト距離が計算され、意味がありません。計算結果の名目上の単位は「度」ですが、点間の本当の角度差に応じるものではなく、「度」と呼ぶこと自体が不正確です。</p><pre class="programlisting">-- GEOMETRYを使った距離計算
SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)'::geometry);
      st_distance
--------------------
 13.342271221453624
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="PostGIS_GeographyVSGeometry"></a>4.3.3. ジオグラフィ型を使用すべき時</h3></div></div></div><p>ジオグラフィ型によって、経度緯度座標でデータを格納できるようになりましたが、ジオグラフィで定義されている関数が、ジオメトリより少ないのと、実行にCPU時間がかかる、というところが犠牲になっています。</p><p>選択した型が、期待する領域から出ないことを、ジオメトリ型にして使用する条件とすべきです。使用するデータは地球全体か、大陸か、州か、自治体か? </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>データが小さいエリア内におさまるなら、適切な投影を選択してジオメトリを使うのが、効率面でも機能面でも最も良い方法です。</p></li><li class="listitem"><p>データが地球全体か大陸なら、ジオグラフィで投影法の細かい問題を気にせずにシステムを構築できるでしょう。経度/緯度のデータを保存して、ジオグラフィで定義された関数使います。</p></li><li class="listitem"><p>投影法を理解していなくて、学習したくもなくて、かつ、ジオグラフィで使える関数が限られていることを受け入れるのなら、ジオグラフィを使った方が簡単です。単純にデータを経度/緯度でロードして、そこから進めて下さい。</p></li></ul></div><p>ジオグラフィとジオメトリ間のサポート状況の比較については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_TypeFunctionMatrix" title="15.11. PostGIS関数対応マトリクス">Section 15.11, “PostGIS関数対応マトリクス”</a>をご覧下さい。ジオグラフィ関数の簡潔なリストと説明については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_GeographyFunctions" title="15.4. PostGISジオグラフィ対応関数">Section 15.4, “PostGISジオグラフィ対応関数”</a>をご覧下さい。 </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="PostGIS_Geography_AdvancedFAQ"></a>4.3.4. ジオグラフィに関する高度なよくある質問</h3></div></div></div><div class="qandaset"><a name="idp52945104"></a><dl><dt>4.3.4.1. <a href="using_postgis_dbmanagement.html#idp52945360">球または回転楕円体のどちらで計算するのでしょうか?</a></dt><dt>4.3.4.2. <a href="using_postgis_dbmanagement.html#idp52947664">日付変更線や極に関してはどうなっていますか?</a></dt><dt>4.3.4.3. <a href="using_postgis_dbmanagement.html#idp52949584">処理できる最も長い弧はどうなりますか?</a></dt><dt>4.3.4.4. <a href="using_postgis_dbmanagement.html#idp52951504">なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idp52945360"></a><a name="idp52945616"></a><p><b>4.3.4.1.</b></p></td><td align="left" valign="top"><p>球または回転楕円体のどちらで計算するのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>デフォルトでは、全ての距離と面積の計算は回転楕円体で行います。局所的なエリアでの計算結果と良好な投影を施した平面での結果と比較して下さい。大きなエリアの場合は、回転楕円体計算は、投影平面上でのどの計算よりも精度が高くなります。 </p><p>全てのジオグラフィ関数には、最後の真偽パラメータを'FALSE'にすると球面を使った計算を行うというオプションがあります。これは、特にジオメトリが非常に単純である場合に計算を速くするためのものです。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52947664"></a><a name="idp52947920"></a><p><b>4.3.4.2.</b></p></td><td align="left" valign="top"><p>日付変更線や極に関してはどうなっていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>全ての計算に日付変更線や極の概念がありません。座標は球 (経度/緯度)であるので、日付変更線とクロスする形状は、計算の観点からは、他のものと変わりありません。 </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52949584"></a><a name="idp52949840"></a><p><b>4.3.4.3.</b></p></td><td align="left" valign="top"><p>処理できる最も長い弧はどうなりますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>大圏の弧を2点の「補完線」として使用しています。任意の2点は、実際には2方向につながっていて、どちらの方向に行くかに依存します。PostGISの全てのコードは、大圏コースの2コースのうち*短い*方でつながっていると仮定しています。結果として、180度以上の弧を持つ形状は正しくモデル化されません。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52951504"></a><a name="idp52951760"></a><p><b>4.3.4.4.</b></p></td><td align="left" valign="top"><p>なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ポリゴンがとんでもなく大きいからです。二つの理由から、大きなエリアは悪いです。一つは、バウンダリボックスが大きいため、どのようなクエリを走らせても、インデックスがフィーチャーを引っ張ってくる傾向にあるためです。もう一つは、頂点数が巨大で、テスト (距離、包含)関数では、少なくとも1回、通常はN (Nは、もう一方のフィーチャーの頂点数)回、頂点を横断しなければならないためです。 </p><p>ジオメトリでは、大きなポリゴンを持っているけれども小さな範囲のクエリを実行する時、ジオメトリデータ情報を小片に「非正規化」します。これにより、インデックスが効果的にオブジェクトの一部を問い合わせるようになり、またクエリが常にオブジェクト全体を引っ張りこむようなことがないようになります。<a class="xref" href="ST_Subdivide.html" title="ST_Subdivide">ST_Subdivide</a>を参照して下さい。ヨーロッパ全体を一つのポリゴンに*格納できる*からといって、*そうすべき*だというわけではありません。</p></td></tr></tbody></table></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="OGC_Validity"></a>4.4. ジオメトリ検証</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Simple_Geometry">4.4.1. 単純ジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Valid_Geometry">4.4.2. 妥当なジオメトリ</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Managing_Validity">4.4.3. 妥当性の管理</a></span></dt></dl></div><p>PostGISはOpen Geospatial Consortium (OGC)のSimple Feature Specificationに準拠しています。この標準では、<span class="emphasis"><em>単純</em></span>なジオメトリと<span class="emphasis"><em>妥当</em></span>なジオメトリの概念が定義されています。これらの定義によって、Simple Featureのジオメトリモデルが一貫性があって、かつ明確な方法で空間オブジェクトを表現することができ、効率的な計算を助けます (OGC Simple FeatureとSQL/MMとにおいては、単純性と妥当性について同じ定義です)。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Simple_Geometry"></a>4.4.1. 単純ジオメトリ</h3></div></div></div><p><span class="emphasis"><em>単純</em></span>なジオメトリは、自己交差や自己接触といった異常な幾何学上のポイントを持たないジオメトリです。 </p><p><code class="varname">POINT</code>は0次元ジオメトリオブジェクトとして常に<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">MULTIPOINT</code>は、二つの座標値 (<code class="varname">POINT</code>)が同じでないなら<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">LINESTRING</code>は、同じポイントを二回通過しないものが<span class="emphasis"><em>単純</em></span>です。単純なラインストリングの端点が同一の場合には、<span class="emphasis"><em>閉じている</em></span>とされ、線形リングと呼ばれます。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="emphasis"><em><span class="bold"><strong>(a)</strong></span>と<span class="bold"><strong>(c)</strong></span>は単純な<code class="varname">LINESTRING</code>です。<span class="bold"><strong>(b)</strong></span>と<span class="bold"><strong>(d)</strong></span>は単純ではありません。<span class="bold"><strong>(c)</strong></span>は閉じた線形リングです。 </em></span></p></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple01.png"><div class="caption"><p><span class="bold"><strong>(a)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple02.png"><div class="caption"><p><span class="bold"><strong>(b)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple03.png"><div class="caption"><p><span class="bold"><strong>(c)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple04.png"><div class="caption"><p><span class="bold"><strong>(d)</strong></span></p></div></div></div></td></tr></tbody></table></div><p><code class="varname">MULTILINESTRING</code>は、要素が全て単純で、かつ、全ての要素同士のインタセクションが要素の境界上でのみ出現する場合には、<span class="emphasis"><em>単純</em></span>です。 </p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="emphasis"><em><span class="bold"><strong>(e)</strong></span>と<span class="bold"><strong>(f)</strong></span>は単純な<code class="varname">MULTILINESTRING</code>です。<span class="bold"><strong>(g)</strong></span>は単純ではありません。 </em></span></p></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple05.png"><div class="caption"><p><span class="bold"><strong>(e)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple06.png"><div class="caption"><p><span class="bold"><strong>(f)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple07.png"><div class="caption"><p><span class="bold"><strong>(g)</strong></span></p></div></div></div></td></tr></tbody></table></div><p><code class="varname">POLYGON</code>は線形リングから形成されるので、妥当なポリゴンジオメトリは常に<span class="emphasis"><em>単純</em></span>です。</p><p>ジオメトリが単純かどうかを試すには<a class="xref" href="ST_IsSimple.html" title="ST_IsSimple">ST_IsSimple</a>関数を使います。次のようにします。</p><pre class="programlisting">SELECT
   ST_IsSimple('LINESTRING(0 0, 100 100)') AS straight,
   ST_IsSimple('LINESTRING(0 0, 100 100, 100 0, 0 100)') AS crossing;

 straight | crossing
----------+----------
 t        | f
</pre><p>一般的にPostGIS関数は引数ジオメトリの単純性を求めていません。単純性は主にジオメトリの妥当性を定義するための基礎として用いられます。空間データモデルによっては要件としていることもあります (たとえば、線形ネットワークはしばしばクロスを認めません)。マルチポイントと線形ジオメトリは<a class="xref" href="ST_UnaryUnion.html" title="ST_UnaryUnion">ST_UnaryUnion</a>を使って単純にできます。 </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Valid_Geometry"></a>4.4.2. 妥当なジオメトリ</h3></div></div></div><p>ジオメトリの妥当性は主に2次元ジオメトリ (<code class="varname">POLYGON</code>と<code class="varname">MULTIPOLYGON</code>)に適用されます。妥当性はポリゴンジオメトリが平面領域を明確にモデル化できる規則によって定義されます。 </p><p><code class="varname">POLYGON</code>は次の条件では<span class="emphasis"><em>妥当</em></span>です。 </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ポリゴン境界リング (外側の殻リングと内側の穴リング)が<span class="emphasis"><em>単純</em></span> (交差も自己接触もしていない)であること。これによりポリゴンは切断線、トゲ、循環を持つことができなくなります。これは、ポリゴンの穴を外側のリングの自己接触 (いわゆる "inverted hole" (逆穴))でなく、内側のリングとして表現されなけれならないことを意味します。 </p></li><li class="listitem"><p>境界リングがクロスしないこと </p></li><li class="listitem"><p>境界リングは点で接触してもいいですが、接点としてでなければなりません (線上にあってはなりません)。 </p></li><li class="listitem"><p>内側リングは外側リング内にあること </p></li><li class="listitem"><p>ポリゴン内部は単純に接続されています (リングはポリゴンを複数に分割するように接触してはなりません)。 </p></li></ol></div><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="emphasis"><em><span class="bold"><strong>(h)</strong></span>と<span class="bold"><strong>(i)</strong></span>は妥当な<code class="varname">POLYGON</code>です。<span class="bold"><strong>(j-m)</strong></span>は不正です。<span class="bold"><strong>(j)</strong></span>は妥当な<code class="varname">MULTIPOLYGON</code>として表すことができます。 </em></span></p></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid01.png"><div class="caption"><p><span class="bold"><strong>(h)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid02.png"><div class="caption"><p><span class="bold"><strong>(i)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid03.png"><div class="caption"><p><span class="bold"><strong>(j)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid04.png"><div class="caption"><p><span class="bold"><strong>(k)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid05.png"><div class="caption"><p><span class="bold"><strong>(l)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid06.png"><div class="caption"><p><span class="bold"><strong>(m)</strong></span></p></div></div></div></td></tr></tbody></table></div><p><code class="varname">MULTIPOLYGON</code>は次の条件では<span class="emphasis"><em>妥当</em></span>です。 </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>要素となる<code class="varname">POLYGON</code>が妥当であること </p></li><li class="listitem"><p>要素がオーバラップしない (内部同士がインタセクトしない)こと </p></li><li class="listitem"><p>要素同士の接触が点でけである (線に沿って接触しない)こと </p></li></ol></div><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="emphasis"><em><span class="bold"><strong>(n)</strong></span>は妥当な<code class="varname">MULTIPOLYGON</code>です。<span class="bold"><strong>(o)</strong></span>と<span class="bold"><strong>(p)</strong></span>は不正です。 </em></span></p></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid09.png"><div class="caption"><p><span class="bold"><strong>(n)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid07.png"><div class="caption"><p><span class="bold"><strong>(o)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid08.png"><div class="caption"><p><span class="bold"><strong>(p)</strong></span></p></div></div></div></td></tr></tbody></table></div><p>これらの規則は妥当なポリゴンジオメトリも<span class="emphasis"><em>単純</em></span>であることも示しています。 </p><p>線ジオメトリについては、<code class="varname">LINESTRING</code>が少なくとも二つのポイントを持ち、長さが0でない (少なくとも二つの異なるポイントを持つことと同じ)、というのが唯一の妥当性規則です。単純でない (自己交差がある)ラインは妥当です。 </p><pre class="programlisting">SELECT
   ST_IsValid('LINESTRING(0 0, 1 1)') AS len_nonzero,
   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)') AS len_zero,
   ST_IsValid('LINESTRING(10 10, 150 150, 180 50, 20 130)') AS self_int;

 len_nonzero | len_zero | self_int
-------------+----------+----------
 t           | f        | t
</pre><p><code class="varname">POINT</code>と<code class="varname">MULTIPOINT</code>は妥当性規則を持っていません。 </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Managing_Validity"></a>4.4.3. 妥当性の管理</h3></div></div></div><p>PostGISは妥当なジオメトリも不正なジオメトリも、生成も格納もできます。このため、不正なジオメトリを検出し、フラグを付け、訂正することができます。OGC妥当性規則が求める規則 (長さが0のラインストリングや逆穴を持つポリゴン等)よりも厳格であることもあります。 </p><p>PostGISが提供する関数の多くは、引数ジオメトリが妥当であるとの仮定によっています。たとえば、ポリゴンの外部に穴があるポリゴンの面積を計算しても意味がありませんし、単純でない境界線からポリゴンを形成するのも意味がありません。妥当なジオメトリ入力を仮定することで、トポロジ的に正しいことを確認する必要がなくなるので、関数がより効率的に動作することができます (例外として、長さ0のラインと反転したポリゴンは一般的に正しく取り扱われます)。また、ほとんどのPostGIS関数は、入力ジオメトリが妥当な場合には、妥当なジオメトリ出力を生成します。これにより、PostGIS関数を安全に連鎖させられます。 </p><p>PostGIS関数を呼ぶときに予期しないエラーメッセージ ("GEOS Intersection() threw an error!"等)に遭遇する場合には、まず関数の引数が妥当かどうかを確認します。妥当でないなら、次に示す方法のいずれかによる、処理中のデータの妥当性の確認を検討して下さい。 </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>関数が妥当な入力でエラーを報告する場合には、PostGISまたは使用しているライブラリの一つの中にエラーがあるのを発見することがありますが、その際はPostGISプロジェクトに報告して下さい。PostGIS関数が妥当な入力から不正なジオメトリを返す場合も同様です。</p></td></tr></table></div><p>ジオメトリが妥当かをテストするには<a class="xref" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid</a>関数を使います。次のようにします。 </p><pre class="programlisting">SELECT ST_IsValid('POLYGON ((20 180, 180 180, 180 20, 20 20, 20 180))');
-----------------
 t
</pre><p>ジオメトリの不正性の性質と位置に関する情報は<a class="xref" href="ST_IsValidDetail.html" title="ST_IsValidDetail">ST_IsValidDetail</a>関数で得られます。次のようにします。 </p><pre class="programlisting">SELECT valid, reason, ST_AsText(location) AS location
    FROM ST_IsValidDetail('POLYGON ((20 20, 120 190, 50 190, 170 50, 20 20))') AS t;

 valid |      reason       |                  location
-------+-------------------+---------------------------------------------
 f     | Self-intersection | POINT(91.51162790697674 141.56976744186045)
</pre><p>不正なジオメトリを自動的に訂正することが望ましいような状況があります。その際は<a class="xref" href="ST_MakeValid.html" title="ST_MakeValid">ST_MakeValid</a>関数を使います (<code class="code">ST_MakeValid</code>は不正な入力を<span class="emphasis"><em>許す</em></span>特別な関数です)。 </p><p>複雑なジオメトリの不正性テストには多大なCPU時間を取ることになるため、デフォルトでは、ジオメトリのロード時にPostGISは妥当性の確認をしません。データソースが信用できない場合には、チェック制約を使って、テーブル上で妥当性を強制的に確認することができます。次のようにします。</p><pre class="programlisting">ALTER TABLE mytable
  ADD CONSTRAINT geometry_valid_check
        CHECK (ST_IsValid(geom));</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spatial_ref_sys"></a>4.5. 空間参照系</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spatial_ref_sys_table">4.5.1. SPATIAL_REF_SYSテーブル</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#user-spatial-ref-sys">4.5.2. ユーザ定義空間参照系</a></span></dt></dl></div><p><a class="ulink" href="https://en.wikipedia.org/wiki/Spatial_reference_system" target="_top">空間参照系</a> (Spatial Reference System, SRS) (座標参照系、Coordinate Reference System, CRSとも呼ばれます)は、ジオメトリが地表上の位置をどのように参照するかを定義しています。SRSには次の通り三種あります。 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>測地</strong></span> (geodetic) 空間参照系は、地表に直接対応付けられる極座標系 (経度と緯度)を使います。 </p></li><li class="listitem"><p><span class="bold"><strong>投影</strong></span> (projected)空間参照系は、回転楕円体面を「平面にする」ための数学的な投影変換を使います。距離、面積、角度といった量を直接計測することが可能な位置座標系です。この座標系はデカルト座標系ですので、原点と二つの直交軸 (通常は来北と東方向)が定義されています。個々の投影座標系は、定まった距離単位 (通常はメートルかフィート)を使います。投影座標系は、歪みを避けて定義された座標範囲に納めるために、適応範囲を制限してもいいことになっています。 </p></li><li class="listitem"><p><span class="bold"><strong>局所</strong></span> (local)座標系は、地表への参照がないデカルト座標系です。PostGISではSRID値を0に指定します。 </p></li></ul></div><p>使用されている空間参照系には多数の相違点があります。一般的空間参照系は欧州石油調査グループ (European Petroleum Survey Group)の<a class="ulink" href="http://www.epsg.org/" target="_top">EPSG database</a>で標準化されています。利便性向上のためPostGIS (と多くの空間系)はSRIDと呼ぶ整数を使って空間参照系の定義を参照します。 </p><p>ジオメトリは、SRID値で空間参照系に関連付けられています。SRID値の取得には<a class="xref" href="ST_SRID.html" title="ST_SRID">ST_SRID</a>を使います。ジオメトリのSRIDの設定には<a class="xref" href="ST_SetSRID.html" title="ST_SetSRID">ST_SetSRID</a>を使います。ジオメトリ構築関数の中には、SRIDを与えられるものもあります (<a class="xref" href="ST_Point.html" title="ST_Point">ST_Point</a>や<a class="xref" href="ST_MakeEnvelope.html" title="ST_MakeEnvelope">ST_MakeEnvelope</a>等)。<a class="link" href="using_postgis_dbmanagement.html#EWKB_EWKT" title="4.2.1. PostGIS EWKBとEWKT">EWKT</a>書式は<code class="code">SRID=n;</code>を前置することでSRIDに対応できます。 </p><p>二つのジオメトリを処理する空間関数 (<a class="link" href="reference.html#Overlay_Functions" title="8.13. 重ね合わせ関数">オーバレイ関数</a>や<a class="link" href="reference.html#Spatial_Relationships" title="8.11. 空間関係関数">空間関係関数</a>等)では、入力ジオメトリが同じ空間参照系でなければなりません (同じSRID値を持たなければなりません)。ジオメトリデータは<a class="xref" href="ST_Transform.html" title="ST_Transform">ST_Transform</a>を使うと異なる空間参照系に変換できます。関数から返されるジオメトリは入力ジオメトリと同じ空間参照系を持ちます。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spatial_ref_sys_table"></a>4.5.1. SPATIAL_REF_SYSテーブル</h3></div></div></div><p>PostGISが使用する<code class="varname">SPATIAL_REF_SYS</code>テーブルは利用可能な空間参照系を定義するOGC準拠のデータベーステーブルです。このテーブルは、数値でSRIDを持ち、文字列で座標系の記述を持っています。 </p><p><code class="varname">spatial_ref_sys</code>の定義は次の通りです。</p><pre class="programlisting">CREATE TABLE spatial_ref_sys (
  srid       INTEGER NOT NULL PRIMARY KEY,
  auth_name  VARCHAR(256),
  auth_srid  INTEGER,
  srtext     VARCHAR(2048),
  proj4text  VARCHAR(2048)
)</pre><p>カラムは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">srid</span></dt><dd><p>データベース内の<a class="ulink" href="http://en.wikipedia.org/wiki/SRID" target="_top">Spatial Reference System</a> (SRS, 空間参照系)で一意に識別される整数コードです。</p></dd><dt><span class="term">auth_name</span></dt><dd><p>この参照系に引用されている標準の名前もしくは標準そのものです。たとえば「EPSG」は妥当な<code class="varname">auth_name</code>です。</p></dd><dt><span class="term">auth_srid</span></dt><dd><p>空間参照系のIDは<code class="varname">auth_name</code>に引用される機関によって定義されます。ここがEPSGの場合には、これはEPSGコードです。</p></dd><dt><span class="term">srtext</span></dt><dd><p>空間参照系のWell-Knownテキスト表現です。たとえば、WKT SRSの表現は、次のようになります。</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
        DATUM["North_American_Datum_1983",
          SPHEROID["GRS 1980",6378137,298.257222101]
        ],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433]
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0],
  UNIT["metre",1]
]</pre><p>SRS WKTの詳細については、OGC標準の<a class="ulink" href="http://docs.opengeospatial.org/is/12-063r5/12-063r5.html" target="_top">Well-known text representation of coordinate reference systems</a>をご覧下さい。 </p></dd><dt><span class="term">proj4text</span></dt><dd><p>PostGISは座標変換機能を提供するためにProj4ライブラリを用いています。 <code class="varname">proj4text</code>カラムには、特定のSRIDを示すProj4座標定義文字列が入ります。たとえば次のようになります。</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>詳細情報については<a class="ulink" href="https://proj.org/" target="_top">PROJウェブサイト</a>をご覧下さい。<code class="filename">spatial_ref_sys.sql</code>ファイルには、全てのEPSG投影について、<code class="varname">srtext</code>と<code class="varname">proj4text</code>の定義があります。</p></dd></dl></div><p>投影変換で空間参照系の定義を使用する場合には、次の戦略を取ります。 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">auth_name</code>と<code class="varname">auth_srid</code>がある (NULLでない)場合には、これに基づいてPROJSRSを使います (存在する場合)。 </p></li><li class="listitem"><p><code class="varname">srtext</code>がある場合には、可能ならそれを使用してSRSを生成します。 </p></li><li class="listitem"><p><code class="varname">proj4text</code>がある場合には、可能ならこれを使用してSRSを生成します。 </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="user-spatial-ref-sys"></a>4.5.2. ユーザ定義空間参照系</h3></div></div></div><p>PostGIS<code class="varname">spatial_ref_sys</code>テーブルには<a class="ulink" href="https://proj.org/" target="_top">PROJ</a>投影ライブラリで処理される最も一般的な空間参照系定義3000件以上があります。しかし、そこに無い多くの座標系があります。空間参照系に関する必要な情報がある場合は、SRS定義をテーブルに追加できます。PROJに詳しいなら独自の空間参照系を定義することもできます。ほとんどの空間参照系は地域的なものであり、目的の範囲外で使用する場合は意味を持たない点に注意してください。</p><p>PostGISのコアセットに入っていない空間参照系を探すための素晴らしい資料が<a class="ulink" href="http://spatialreference.org/" target="_top">http://spatialreference.org/</a>にあります。</p><p>一般的に使用される空間参照系には<a class="ulink" href="http://spatialreference.org/ref/epsg/4326/" target="_top">4326 - WGS 84経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/4269/" target="_top">4269 - NAD 83 経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/3395/" target="_top">3395 - WGS 84 メルカトル</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/2163/" target="_top">2163 - 米国ナショナルアトラス正積図法</a>、60個のWGS84 UTMゾーンがあります。UTMゾーンは計測に最適ですが、6度 (訳注: 経度)の領域のみをカバーします (対象地域に使用するUTMゾーンを決定するには<a class="ulink" href="http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance" target="_top">utmzone PostGIS plpgsql helper function</a>を参照してください)。 </p><p>米国の州では、州平面空間参照系 (メートルまたはフィート単位)を使用します。この空間参照系は州ごとに一つか二つ存在します。ほとんどのメートル単位のものはコアのセットに存在しますが、フィート単位の多数のものやESRIが作成したものは<a class="ulink" href="http://spatialreference.org" target="_top">spatialreference.org</a>からロードする必要があります。 </p><p>地球外の座標系でさえも定義することができます。たとえば<a class="ulink" href="http://spatialreference.org/ref/iau2000/mars-2000/" target="_top">Mars 2000</a>です。この火星の座標系は非平面 (回転楕円体の度)ですが、<code class="varname">geography</code>型で、度でなくメートル単位で長さや近接測定値を取得することができます。</p><p>割当外のSRIDとPROJ定義を使って米国中央のランベルト正角円錐図法の独自座標系をロードする例を次に示します。</p><pre class="programlisting">INSERT INTO spatial_ref_sys (srid, proj4text)
VALUES ( 990000,
  '+proj=lcc  +lon_0=-95 +lat_0=25 +lat_1=25 +lat_2=25 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs'
);
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp53141968"></a>4.6. 空間テーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Spatial_Table">4.6.1. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#geometry_columns">4.6.2. GEOMETRY_COLUMNSビュー</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Manual_Register_Spatial_Column">4.6.3. 手動でジオメトリカラムをgeometry_columnsに登録する</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Create_Spatial_Table"></a>4.6.1. 空間テーブルを作る</h3></div></div></div><p><code class="varname">geometry</code>型のカラムを付けた<a class="ulink" href="https://www.postgresql.org/docs/current/sql-createtable.html" target="_top">CREATE TABLE</a> SQLステートメントでジオメトリデータを保存するテーブルを生成することができます。次の例では、BC-アルベルス座標系 (SRID 3005)の2次元 (XY)ラインストリングを保存するジオメトリカラムを持つテーブルを生成します。</p><pre class="programlisting">CREATE TABLE roads (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    geom geometry(LINESTRING,3005)
  );</pre><p><code class="varname">geometry</code>型は、次の通り、二つの任意指定<span class="bold"><strong>型修飾子</strong></span>に対応しています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> <span class="bold"><strong>空間タイプ修飾子</strong></span>はカラムで許される形状と次元の種類を制約するものです。値は、対応している<a class="link" href="using_postgis_dbmanagement.html#RefObject" title="4.1. 空間データ モデル">ジオメトリタイプ</a> (POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION等)なら全て可能です。空間タイプ修飾子は、後置詞 Z, M, ZMを付け加えることで座標次元の制約に対応します。例えば、`LINESTRINGM`修飾子では、3次元で3番目がM軸となるラインストリングだけを許します。同様に、'POINTZM'では4次元 (XYZM)データが求められます。 </p></li><li class="listitem"><p><span class="bold"><strong>SRID修飾子</strong></span>は<a class="link" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. 空間参照系">空間参照系</a>のSRIDを特定の数値に制約します。省略した場合には、デフォルトは0となります。
 restricts the <a class="link" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. 空間参照系">spatial reference system</a> SRID to a particular number. If omitted, the SRID defaults to 0. </p></li></ul></div><p></p><p>ジオグラフィカラムを持つテーブルの生成の例を次に挙げます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルトSRIDであらゆる種類のジオメトリを保持するテーブルの生成:</p><pre class="programlisting">CREATE TABLE geoms(gid serial PRIMARY KEY, geom geometry );</pre></li><li class="listitem"><p>2次元ポイントでSRIDがデフォルトのテーブル作成:</p><pre class="programlisting">CREATE TABLE pts(gid serial PRIMARY KEY, geom geometry(POINT) );</pre></li><li class="listitem"><p>3次元 (XYZ)ポイントでSRIDが3005のテーブル作成:</p><pre class="programlisting">CREATE TABLE pts(gid serial PRIMARY KEY, geom geometry(POINTZ,3005) );</pre></li><li class="listitem"><p>4次元 (XYZM)ラインストリングでSRIDがデフォルトのテーブル作成:</p><pre class="programlisting">CREATE TABLE lines(gid serial PRIMARY KEY, geom geometry(LINESTRINGZM) );</pre></li><li class="listitem"><p>2次元ポリゴンでSRIDが4276 (NAD 1927地理座標系)のテーブル作成:</p><pre class="programlisting">CREATE TABLE polys(gid serial PRIMARY KEY, geom geometry(POLYGON,4267) );</pre></li></ul></div><p>一つのテーブルが一つ以上のジオメトリカラムを持つことができます。テーブル生成時に指定するか、<a class="ulink" href="https://www.postgresql.org/docs/current/sql-altertable.html" target="_top">ALTER TABLE</a> SQLステートメントを使って追加するかで実現できます。次に3次元ラインストリングを格納するカラムを追加する例を示します。</p><pre class="programlisting">ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="geometry_columns"></a>4.6.2. GEOMETRY_COLUMNSビュー</h3></div></div></div><p>OGC <span class="emphasis"><em>Simple Features Specification for SQL</em></span>は、ジオメトリテーブル構造を記述するための<code class="varname">GEOMETRY_COLUMNS</code>メタデータテーブルを定義しています。PostGISでは<code class="varname">geometry_columns</code>は、データベースのシステムカタログテーブルから読み取るビューです。これによって、空間メタデータ情報が常に現在定義されているテーブルやビューと矛盾しなくなります。</p><pre class="programlisting">\d geometry_columns</pre><pre class="screen">View "public.geometry_columns"
      Column       |          Type          | Modifiers
-------------------+------------------------+-----------
 f_table_catalog   | character varying(256) |
 f_table_schema    | character varying(256) |
 f_table_name      | character varying(256) |
 f_geometry_column | character varying(256) |
 coord_dimension   | integer                |
 srid              | integer                |
 type              | character varying(30)  |</pre><p>カラムは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">f_table_catalog, f_table_schema, f_table_name</span></dt><dd><p>ジオメトリカラムを持っている地物テーブルの完全修飾名。PostgreSQLには"catalog"の類似カラムが無いので、このカラムは空白のままです。"schema"についてはPostgreSQLスキーマ名が使われます (デフォルトは<code class="varname">public</code>です)。</p></dd><dt><span class="term">f_geometry_column</span></dt><dd><p>フィーチャーテーブル内のジオメトリカラムの名前。</p></dd><dt><span class="term">coord_dimension</span></dt><dd><p>カラムの座標次元 (2, 3, 4)</p></dd><dt><span class="term">srid</span></dt><dd><p>このテーブルのジオメトリの座標系として使用される座標系空間参照系のIDです。<code class="varname">spatial_ref_sys</code>テーブルを参照する外部キーです (<a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys_table" title="4.5.1. SPATIAL_REF_SYSテーブル">Section 4.5.1, “SPATIAL_REF_SYSテーブル”</a>を参照して下さい)。</p></dd><dt><span class="term">type</span></dt><dd><p>空間オブジェクトの型。空間カラムを単一型に制限するには、POINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTIONのうちのいずれかを、また、XYMで使う場合には、LINESTRINGM、POLYGONM、MULTIPOINTM、MULTILINESTRINGM、MULTIPOLYGONM、GEOMETRYCOLLECTIONMのうちのいずれかを使います。複数の型が混合するコレクションの場合は"GEOMETRY"を型とすることができます。</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Manual_Register_Spatial_Column"></a>4.6.3. 手動でジオメトリカラムをgeometry_columnsに登録する</h3></div></div></div><p>これが必要になる事例に、SQLビューとバルクインサートの二つがあります。バルクインサートの場合には、カラムに制約を与えるか、ALTER TABLEを実行することで、geometry_columnsテーブル内の登録を訂正することができます。ビューの場合には、CAST演算を使用します。カラムが型修飾子に基づく場合には、生成処理によって正しく登録されるので、何も行う必要がありません。ジオメトリに適用する空間関数を持たないビューも、基礎となるテーブルのジオメトリカラムと同じように登録されます。</p><pre class="programlisting">-- 次のようなビューがあるとします
CREATE VIEW public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395) As geom, f_name
        FROM public.mytable;

-- 正しく登録するには、
-- ジオメトリをキャストします。
--
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As geom, f_name
        FROM public.mytable;

-- ジオメトリタイプが確実に2次元ポリゴンだと知っているなら
-- 次のようにできます。
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name
        FROM public.mytable;</pre><pre class="programlisting">-- 次のように、バルクインサートで派生テーブルを生成したとしましょう
SELECT poi.gid, poi.geom, citybounds.city_name
INTO myschema.my_special_pois
FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);

-- 新しいテーブルに2次元インデックスを作ります
CREATE INDEX idx_myschema_myspecialpois_geom_gist
  ON myschema.my_special_pois USING gist(geom);

-- ポイントが3次元ポイントであったり、XYMポイントであったりした場合には、
-- 次のように、2次元インデックスでなくN次元インデックスを作ることになるかも
-- 知れません。
CREATE INDEX my_special_pois_geom_gist_nd
        ON my_special_pois USING gist(geom gist_geometry_ops_nd);

-- 新しいテーブルのジオメトリカラムをgeometry_columnsに手動登録するには、
-- 次のようにします。
-- カラムを型修飾子ベースにするために、基礎となるテーブル構造も変更することに
-- 注意して下さい。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);

-- PostGIS 2.0を使っていて、何らかの理由で古い制約をもとにした定義を行う
-- (派生テーブルが同じタイプやSRIDを持たないといった場合)ことが必要な場合には、
-- 新しい任意変数use_typemodをfalseにします。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false); </pre><p>古い制約を基にした手法は現在も対応していますが、制約を基にしたジオメトリカラムで直接的にビューで使われている場合は、型修飾子のようには正しくgeometry_columnsに登録されません。次の例では、型修飾子を使ったカラム定義と、制約に基づくカラムの定義とを行っています。</p><pre class="programlisting">CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom geometry(POINT,4326));
SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);</pre><p>psqlで次を実行します。</p><pre class="programlisting">\d pois_ny;</pre><p>型修飾子と制約に基づくのとでは異なった定義になっているのが見えます。</p><pre class="screen">Table "public.pois_ny"
  Column   |         Type          |                       Modifiers

-----------+-----------------------+------------------------------------------------------
 gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)
 poi_name  | text                  |
 cat       | character varying(20) |
 geom      | geometry(Point,4326)  |
 geom_2160 | geometry              |
Indexes:
    "pois_ny_pkey" PRIMARY KEY, btree (gid)
Check constraints:
    "enforce_dims_geom_2160" CHECK (st_ndims(geom_2160) = 2)
    "enforce_geotype_geom_2160" CHECK (geometrytype(geom_2160) = 'POINT'::text
        OR geom_2160 IS NULL)
    "enforce_srid_geom_2160" CHECK (st_srid(geom_2160) = 2160)</pre><p>geometry_columnsでは、両方とも正しく登録されています。</p><pre class="programlisting">SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'pois_ny';</pre><pre class="screen">f_table_name | f_geometry_column | srid | type
-------------+-------------------+------+-------
pois_ny      | geom              | 4326 | POINT
pois_ny      | geom_2160         | 2160 | POINT</pre><p>しかし、次のようにビューを作ろうとします。</p><pre class="programlisting">CREATE VIEW vw_pois_ny_parks AS
SELECT *
  FROM pois_ny
  WHERE cat='park';

SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><p>型修飾子によるgeomのビューカラムは正しく登録されますが、制約に基づくものは正しく登録されません。</p><pre class="screen">f_table_name   | f_geometry_column | srid |   type
------------------+-------------------+------+----------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY</pre><p>これは、将来的にPostGISの版で変更されるかもしれませんが、今のところは、制約に基づくビューカラムを正しく登録させるには、次のようにします。</p><pre class="programlisting">DROP VIEW vw_pois_ny_parks;
CREATE VIEW vw_pois_ny_parks AS
SELECT gid, poi_name, cat,
  geom,
  geom_2160::geometry(POINT,2160) As geom_2160
  FROM pois_ny
  WHERE cat = 'park';
SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><pre class="screen">f_table_name   | f_geometry_column | srid | type
------------------+-------------------+------+-------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         | 2160 | POINT</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="loading-data"></a>4.7. 空間データのロード</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#load-data-sql">4.7.1. SQLを使ってロードする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#shp2pgsql_usage">4.7.2. シェープファイルローダを使う</a></span></dt></dl></div><p>空間テーブルを作成したら、これでGISデータをデータベースにアップロードする準備ができたことになります。現在、PostGIS/PostgreSQLデータベースにデータをロードするには、SQLステートメントを使う、またはシェープファイルのローダ/ダンパを使う、という二つの方法があります。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="load-data-sql"></a>4.7.1. SQLを使ってロードする</h3></div></div></div><p>空間データを文字表現 (WKTかWKB)に変換できたら、SQLを使うのがPostGISにデータを持たせる最も簡単です。SQLユーティリティの<code class="code">psql</code>を使用して、SQLの<code class="code">INSERT</code>ステートメントのテキストファイルをロードすると、データをPostGIS/PostgreSQLに一括読み込みできます。</p><p>データアップロードファイル (たとえば<code class="filename">roads.sql</code>)は次のようになるでしょう。</p><pre class="programlisting">BEGIN;
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');
COMMIT;</pre><p>SQLファイルのPostgreSQLへのロードは<code class="code">psql</code>を使います。次のようにします。</p><pre class="programlisting">psql -d [データベース名] -f roads.sql</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="shp2pgsql_usage"></a>4.7.2. シェープファイルローダを使う</h3></div></div></div><p><code class="filename">shp2pgsql</code>データローダは、ESRIシェープファイルをPostGIS/PostgreSQLデータベースに、ジオメトリまたはジオグラフィとして挿入するための適切なSQLに変換します。ローダには、次に示すコマンドラインフラグによって区別される、いくつかの操作モードがあります。 </p><p>グラフィカルユーザインタフェースを持つ<code class="filename">shp2pgsql-gui</code>もあります。コマンドラインローダのオプションのほとんどが使えます。これは、スクリプト化されていない1回限りのロードの場合や、PostGIS初心者がロードする場合に、簡単に使用できます。PgAdminIIIのプラグインとすることもできます。 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">(c|a|d|p) 相互に排他的なオプションです</span></dt><dd><p>
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-c</span></dt><dd><p>新しいテーブルの作成とシェープファイルからのデータの読み込みを行います。<span class="emphasis"><em>これがデフォルトモードです</em></span>。 </p></dd><dt><span class="term">-a</span></dt><dd><p>シェープファイルからデータベーステーブルにデータを追加します。複数のファイルをロードするためにこのオプションを使う場合は、これらのファイルは同じ属性と同じデータ型を持つ必要があります。 </p></dd><dt><span class="term">-d</span></dt><dd><p>シェープファイルにあるデータを持つ新しいテーブルを作成する前にデータベーステーブルを削除します。 </p></dd><dt><span class="term">-p</span></dt><dd><p>テーブル作成のSQLコードを生成するだけで、実際のデータは追加しません。このモードは、テーブル作成とデータロードとを完全に分けたい場合に使用します。 </p></dd></dl></div><p>
        </p></dd><dt><span class="term">-?</span></dt><dd><p>ヘルプ画面を表示します。 </p></dd><dt><span class="term">-D</span></dt><dd><p>出力データにPostgreSQLのダンプ書式を用います。このモードは-a, -c, -dと組み合わせて利用します。デフォルトの"insert"によるSQL書式よりも、大変早くロードできます。大きなデータセットではこちらを使用して下さい。 </p></dd><dt><span class="term">-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;</span></dt><dd><p>指定したSRIDを持つジオメトリテーブルの生成や追加を行います。FROM_SRIDが与えられた場合には、入力シェープファイルに、これを使います 。この場合には、ジオメトリは変更先SRIDに投影変換します。 </p></dd><dt><span class="term">-k</span></dt><dd><p>識別子 (カラム、スキーマおよび属性)の大文字小文字を保持します。シェープファイルの属性は全て大文字であることに注意して下さい。 </p></dd><dt><span class="term">-i</span></dt><dd><p>全ての整数を標準の32ビット整数に強制します。DBFヘッダではそれが正当であったとしても、64ビットのbigintを生成しません。 </p></dd><dt><span class="term">-I</span></dt><dd><p>ジオメトリカラムにGiSTインデックスを生成します。 </p></dd><dt><span class="term">-m</span></dt><dd><p>-m <code class="filename">a_file_name</code>で、長いカラム名を10文字のDBFカラム名に対応付けるファイルを指定します。ファイルは、1以上の行を持ちます。各行は空白区切りで二つの名前を持ち、行頭行末に空白を入れません。例を次に示します。 </p><pre class="programlisting">COLUMNNAME DBFFIELD1
AVERYLONGCOLUMNNAME DBFFIELD2</pre><p>
        </p></dd><dt><span class="term">-S </span></dt><dd><p>マルチ系ジオメトリの替りに単一ジオメトリを生成します。全てのジオメトリが実際に単一である (たとえば単一の外環でなるMULTIPOLYGONや単一の頂点でなるMULTIPOINT)場合にのみ成功します。 </p></dd><dt><span class="term">-t &lt;次元&gt;</span></dt><dd><p>出力ジオメトリが特定の次元を持つよう強制します。次元は、2D, 3DZ, 3DM, 4Dの文字列を使います。 </p><p>入力の次元が出力より小さい場合には、出力では0が入ります。入力の次元が大きい場合には、外されます。 </p></dd><dt><span class="term">-w</span></dt><dd><p>出力書式をWKBでなくWKTにします。精度が低下して、座標変動が発生しうることに注意が必要です。 </p></dd><dt><span class="term">-e</span></dt><dd><p>トランザクションを使わずに、ステートメントごとに実行するようにします。エラーの元となる不良なジオメトリがいくつか含んでいる時に、大半の良好なデータのロードが可能にするものです。ダンプ書式ではトランザクションを常に使うので、-Dフラグを指定している場合には使えません。 </p></dd><dt><span class="term">-W &lt;エンコーディング&gt;</span></dt><dd><p>入力データ (dbfファイル)のエンコーディングを指定します。全てのdbfの属性は指定されたエンコーディングからUTF8に変換されます。SQL出力結果には <code class="code">SET CLIENT_ENCODING to UTF8</code>が含まれるようになり、バックエンドはUTF-8からデータベースが内部利用のために設定したエンコーディングに再変換できます。 </p></dd><dt><span class="term">-N &lt;方針&gt;</span></dt><dd><p>NULLジオメトリ操作方針(insert*=挿入, skip=スキップ, abort=強制終了)を選択します。 </p></dd><dt><span class="term">-n</span></dt><dd><p>DBFファイルのみインポートします。対応するシェープファイルを持っていない場合、 自動的にこのモードになり、DBFファイルのみロードします。 このフラグは、完全なシェープファイル群を持っていて、属性データだけが欲しくてジオメトリが欲しくない時のみ使用します。 </p></dd><dt><span class="term">-G</span></dt><dd><p>ジオメトリ型のかわりに、ジオグラフィ型で、WGS84経度緯度 (SRID=4326)を使用します (経度緯度データが必要です)。 </p></dd><dt><span class="term">-T &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのテーブル空間を指定します。 -Xパラメータが使われない場合には、インデックスはデフォルトのテーブル空間を使用します。PostgreSQL文書には、テーブル空間を用いるべき時に関する良い文書があります。 </p></dd><dt><span class="term">-X &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのインデックスで使われるテーブル空間を指定します。 主キーインデックスに適用され、-Iが合わせて使われている場合にはGiST空間インデックスにも適用されます。 </p></dd><dt><span class="term">-Z</span></dt><dd><p>このフラグをこれを使う時、<code class="code">ANALYZE</code>手続きの生成を防ぎます。-Zフラグが無い (デフォルトの振る舞い)場合には、<code class="code">ANALYZE</code>手続きが生成されます。 </p></dd></dl></div><p>ローダを使って入力ファイルを生成してアップロードするセッション例は次の通りです。 </p><pre class="programlisting"># shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql
# psql -d roadsdb -f roads.sql</pre><p>変換とアップロードはUNIXのパイプを使うと一回で実行できます。 </p><pre class="programlisting"># shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extracting-data"></a>4.8. 空間データの抽出</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#extract-data-sql">4.8.1. SQLを使ってデータを抽出する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#pgsql2shp-usage">4.8.2. ダンパを使う</a></span></dt></dl></div><p>空間データはSQLかシェープファイルダンパを使うと抽出できます。SQLの節では空間テーブルで比較とクエリに使用できる関数を示します。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="extract-data-sql"></a>4.8.1. SQLを使ってデータを抽出する</h3></div></div></div><p>データベース外へのデータ抽出の最も簡単な方法は、抽出するデータセットを定義し、<code class="code">SELECT</code>問い合わせを使って、結果カラムを解析可能なテキストファイルにダンプすることです。</p><pre class="programlisting">db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;

road_id | geom                                    | road_name
--------+-----------------------------------------+-----------
          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd
          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd
          3 | LINESTRING(192783 228138,192612 229814) | Paul St
          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
          7 | LINESTRING(218421 284121,224123 241231) | Chris Way
(6 rows)</pre><p>返されるレコードの数を減らすためにある種の制限が必要になる場合があります。属性ベースで制限をかける場合には、非空間テーブルで使うのと同じSQL文を使います。空間に制限をかけるには次の関数を使います。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ST_Intersects</span></dt><dd><p>この関数は、二つのジオメトリが空間を共有しているかどうかをテストします。</p></dd><dt><span class="term">=</span></dt><dd><p>この関数で、二つのジオメトリが幾何的に同一であるかを見ることができます。たとえば、'POLYGON((0 0,1 1,1 0,0 0))' は 'POLYGON((0 0,1 1,1 0,0 0))' と同じかを見ることができます (これは同じとなります)。 </p></dd></dl></div><p>次に、これらの演算子をクエリで使うことができます。SQLコマンドラインからジオメトリとボックスの指定を行うときは、明示的に文字列表現をジオメトリに変換しなければならないことに注意して下さい。たとえば、次のようになります。ただし312は架空の空間参照系番号で、ここでのデータに合致しています。</p><pre class="programlisting">SELECT road_id, road_name
  FROM roads
  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::geometry;</pre><p>上のクエリは"ROADS_GEOM"テーブルから、その値と等価である単一のレコードを返します。</p><p>道路がポリゴンで定義した面を通過するかどうかをチェックするには次のようにします。</p><pre class="programlisting">SELECT road_id, road_name
FROM roads
WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');</pre><p>最も一般的な空間クエリは「フレームベース」のクエリでしょう。これは、表示するためのデータの価値のある「マップフレーム」を取得するために、データブラウザやウェブマッパのようなクライアントソフトウェアに使われます。 </p><p>"&amp;&amp;"演算子を使うとき、比較フィーチャーをBOX3DかGEOMETRYかに指定することができます。ただし、GEOMETRYを指定すると、それのバウンディングボックスが比較に使われます。</p><p>次に示すクエリのように、フレームにBOX3Dオブジェクトを使います。</p><pre class="programlisting">SELECT ST_AsText(roads_geom) AS geom
FROM roads
WHERE
  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);</pre><p>エンベロープの投影を指定するためにSRID 312を使っていることに注意して下さい。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="pgsql2shp-usage"></a>4.8.2. ダンパを使う</h3></div></div></div><p><code class="filename">pgsql2shp</code>テーブルダンパは、データベースに直接接続して、テーブル (あるいはクエリによって定義されたもの)をシェープファイルに変換するものです。基本的な文は次の通りです。</p><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;database&gt; [&lt;スキーマ&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; &lt;クエリ&gt;</pre><p>コマンドラインオプションは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-f &lt;ファイル名&gt;</span></dt><dd><p>特定のファイル名に出力を書きこみます。</p></dd><dt><span class="term">-h &lt;ホスト&gt;</span></dt><dd><p>接続先データベースのホスト名。</p></dd><dt><span class="term">-p &lt;ポート&gt;</span></dt><dd><p>接続先データベースのポート。</p></dd><dt><span class="term">-P &lt;パスワード&gt;</span></dt><dd><p>データベースに接続するためのパスワード。</p></dd><dt><span class="term">-u &lt;ユーザ名&gt;</span></dt><dd><p>データベースに接続する際のユーザ名。</p></dd><dt><span class="term">-g &lt;ジオメトリカラム&gt;</span></dt><dd><p>複数のジオメトリカラムを持つテーブルの場合の、シェープファイルの出力に使用するジオメトリカラム。</p></dd><dt><span class="term">-b</span></dt><dd><p>バイナリカーソルを使います。これは、実行時間を短くしますが、テーブルの非ジオメトリ属性がテキストへのキャストを持っていない場合には、動作しません。</p></dd><dt><span class="term">-r</span></dt><dd><p>Rawモード。<code class="varname">gid</code>フィールドを落としたり、カラム名をエスケープしてはいけません。</p></dd><dt><span class="term">-m <code class="varname">ファイル名</code></span></dt><dd><p>識別名を10文字名に再割り当てします。 ファイルの中身は、一つの空白で区切られ、前と後に空白が無い二つのシンボルの行からなります。VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER等となります。</p></dd></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="build-indexes"></a>4.9. 空間インデックス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#gist_indexes">4.9.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#brin_indexes">4.9.2. BRINインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spgist_indexes">4.9.3. SP-GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#tuning-index-usage">4.9.4. インデックス使用のチューニング</a></span></dt></dl></div><p>インデックスによって巨大データセットの空間データベースの使用が可能となります。インデックス無しでは、地物の検索を行う際に、データベースの全てのレコードに対するシーケンシャルスキャンが必要となります。インデックスによって、レコード探索のために早く移動できる構造を構築するので、検索速度が向上します。 </p><p>一般的に属性データに使われるインデックス手法でありB木は、空間データではあまり有用ではありません。1次元データの格納とクエリにだけしか対応していないためです。ジオメトリのような2次元以上の次元を持つデータでは、全ての次元の範囲を指定できるインデックス手法が求められます。PostgreSQLの空間データ処理に関する主要な利点の一つに、多次元データで上手く動作するGiST、BRIN、SP-GiSTの複数のインデックス手法を提供していることです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>GiST (Generalized Search Tree)</strong></span>インデックスは、データを「一方にあるもの」「オーバラップするもの」「内部にあるもの」に分解するもので、GISデータを含む幅広い範囲で使えます。PostGISはGiSTインデックス空間データをR木インデックス実装のベースにています。GiSTは最も一般的に使われ、多目的なインデックス手法で、非常に良好な問い合わせ効率を提供しています。 </p></li><li class="listitem"><p><span class="bold"><strong>BRIN (Block Range Index)</strong></span>インデックスは、空間範囲を集計することで動作します。探索は範囲のスキャンを通して行われます。BRINは一部の種類 (空間的にソートされ、更新がほぼ無いか全く無い)のデータだけに適切です。しかし、インデックス生成時間は非所に早く、インデックスサイズは非常に小さくなります。 </p></li><li class="listitem"><p><span class="bold"><strong>SP-GiST (Space-Partitioned Generalized Search Tree)</strong></span>は4分木、kd木、基数木 (トライ木)のような部分木探索に対応する一般的なインデックス手法です。 </p></li></ul></div><p>空間インデックスはジオメトリのバウンディングボックスだけを格納します。空間クエリはインデックスは<span class="bold"><strong>初期フィルタ</strong></span>として使用して、クエリ条件に一致する可能性のあるジオメトリを早く求めます。ほとんどの空間クエリでは、空間述語関数を使って特定の空間条件をテストする<span class="bold"><strong>二次フィルタ</strong></span>が必要です。空間述語関数を使ったクエリの詳細情報については<a class="xref" href="using_postgis_query.html#using-query-indexes" title="5.2. 空間インデックスを使う">Section 5.2, “空間インデックスを使う”</a>をご覧下さい。 </p><p>また、<a class="ulink" href="https://postgis.net/workshops/postgis-intro/indexing.html" target="_top">PostGIS Workshop section on spatial indexes</a>と<a class="ulink" href="https://www.postgresql.org/docs/current/indexes.html" target="_top">PostgreSQL manual</a>もご覧下さい。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="gist_indexes"></a>4.9.1. GiSTインデックス</h3></div></div></div><p>GiSTは「汎用検索木 (Generalized Search Tree)」の意味で、多次元データのインデックスの一般化された形式です。PostGISはGiST上で実装しているR木インデックスをを空間データのインデックスに使用しています。GiSTは最も一般的に使われ、多目的なインデックス手法で、クエリ能率を非常に良くします。他のGiSTの実装は、通常のB木インデックスに従わない全ての種類の不規則なデータ構造 (整数配列, スペクトラルデータ等)の検索速度を向上させるために使います。詳細情報については<a class="ulink" href="https://www.postgresql.org/docs/current/gist.html" target="_top">PostgreSQL manual</a>をご覧ください。 </p><p>GISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデックスを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常のインデックスを属性フィールドに追加します)。</p><p>GiSTインデックスをジオメトリカラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>上の文では常に2次元インデックスを構築します。n次元インデックスをジオメトリ型で使うには、次の文でインデックスを生成できます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] gist_geometry_ops_nd);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムではより遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="brin_indexes"></a>4.9.2. BRINインデックス</h3></div></div></div><p>BRINは"Block Range Index"の略です。PostgreSQL 9.5で導入された汎用インデックス手法です。BRINは<span class="emphasis"><em>不可逆</em></span>インデックス手法であり、レコードが与えた検索条件に合致することを確認する二番目のチェックが必要であることを意味しています (全ての空間インデックスで言えます)。非常に速いインデックス作成、非常に小さいインデックスサイズで、合理的な読み込み効率を持ちます。主目的は、非常に大きいテーブルのテーブル内の物理位置と関係があるカラムにインデックスを作ることに対応するためです。空間インデックスに加えて、BRINは様々な種類の属性データ構造 (整数、配列等)で速度向上させることができます。詳細情報については<a class="ulink" href="https://www.postgresql.org/docs/current/brin.html" target="_top">PostgreSQL manual</a>をご覧ください。 </p><p>空間テーブルが、ひとたび数千行を超えると、データの空間検索の速度向上にインデックスが必要と感じることになります。GiSTインデックスは、サイズがデータベースで使えるRAM容量を超えず、インデックスのストレージサイズに余裕があり、書き込み時のインデックス更新コストにも余裕があるなら、非常に高いパフォーマンスを発揮します。そうでない場合には、非常に大きなテーブルにおいては、BRINインデックスを代替に考えることができます。</p><p>BRINインデックスは、連続するテーブルブロックの集合 (<span class="emphasis"><em>ブロック範囲</em></span>と言います)の全てのジオメトリを囲むバウンディングボックスを格納します。インデックスを使用した問い合わせを実行する時に、問い合わせ範囲とインタセクトするブロック範囲を見つけるためにスキャンします。これは、データが物理的に整列していて、ブロック範囲のバウンディングボックスのオーバラップが最小である (理想的には相互に排他的である)場合に限って効率的です。結果インデックスは非常に小さいサイズですが、通常、読み込み効率は、同じデータにおけるGiSTインデックスより悪くなります。</p><p>BRINインデックスの構築は、はGiSTインデックスと比べて、CPU集中を非常に減らします。BRINインデックスはGiSTインデックスよりも、同じデータに対して10倍速く構築するのが普通です。BRINインデックスはテーブルブロックの範囲ごとに一つのバウンディングボックスしか格納しないので、GiSTインデックスと比べて、ディスクスペースを1000倍少なくできます。</p><p>レンジ内で要約するブロック数を選択できます。この数字を減らすと、インデックスは大きくなりますが、効率向上の助けになる可能性があります。</p><p>BRINを効果的にするには、テーブルデータをブロック範囲のオーバラップの量を最小にするような物理的オーダーで格納します。データが既に適切に並び替えられているかも知れません (たとえば、既に空間オーダーで並び替えられているデータセットを他のデータベースからロードする場合)。そうでない場合には、一つの空間キーによるデータの並べ替えで実現できます。一つの方法として、ジオメトリ値で並べ替えた新しいテーブルを生成することです (最近のPostGISのバージョンで効果的なヒルベルト曲線オーダーが使われています)。 </p><pre class="programlisting">CREATE TABLE table_sorted AS
   SELECT * FROM table  ORDER BY geom;
</pre><p>もしくは、データは、ジオハッシュを (一時的な)インデックスに使い、そのインデックスでクラスタリングを行うことによって適切に並べ替えることができます。 </p><pre class="programlisting">CREATE INDEX idx_temp_geohash ON table
    USING btree (ST_GeoHash( ST_Transform( geom, 4326 ), 20));
CLUSTER table USING idx_temp_geohash;
</pre><p>BRINインデックスを<code class="code">ジオメトリ</code>カラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ); </pre><p>上の文で2次元インデックスを構築します。3次元インデックスをビルドするには、この文を使います。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_3d);</pre><p>また、4次元演算子クラスを使う4次元インデックスを使うこともできます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_4d);</pre><p>上記のコマンドでは、範囲のブロック数はデフォルトの128を使用しています。集計で範囲のブロック数を指定するには、この文を使います。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] ) WITH (pages_per_range = [数字]); </pre><p>また、BRINインデックスは、多数の行で一つのインデックス値を格納することを心に留めておいて下さい。テーブルに違う次元のジオメトリを格納する場合には、インデックスの効率が悪くなります。この効率欠落を回避するには、格納したジオメトリの次元数の最小値となる演算子クラスを選択します。 </p><p>「ジオグラフィ」型もまたBRINインデックスに対応しています。BRINインデックスを「ジオグラフィ」カラムに構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ); </pre><p>上の文では常に回転楕円体面上の地理空間オブジェクトの2次元インデックスを構築します。 </p><p>現在のところは「包括対応」だけをここで考えています。これは、<code class="varname">&amp;&amp;</code>, <code class="varname">~</code>, <code class="varname">@</code>の演算子だけが2次元で使われることを意味します (<code class="code">ジオメトリ</code>と<code class="code">ジオグラフィ</code>の両方)。 <code class="varname">&amp;&amp;&amp;</code>演算子は3次元ジオメトリで使えます。しばらくはKNN検索に対応しません。</p><p>BRINと他のインデックスとの重要な違いは、データベースがインデックスを動的に保守しないことです。テーブルの空間データを変更すると、単純にインデックスの末尾に追加しています。このためインデックス探索の能率が時間とともに低下します。インデックスは<code class="code">VACUUM</code>か空間関数<code class="code">brin_summarize_new_values(regclass)</code>を実行することで更新できます。このため、BRINは読み込み専用か、書き込みがほとんど発生しないよなデータでの利用では最も適切になりえます。詳細情報については、<a class="ulink" href="https://www.postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION" target="_top">manual</a>をご覧下さい。 </p><p>空間データにBRINを使用して集計するには: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>インデックス構築時間は非常に速く、インデックスサイズは非常に小さいです。</p></li><li class="listitem"><p>インデックスのクエリ時間はGiSTより遅いですが、十分許容できます。</p></li><li class="listitem"><p>テーブルデータを空間順序で並べ替える必要があります。</p></li><li class="listitem"><p>手動でインデックスの保守をする必要があります。</p></li><li class="listitem"><p>巨大なテーブルであって、オーバラップが少ないか無く (ポイントなど)、かつ静的か頻繁には変更しないようなものに、最も適しています。</p></li><li class="listitem"><p>比較的多数のデータレコードを返すクエリでの使用が、より効果的です。</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spgist_indexes"></a>4.9.3. SP-GiSTインデックス</h3></div></div></div><p>SP-GiSTは、「空間分割された一般探索木」を表します。四分木、k次元木、基数木 (トライ木)のような分割探索木に対応するインデックスの総称的な形式です。このデータ構造の一般的な機能は、検索空間を反復して分割することですが、分割は等しいサイズである必要はありません。SP-GiSTは、GISインデックスだけでなく、電話回線のルーティングや、IPルーティング、部分文字列検索等といった、様々な種類のデータを探索する速度の向上に使われます。詳細情報については<a class="ulink" href="https://www.postgresql.org/docs/current/spgist.html" target="_top">PostgreSQL manual</a>をご覧下さい。 </p><p>GiSTインデックスを利用しているので、空間オブジェクトを覆うバウンディングボックスを保存するという意味で、SP-GiSTインデックスは不可逆です。SP-GiSTインデックスは、GiSTインデックスの代替と考えることができます。</p><p>一度GISデータテーブルが数千行を超えると、データの空間探索の速度向上にSP-GiSTインデックスを使うと良いかも知れません。「ジオメトリ」カラムにSP-GiSTインデックスを構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>上の文では、2次元インデックスを構築します。ジオメトリ型の3次元インデックスは、次のように、3次元演算子クラスを使用して生成します。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ([ジオメトリカラム] spgist_geometry_ops_3d);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムでは、より遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre><p>SP-GiSTインデックスは次の演算子を含むクエリの実行速度を向上させられます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>2次元インデックスについては &lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, |&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~= 。</p></li><li class="listitem"><p>3次元インデックスについては &amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@ 。</p></li></ul></div><p>現時点ではkNN探索に対応していません。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tuning-index-usage"></a>4.9.4. インデックス使用のチューニング</h3></div></div></div><p>通常、インデックスは知らないうちにデータアクセスの速度を向上します。ひとたびインデックスを構築すれば、PostgreSQLクエリプランナは自動的にクエリの能率を向上させるために使うべきかどうかを決定します。しかし、プランナが既存のインデックスを選択せず、遅いシーケンシャルスキャンを使い続ける場合があります。</p><p>空間インデックスが使われていないのが分かった場合には、少しの行えることがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>クエリプランの試験とクエリの確認で、必要なものを計算できます。誤ったJOINや忘れ去られたテーブルや間違ったテーブルでは、予期しないテーブルレコード検索が複数回行われることがありえます。クエリプランを得るにはクエリの先頭に<code class="code">EXPLAIN</code>を付けて実行します。</p></li><li class="listitem"><p>テーブル内の値の数量と分布に関する統計情報を収集するとともに、クエリプランナにインデックス使用にかかる意思決定のための、より良い情報を与えるようにします。<span class="command"><strong>VACUUM ANALYZE</strong></span>は両方を計算します。</p><p>データベースに対する定期的なvacuumは常に実行するべきです。多くのPostgreSQLデータベースエージェントは、閑散時のcronジョブとして定期的に<span class="command"><strong>VACUUM</strong></span>を実行します。</p></li><li class="listitem"><p>VACUUMが役に立たない場合には、<span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span>コマンドを使用して、一時的にプランナにインデックス情報の使用を強制することができます。この方法で、プランナがインデックス使用を多くしたクエリプランを生成できるかどうかを確認できます。このコマンドはデバッグにのみ使用してください。一般的に言えば、プランナはインデックスを使用するタイミングをよく知っています。クエリを実行したら<span class="command"><strong>SET ENABLE_SEQSCAN TO ON;</strong></span>を実行して、他のクエリでは通常操作にすることを忘れないでください。</p></li><li class="listitem"><p><span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span>でクエリ速度が向上する場合には、PostgreSQLのハードウェア関連のチューンが行われていないのかも知れません。プランナがシーケンシャル対インデックスのコストが誤っている場合には、<code class="code">postgresql.conf</code>内にある<code class="varname">RANDOM_PAGE_COST</code>の値を変更してみて下さい。<span class="command"><strong>SET RANDOM_PAGE_COST TO 1.1;</strong></span>とします。<code class="varname">RANDOM_PAGE_COST</code>のデフォルト値は4.0です。1.1 (SSDの場合)または2.0 (高速磁気ディスクの場合)を試してみて下さい。値を小さくするほど、プランナがインデックススキャンをしやすくなります。</p></li><li class="listitem"><p><span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span>がクエリの助けにならないなら、クエリはPostgreSQLプランナがまだ最適化できないSQL構成なのかも知れません。プランナが処理できるようにクエリを再記述できるかもしれません。例えば、インラインSELECTを持つ副問い合わせがあると、効果的なプランを作らないことがあり、LATERAL JOINを使うように書き換えることができます。</p></li></ul></div><p>詳細情報についてはPostgreSQLマニュアルの<a class="ulink" href="https://www.postgresql.jp/document/current/html/runtime-config-query.html" target="_top">問い合わせ計画</a>節をご覧下さい。 </p></div></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="postgis_administration.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="using_postgis_query.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. PostGIS管理 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. 空間クエリ</td></tr></table></div></body></html>
