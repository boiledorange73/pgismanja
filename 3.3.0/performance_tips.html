<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 6. 性能向上に関する技法</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.3.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.3.0 マニュアル"><link rel="prev" href="using_postgis_query.html" title="Chapter 5. 空間クエリ"><link rel="next" href="ch07.html" title="Chapter 7. アプリケーションのビルド"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 6. 性能向上に関する技法</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="using_postgis_query.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="performance_tips"></a>Chapter 6. 性能向上に関する技法</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="sect1"><a href="performance_tips.html#small_tables_large_objects">6.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance_tips.html#idp54413648">6.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp54421968">6.1.2. 応急処置</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance_tips.html#database_clustering">6.2. ジオメトリインデクスでCLUSTERを実行する</a></span></dt><dt><span class="sect1"><a href="performance_tips.html#avoiding_dimension_conversion">6.3. 次元変換の回避</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="small_tables_large_objects"></a>6.1. 大きなジオメトリを持つ小さなテーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="performance_tips.html#idp54413648">6.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp54421968">6.1.2. 応急処置</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54413648"></a>6.1.1. 問題の説明</h3></div></div></div><p>現版のPostgreSQL (9.6を含む)では、TOASTテーブルに従うクエリオプティマイザの弱さに苦しみます。 TOASTテーブルは、(長いテキスト、イメージ、多数の頂点を持つ複合ジオメトリといった)通常のデータページに適合しない、(データサイズという意味では)巨大な値を納めるための「拡張部屋」の一種です。詳細情報は <a class="ulink" href="http://www.postgresql.org/docs/current/static/storage-toast.html" target="_top">the PostgreSQL Documentation for TOAST</a>をご覧ください。</p><p>(高解像度で全てのヨーロッパの国の境界を含むテーブルのような)大きなジオメトリがあるうえ、行がそう多くないテーブルを持つようになると、この問題が出てきます。テーブル自体は小さいのですが、多くのTOASTスペースを使います。例として、テーブル自体は概ね80行で3データページしか使わなくてもTOASTテーブルで8225ページを使うとします。</p><p>ここで、ジオメトリ演算子の&amp;&amp;を使って、ほとんどマッチしないようなバウンダリボックスを検索するクエリを出してみます。クエリオプティマイザにはテーブルは3ページ80行しかないように見えます。オプティマイザは、小さなテーブルを順に走査する方がインデクスを使うよりも早いと見積もります。そして、GiSTインデクスは無視すると決めます。通常なら、この見積もりは正しいです。しかし、この場合は&amp;&amp;演算子が全てのジオメトリをディスクから呼び出してバウンディングボックスと比較しなければならなくなり、ゆえに、全てのTOASTページもまた呼び出す必要があります。</p><p>この問題に苦しむかどうかを見るには、PostgreSQLの"EXPLAIN ANALYZE"コマンドを使います。詳細情報と技術情報については、PostgreSQL性能メーリングリストのスレッド<a class="ulink" href="http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php" target="_top">http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</a>をご覧下さい。</p><p>また、PostGISの新しいスレッド<a class="ulink" href="https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html" target="_top">https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html</a>もご覧下さい。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54421968"></a>6.1.2. 応急処置</h3></div></div></div><p>PostgreSQLコミュニティでは、TOASTを意識したクエリ見積もりを作ることで、この問題を解決しようとしています。今のところは、二つの応急処置があります。</p><p>一つは、クエリプランナにインデクスの使用を強制することです。クエリを発行する前に"SET enable_seqscan TO off;"をサーバに送信します。これは基本的にクエリプランナに対して可能な限り順に走査することを避けるよう強制します。そのためGiSTインデクスを通常使うようになります。しかし、このフラグは接続するたびに設定しなければならず、他のケースにおいてはクエリプランナに誤った見積もりをさせることになるので、 "SET enable_seqscan TO on;"をクエリの後に送信すべきです。</p><p>もう一つは、順に走査することをクエリプランナが考える程度に早くすることです。これは、バウンダリボックスの「キャッシュ」を行う追加カラムを作成し、このカラムにマッチさせるようにすることで達成することができます。ここでの例では次のようになります。</p><pre class="programlisting">SELECT AddGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2');
UPDATE mytable SET bbox = ST_Envelope(ST_Force2D(geom));</pre><p>そして、次のように、&amp;&amp;演算子をgeom_columnに対して行っていたものをbboxに変更します。</p><pre class="programlisting">SELECT geom_column
FROM mytable
WHERE bbox &amp;&amp; ST_SetSRID('BOX3D(0 0,1 1)'::box3d,4326);</pre><p>もちろん、mytableの行を変更または追加したら、bboxを「同期」するようにしなければなりません。最もすっきりした方法はトリガです。もしくは、アプリケーションを変更してbboxカラムの現状を保持するか、テーブル更新後にいつもUPDATEクエリを実行するかでも対応できます。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database_clustering"></a>6.2. ジオメトリインデクスでCLUSTERを実行する</h2></div></div></div><p>読み込むことがほとんどで、かつほとんどのクエリでひとつのインデクスを使うようなテーブルのために、PostgreSQLはCLUSTERコマンドを提供しています。このコマンドは、全てのデータ行を、インデクス基準にあわせて物理的に再整理するので、二つの性能の利点を生みます。一つは、インデックスの範囲走査のために、データテーブルのシーク回数が劇的に減少することです。もう一つは、いくつかの小さなインデックス間隔に集中する場合には、データ行が分布するデータページがより少なくなることで、より効率的なキャッシュを持つことです (この点は、PostgreSQLマニュアルのCLUSTERコマンドのドキュメントを読むように仕向けられていると感じて下さい)。</p><p>しかし、GiSTインデクスは単純にNULL値を無視するため現在のところPostGISのGiSTインデクスのクラスタリングはできず、次のようなエラーメッセージを得ます。</p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table;
ERROR: cannot cluster when index access method does not handle null values
(エラー: インデクスアクセスメソッドがNULL値を扱わない場合クラスタ化できません)
HINT: You may be able to work around this by marking column "geom" NOT NULL.
(ヒント: 列"the_geom"をNOT NULLとすることで、これを回避できるかもしれません)</pre><p>ヒントメッセージにある通り、テーブルに"not null"制限を追加することで、この欠陥にとりあえず対応できます。例を示します。</p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN geom SET not null;
ALTER TABLE</pre><p>もちろん、ジオメトリカラムで実際にNULL値が必要な場合、この対応はできません。さらには、制限を追加するには上の方法を使わなければならず、"ALTER TABLE blubb ADD CHECK (geometry is not null);"のようなCHECK制限は使えません。</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="avoiding_dimension_conversion"></a>6.3. 次元変換の回避</h2></div></div></div><p>ときどき、テーブルで3次元、4次元のデータを持つのに、常にOpenGIS準拠のST_AsText()またはST_AsBinary()関数を使ってアクセスして 2次元ジオメトリを出力させるようなことが起きます。内部でST_Force_2d()関数を呼んでいるために発生しますが、これは、大きなジオメトリでは重大なオーバヘッドを誘引することになります。このオーバヘッドを回避するには、一度追加された次元を前もって落とし、かつこれを永続化するのが適当かも知れません。</p><pre class="programlisting">UPDATE mytable SET geom = ST_Force2D(geom);
VACUUM FULL ANALYZE mytable;</pre><p>AddGeometryColumn()を使ってジオメトリカラムを追加した場合、ジオメトリの次元に関する制限があることに注意してください。この制限を迂回するには、制限の削除が必要になります。geometry_columnsテーブル内のエントリを更新して、その後で制限を再作成することを忘れないで下さい。</p><p>大きなテーブルの場合、WHERE節、およびプライマリキー若しくは他の適切な基準によってテーブルの一部へのUPDATEを制限させて、UPDATEの実行の間に単に"VACUUM;"と実行することで、UPDATEをより小さい塊に分割するのが賢いやり方かもしれません。これにより、テンポラリディスクスペースが劇的に減少します。さらに、次元混合のジオメトリを持つ場合、"WHERE dimension(the_geom)&gt;2"によってUPDATEを制限することで、2次元で書かれているジオメトリの再書き込みをスキップさせることができます。</p></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using_postgis_query.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. 空間クエリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 7. アプリケーションのビルド</td></tr></table></div></body></html>
