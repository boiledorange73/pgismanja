<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第4章 PostGISを使う: データ管理とクエリ</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.0.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.0.0 マニュアル"><link rel="prev" href="PostGIS_FAQ.html" title="第3章 PostGIS よくある質問"><link rel="next" href="using_raster_dataman.html" title="第5章 ラスタデータの管理、クエリ、アプリケーション"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第4章 PostGISを使う: データ管理とクエリ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="PostGIS_FAQ.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="using_raster_dataman.html">次へ</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="using_postgis_dbmanagement"></a>第4章 PostGISを使う: データ管理とクエリ</h1></div></div></div><div class="toc"><div class="toc-title">目次</div><dl class="toc"><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#RefObject">4.1. GISオブジェクト</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OpenGISWKBWKT">4.1.1. OpenGIS WKBとWKT</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#EWKB_EWKT">4.1.2. PostGIS EWKB, EWKTと標準形式</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#SQL_MM_Part3">4.1.3. SQL-MM第3部</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#PostGIS_Geography">4.2. PostGISジオグラフィ型</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Geography_Basics">4.2.1. ジオグラフィ基礎</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_GeographyVSGeometry">4.2.2. ジオグラフィ型をジオメトリ型にして使用すべき時</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_Geography_AdvancedFAQ">4.2.3. ジオグラフィに関する高度なよくある質問</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#idp68296008">4.3. OpenGIS標準を使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spatial_ref_sys">4.3.1. SPATIAL_REF_SYSテーブルと空間参照系</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#geometry_columns">4.3.2. GEOMETRY_COLUMNSビュー</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Spatial_Table">4.3.3. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Manual_Register_Spatial_Column">4.3.4. 手動でジオメトリカラムをgeometry_columnsに登録する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OGC_Validity">4.3.5. ジオメトリのOpenGIS準拠を確実にする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#DE-9IM">4.3.6. ここで、Dimensionally Extended 9 Intersection Modelまたは略してDE-9IMを見てみましょう。</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#loading_geometry_data">4.4. GIS (ベクタ)データをロードする</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68579400">4.4.1. SQLを使ってロードする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#shp2pgsql_usage">4.4.2. shp2pgsql: ESRIシェープファイルローダを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#retrieving_vector-data">4.5. GISデータを検索する</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68658248">4.5.1. SQLを使ってデータを検索する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68668744">4.5.2. ダンパを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#idp68686664">4.6. インデックスを構築する</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#gist_indexes">4.6.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#brin_indexes">4.6.2. BRINインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spgist_indexes">4.6.3. SP-GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68713544">4.6.4. インデックスを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="using_postgis_dbmanagement.html#idp68723528">4.7. 複雑なクエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68731080">4.7.1. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#examples_spatial_sql">4.7.2. 空間SQLの例</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. GISオブジェクト</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OpenGISWKBWKT">4.1.1. OpenGIS WKBとWKT</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#EWKB_EWKT">4.1.2. PostGIS EWKB, EWKTと標準形式</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#SQL_MM_Part3">4.1.3. SQL-MM第3部</a></span></dt></dl></div><p>PostGISでサポートされるGISオブジェクトは、OpenGIS Consortium (OGC)が定義する"Simple Features" のスーパーセットです。 PostGISはOGCの"Simple Features for SQL"仕様で定められた全てのオブジェクトと関数に対応しています。</p><p>PostGISは標準から拡張して 3DZ, 3DM, 4次元 (訳注: それぞれXYZ, XYM, XYZM)座標に対応しています。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="OpenGISWKBWKT"></a>4.1.1. OpenGIS WKBとWKT</h3></div></div></div><p>OpenGIS仕様は空間オブジェクトの表現について二つの標準を定義しています。Well-Knownテキスト (WKT)形式とWell-Knownバイナリ (WKB)形式です。WKTもWKBも、オブジェクトの型とオブジェクトを形成する座標に関する情報を持っています。</p><p>フィーチャーの空間オブジェクトのテキスト表現 (WKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0)</p></li><li class="listitem"><p>LINESTRING(0 0,1 1,1 2)</p></li><li class="listitem"><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li class="listitem"><p>MULTIPOINT((0 0),(1 2))</p></li><li class="listitem"><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))</p></li></ul></div><p>OpenGIS仕様では、空間オブジェクトの内部保存書式は空間参照系識別子 (Spatial Referencing System IDentifier, SRID)を含むことも求められます。SRIDはデータベースへの挿入のために空間オブジェクトが生成される時に求められます。</p><p>これらの書式の入出力は次のインタフェースを用いて実現できます。</p><pre class="programlisting">バイト配列 WKB = ST_AsBinary(geometry);
テキスト WKT = ST_AsText(geometry);
ジオメトリ = ST_GeomFromWKB (bytea WKB、SRID);
ジオメトリ = ST_GeometryFromText (テキスト WKT、SRID);</pre><p>たとえば、OGC空間オブジェクトを生成して挿入する妥当なINSERTステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="EWKB_EWKT"></a>4.1.2. PostGIS EWKB, EWKTと標準形式</h3></div></div></div><p>OGC書式は2次元ジオメトリしかサポートされておらず、また、入出力の表現においてSRIDは*決して*埋め込まれません。</p><p>PostGIS拡張書式は現在のところOGC書式のスーパーセットとなっています (全ての妥当なWKB/WKTは妥当なEWKB/EWKTです)。しかし、特にもしOGCがPostGIS拡張と矛盾する新しい書式を出すことがあるなら、これは将来変更されるかも知れません。ゆえにこの機能に頼るべきではありません。</p><p>PostGIS EWKB/EWKT では 3DM, 3DZ, 4D の座標サポートが追加され、SRID情報が埋め込まれます。</p><p>拡張された空間オブジェクトのテキスト表現 (EWKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0 0) -- XYZ</p></li><li class="listitem"><p>SRID=32632;POINT(0 0) -- SRID付きXY</p></li><li class="listitem"><p>POINTM(0 0 0) -- XYM</p></li><li class="listitem"><p>POINT(0 0 0 0) -- XYZM</p></li><li class="listitem"><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID付きXYM</p></li><li class="listitem"><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))</p></li><li class="listitem"><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )</p></li><li class="listitem"><p>MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )</p></li><li class="listitem"><p>POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</p></li><li class="listitem"><p>TRIANGLE ((0 0, 0 9, 9 0, 0 0))</p></li><li class="listitem"><p>TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</p></li></ul></div><p>これらの書式の変換は次のインタフェースを用いて実現できます。</p><pre class="programlisting">バイト配列 EWKB = ST_AsEWKB(geometry);
テキスト EWKT = ST_AsEWKT(geometry);
ジオメトリ = ST_GeomFromEWKB(bytea EWKB);
ジオメトリ = ST_GeomFromEWKT(text EWKT);</pre><p>たとえば、PostGISの空間オブジェクトを作成し挿入する妥当なINSERTステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre><p>PostgreSQLの「標準的な形式」は単純なクエリ (全く関数呼び出しが無い)で得る表現であり、単純なINSERT, UPDATE, COPYで受け付けられることが保障されるものです。PostGISの"geometory"型の場合は次の通りです。 </p><pre class="programlisting">- 出力
  - バイナリ: EWKB
        ascii: HEXEWKB (EWKBのHEX表現)
- 入力
  - バイナリ: EWKB
        ascii: HEXEWKB|EWKT </pre><p>たとえば、次のステートメントは、標準的なASCII文字列による入出力の処理でEWKTを読み、HEXEWKBを返すものです。</p><pre class="programlisting">=# SELECT 'SRID=4;POINT(0 0)'::geometry;

geometry
----------------------------------------------------
01010000200400000000000000000000000000000000000000
(1 row)</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="SQL_MM_Part3"></a>4.1.3. SQL-MM第3部</h3></div></div></div><p>SQLマルチメディア・アプリケーション空間仕様は、円弧補完曲線を定義したSQL仕様の拡張です。</p><p>SQL-MMの定義では、3DM、3DZと4Dの座標を含みますが、SRID情報の埋め込みはできません。</p><p>Well-Known Text拡張はまだ完全にはサポートされていません。単純な曲線ジオメトリの例を次に示します。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>CIRCULARSTRING(0 0, 1 1, 1 0)</p><p>CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)</p><p>CIRCULARSTRINGは基本的な曲線型で、線型のLINESTRINGに似ています。一つの辺で、始点、終点 (一つめと三つめ)と弧上の任意の点、の3点が必要です。例外として、始点と終点が同じとなる閉曲線があります。閉曲線では二つ目の点が弧の中心、すなわち円の反対側にならなければなりません。弧の連結では、LINESTRINGと同じように、前の弧の最後の点が次の弧の最初の点となります。よって、妥当なCIRCULARSTRINGは1以上の奇数になります。</p></li><li class="listitem"><p>COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</p><p>複合曲線は、曲線 (円弧)セグメントと線型セグメントの両方を持つ、単一の連続した曲線です。 よって、要素が的確である必要があることに加え、各要素 (最終要素は除く)の終点は次の要素の始点と同じになる必要があります。</p></li><li class="listitem"><p>CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))</p><p>曲線ポリゴンの中に複合ポリゴンがある例は次の通りです。 CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) ) </p><p>CURVEPOLYGONは外環と0以上の内環とを持つ点でPOLYGONと似ています。 異なる点は、環に曲線ストリング、線型ストリング、複合ストリングのいずれも取れる点です。</p><p>PostGIS 1.4から、PostGISで曲線ポリゴンで複合曲線をサポートするようになりました。</p></li><li class="listitem"><p>MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))</p><p>MULTICURVEは曲線のコレクションで、線型ストリング、曲線ストリング、複合ストリングを取れます。</p></li><li class="listitem"><p>MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))</p><p>サーフェスのコレクションです。(線型)ポリゴンか曲線ポリゴンを取れます。</p></li></ul></div><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>SQL-MM実装での全ての浮動小数点数の比較では、所定の丸め誤差があります。現在は1E-8です。</p></td></tr></table></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PostGIS_Geography"></a>4.2. PostGISジオグラフィ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Geography_Basics">4.2.1. ジオグラフィ基礎</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_GeographyVSGeometry">4.2.2. ジオグラフィ型をジオメトリ型にして使用すべき時</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#PostGIS_Geography_AdvancedFAQ">4.2.3. ジオグラフィに関する高度なよくある質問</a></span></dt></dl></div><p>ジオグラフィ型は、「地理」座標 (しばしば「測地」座標、"lat/lon"、"lon/lat"、緯度経度, 経度緯度などとも呼ばれます)上で表現された空間フィーチャーのネイティブサポートするためのものです。地理座標は角度の単位 (度)で表現される球面座標です。 </p><p>PostGISジオメトリ型の基礎は平面です。平面上の二点間の最短コースは直線になります。よって、ジオメトリ上の計算 (面積、距離、長さ、インタセクション等)は、デカルト座標と線型ベクトルを使用することができます。</p><p>PostGISのジオグラフィ型の基礎は球面です。球面上での二点間の最短距離は大圏の弧です。よって、ジオグラフィ上の計算 (面積、距離、長さ、インタセクション等)は、球面上で計算しなければならず、複雑な計算が必要となります。より正確な計測のためには、世界の実際の回転楕円体の形を考慮に入れなければならず、非常に複雑です。</p><p>基礎となる数学が大変に複雑なので、ジオグラフィ型用に定義された関数は、ジオメトリ型よりも少ないです。時間とともに、新しいアルゴリズムが追加されて、ジオグラフィ型の能力は拡大していくでしょう。</p><p><code class="varname">geography</code>と呼ばれるデータ型を使用します。GEOS関数は<code class="varname">geography</code>型に対応していません。回避策として、ジオメトリとジオグラフィの型変換を行うことができます。</p><p>PostGIS 2.2より前は、ジオグラフィ型はWGS84経度緯度 (SRID:4326)だけに対応していました。PostGIS 2.2以降は、<code class="varname">spatial_ref_sys</code>で定義されている経度緯度ベースの空間参照系の全てが使えます。<a class="ulink" href="http://www.bostongis.com/blog/index.php?/archives/266-geography-type-is-not-limited-to-earth.html" target="_top">geography type is not limited to earth</a>の記述にある通り、独自の回転楕円体の空間参照系を追加することもできます。</p><p>どの空間参照系を使用しても、計測関数 (<a class="xref" href="ST_Distance.html" title="ST_Distance">ST_Distance</a>, <a class="xref" href="ST_Length.html" title="ST_Length">ST_Length</a>, <a class="xref" href="ST_Perimeter.html" title="ST_Perimeter">ST_Perimeter</a>, <a class="xref" href="ST_Area.html" title="ST_Area">ST_Area</a>)の返り値の単位と、<a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a>の入力の単位はメートルです。</p><p>ジオグラフィ型はPostgreSQLのtypmod定義書式を使います。ジオグラフィカラムを持つテーブルに1ステップで追加できます。標準OGC書式は曲線を除いてサポートします。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Geography_Basics"></a>4.2.1. ジオグラフィ基礎</h3></div></div></div><p>ジオグラフィ型はシンプルフィーチャーの最も簡単なもののみサポートします。標準的なジオメトリ型データで、SRIDが4326の場合は、ジオグラフィに自動でキャストされます。またデータ挿入においてEWKTとEWKBの取り決めを使うこともできます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT: SRID指定なしでの2次元ポイントジオグラフィのテーブル生成は次の通りです。デフォルトは4326 WGS84経度緯度となります。</p><pre class="programlisting">CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );</pre><p>POINT: NAD83経度緯度での2次元ポイントジオグラフィのテーブル生成は次の通りです。</p><pre class="programlisting">CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog geography(POINT,4269) );</pre><p>Z値を持ち、明示的にSRIDを指定したポイントのテーブル生成は次の通りです。</p><pre class="programlisting">CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog geography(POINTZ,4326) );</pre></li><li class="listitem"><p>LINESTRING</p><pre class="programlisting">CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );</pre></li><li class="listitem"><p>POLYGON</p><pre class="programlisting">-- ポリゴン NAD 1927経度緯度
CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog geography(POLYGON,4267) );</pre></li><li class="listitem"><p>MULTIPOINT</p></li><li class="listitem"><p>MULTILINESTRING</p></li><li class="listitem"><p>MULTIPOLYGON</p></li><li class="listitem"><p>GEOMETRYCOLLECTION</p></li></ul></div><p>ジオグラフィ型のフィールドは<code class="varname">geography_columns</code>システムビューに登録されます。</p><p>"geography_columns"ビューをチェックして、テーブルが一覧にあるか見て下さい。</p><p>CREATE TABLEの文法でジオグラフィカラムを持つテーブルを新規に生成できます。</p><p>
</p><pre class="programlisting">CREATE TABLE global_points (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    location GEOGRAPHY(POINT,4326)
  );</pre><p>
		</p><p>locationカラムはジオグラフィ型で、二つの任意修飾子に対応していることにご注意ください。一つは、そのカラムで使用できる形状と次元を限定する型修飾子です。もう一つは、座標参照IDを特定の数に限定するSRID修飾子です。</p><p>型修飾子として受け付ける値は、POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGONです。型修飾子は、Z, M, ZMの後置子を付けることで次元制限にも対応します。たとえば、'LINESTRINGM'という型修飾子で、三つ目の次元をMとする3次元のラインストリングのみ受け付けることになります。同じように'POINTZM'で、4次元データを期待します。</p><p>SRIDを指定していない場合には、SRIDは4326 WGS84経度緯度が使われ、全ての計算はWGS 84を使って行われます。</p><p>テーブルを作ったら、次のようにしてGEOGRAPHY_COLUMNSを見ることができます。</p><pre class="programlisting">-- メタデータビューの中身を見る
SELECT * FROM geography_columns;</pre><p>ジオメトリカラムを使うのと同じようにテーブルへのデータの挿入ができます。</p><pre class="programlisting">-- testテーブルにデータを追加する
INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;POINT(-110 30)');
INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;POINT(-109 29)');
INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;POINT(0 49)');</pre><p>ジオメトリと同じ操作でインデックスを作成します。PostGISは、カラム型がジオグラフィであるかを見て、ジオメトリで使われる平面用インデックスの代わりに球面ベースのインデックスを作成します。</p><pre class="programlisting">-- testテーブルに球面インデックスを作成
  CREATE INDEX global_points_gix ON global_points USING GIST ( location );</pre><p>
</p><p>クエリと計測関数はメートル単位となります。そのため距離パラメータはメートル (面積の場合は平方メートル)単位となります。</p><pre class="programlisting">-- 距離クエリの表示。ロンドンは1000km範囲外です
  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;POINT(-110 29)'::geography, 1000000);</pre><p>
</p><p>ジオグラフィの威力については、シアトルからロンドンまで (LINESTRING(-122.33 47.606, 0.0 51.5))の飛行機がレイキャビク (POINT(-21.96 64.15))に最も近くなるときの距離を求めてみると分かります。</p><pre class="programlisting">-- ジオグラフィを使った距離計算 (122.2km)
  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)'::geography);</pre><p>
</p><pre class="programlisting">-- ジオメトリを使った計算 (13.3 "度")
  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)'::geometry);</pre><p>
</p><p>異なる経度緯度座標系を試します。<code class="varname">spatial_ref_sys</code>テーブルで挙げられている経度緯度の空間参照系なら全て可能です。</p><p>	</p><pre class="programlisting">-- NAD83経度緯度
SELECT 'SRID=4269;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AD1000000000000000C05EC00000000000004140
(1 row)</pre><p>

</p><pre class="programlisting">-- NAD27経度緯度
SELECT 'SRID=4267;POINT(-123 34)'::geography;

                    geography
----------------------------------------------------
 0101000020AB1000000000000000C05EC00000000000004140
(1 row)</pre><p>

</p><pre class="programlisting">-- メートル単位のNAD83 UTM、メートル単位の投影法ですのでエラーが出ます
SELECT 'SRID=26910;POINT(-123 34)'::geography;

ERROR:  Only lon/lat coordinate systems are supported in geography.
LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;</pre><p>ジオグラフィ型は、レイキャビクとシアトル-ロンドン間の飛行機の大圏コースとの間の、球面上での本当に最も近い距離を計算します。</p><p><a class="ulink" href="http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR" target="_top">大圏コースマップ</a> ジオメトリ型は、平面の世界地図上にプロットされたレイキャビクとシアトル-ロンドン間の直線とのデカルト距離という意味のない値を出します。結果の名目上の単位は「度」ですが、点間の本当の角度差にあっていませんので、「度」と言うこと自体不正確です。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="PostGIS_GeographyVSGeometry"></a>4.2.2. ジオグラフィ型をジオメトリ型にして使用すべき時</h3></div></div></div><p>ジオグラフィ型によって、経度緯度座標でデータを格納できるようになりましたが、ジオグラフィで定義されている関数が、ジオメトリより少ないのと、実行にCPU時間がかかる、というところが犠牲になっています。</p><p>選択した型が、期待する領域から出ないことを、ジオメトリ型にして使用する条件とすべきです。使用するデータは地球全体か、大陸か、州か、自治体か? </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>データが小さいエリア内におさまるなら、適切な投影を選択してジオメトリを使うのが、効率面でも機能面でも最も良い方法です。</p></li><li class="listitem"><p>データが地球全体か大陸なら、ジオグラフィで投影法の細かい問題を気にせずにシステムを構築できるでしょう。経度/緯度のデータを保存して、ジオグラフィで定義された関数使います。</p></li><li class="listitem"><p>投影法を理解していなくて、学習したくもなくて、かつ、ジオグラフィで使える関数が限られていることを受け入れるのなら、ジオグラフィを使った方が簡単です。単純にデータを経度/緯度でロードして、そこから進めて下さい。</p></li></ul></div><p>ジオグラフィとジオメトリ間のサポート状況の比較については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_TypeFunctionMatrix" title="14.11. PostGIS関数対応マトリクス">「PostGIS関数対応マトリクス」</a>をご覧下さい。ジオグラフィ関数の簡潔なリストと説明については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_GeographyFunctions" title="14.4. PostGISジオグラフィ対応関数">「PostGISジオグラフィ対応関数」</a>をご覧下さい。 </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="PostGIS_Geography_AdvancedFAQ"></a>4.2.3. ジオグラフィに関する高度なよくある質問</h3></div></div></div><div class="qandaset"><a name="idp68278344"></a><dl><dt>4.2.3.1. <a href="using_postgis_dbmanagement.html#idp68278600">球または回転楕円体のどちらで計算するのでしょうか?</a></dt><dt>4.2.3.2. <a href="using_postgis_dbmanagement.html#idp68280904">日付変更線や極に関してはどうなっていますか?</a></dt><dt>4.2.3.3. <a href="using_postgis_dbmanagement.html#idp68286920">処理できる最も長い弧はどうなりますか?</a></dt><dt>4.2.3.4. <a href="using_postgis_dbmanagement.html#idp68288840">なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idp68278600"></a><a name="idp68278856"></a><p><b>4.2.3.1.</b></p></td><td align="left" valign="top"><p>球または回転楕円体のどちらで計算するのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>デフォルトでは、全ての距離と面積の計算は回転楕円体で行います。局所的なエリアでの計算結果と良好な投影を施した平面での結果と比較して下さい。大きなエリアの場合は、回転楕円体計算は、投影平面上でのどの計算よりも精度が高くなります。 </p><p>全てのジオグラフィ関数には、最後の真偽パラメータを'FALSE'にすると球面を使った計算を行うというオプションがあります。これは、特にジオメトリが非常に単純である場合に計算を速くするためのものです。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68280904"></a><a name="idp68281160"></a><p><b>4.2.3.2.</b></p></td><td align="left" valign="top"><p>日付変更線や極に関してはどうなっていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>全ての計算に日付変更線や極の概念がありません。座標は球 (経度/緯度)であるので、日付変更線とクロスする形状は、計算の観点からは、他のものと変わりありません。 </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68286920"></a><a name="idp68287176"></a><p><b>4.2.3.3.</b></p></td><td align="left" valign="top"><p>処理できる最も長い弧はどうなりますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>大圏の弧を2点の「補完線」として使用しています。任意の2点は、実際には2方向につながっていて、どちらの方向に行くかに依存します。PostGISの全てのコードは、大圏コースの2コースのうち*短い*方でつながっていると仮定しています。結果として、180度以上の弧を持つ形状は正しくモデル化されません。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68288840"></a><a name="idp68289096"></a><p><b>4.2.3.4.</b></p></td><td align="left" valign="top"><p>なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ポリゴンがとんでもなく大きいからです。二つの理由から、大きなエリアは悪いです。一つは、バウンダリボックスが大きいため、どのようなクエリを走らせても、インデックスがフィーチャーを引っ張ってくる傾向にあるためです。もう一つは、頂点数が巨大で、テスト (距離、包含)関数では、少なくとも1回、通常はN (Nは、もう一方のフィーチャーの頂点数)回、頂点を横断しなければならないためです。 </p><p>ジオメトリでは、大きなポリゴンを持っているけれども小さな範囲のクエリを実行する時、ジオメトリデータ情報を小片に「非正規化」します。これにより、インデックスが効果的にオブジェクトの一部を問い合わせるようになり、またクエリが常にオブジェクト全体を引っ張りこむようなことがないようになります。<a class="xref" href="ST_Subdivide.html" title="ST_Subdivide">ST_Subdivide</a>を参照して下さい。ヨーロッパ全体を一つのポリゴンに*格納できる*からといって、*そうすべき*だというわけではありません。</p></td></tr></tbody></table></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp68296008"></a>4.3. OpenGIS標準を使う</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spatial_ref_sys">4.3.1. SPATIAL_REF_SYSテーブルと空間参照系</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#geometry_columns">4.3.2. GEOMETRY_COLUMNSビュー</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Create_Spatial_Table">4.3.3. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#Manual_Register_Spatial_Column">4.3.4. 手動でジオメトリカラムをgeometry_columnsに登録する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#OGC_Validity">4.3.5. ジオメトリのOpenGIS準拠を確実にする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#DE-9IM">4.3.6. ここで、Dimensionally Extended 9 Intersection Modelまたは略してDE-9IMを見てみましょう。</a></span></dt></dl></div><p>OpenGISの「SQL用シンプルフィーチャー仕様」では、標準GISオブジェクト型とこれらを操作するために必要な関数、メタデータテーブルのセットが定義されています。メタデータが一貫性を維持していることを保証するために、空間カラムの生成、消去といった操作はOpenGISで定義されている空間プロシージャを通して実行されます。</p><p>OpenGISメタデータテーブルには<code class="varname">SPATIAL_REF_SYS</code>と<code class="varname">GEOMETRY_COLUMNS</code>の二つがあります。<code class="varname">SPATIAL_REF_SYS</code>テーブルは空間データベースで用いられる座標系の、数字によるIDと文字による説明を持っています。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spatial_ref_sys"></a>4.3.1. SPATIAL_REF_SYSテーブルと空間参照系</h3></div></div></div><p>spatial_ref_sysテーブルは、PostGISに含まれるもので、3000以上の<a class="ulink" href="http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx" target="_top">空間参照系</a>と、座標変換/投影変換を行うのに必要な詳細情報との一覧を持つ、OGC準拠のデータベーステーブルです。</p><p>PostGISのspatial_ref_sysテーブルには、projライブラリで使われる3000以上の一般に使われる空間参照系定義がありますが、全てを持っているわけではなく、proj4の構築に慣れているならカスタム投影を定義することができます。ほとんどの空間参照系は地域限定のもので、想定されている範囲の外で使うと意味が無いことに注意して下さい。</p><p>PostGISのコアセットに入っていない空間参照系を探すための素晴らしい資料が<a class="ulink" href="http://spatialreference.org/" target="_top">http://spatialreference.org/</a>にあります。</p><p>よく共通的に使われる空間参照系は次の通りです (訳注: 日本では状況が異なります)。<a class="ulink" href="http://spatialreference.org/ref/epsg/4326/" target="_top">4326 - WGS 84 経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/4269/" target="_top">4269 - NAD 83 経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/3395/" target="_top">3395 - WGS 84 メルカトル図法</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/2163/" target="_top">2163 - 米国ナショナルアトラス正積図法</a>、NAD83とWGS84のUTM空間参照系 - UTMゾーンは計測に最も理想的なものの一つですが6度 (訳注: 経度)の領域しかカバーしません。 </p><p>まざまな米国の州の平面空間参照系 (メートルまたはフィート単位) - 通常は州ごとに一つか二つあります。メートル単位のもののほとんどがPostGISのコアセットに入っていますが、多数のフィート単位のものやESRIが作ったものについては<a class="ulink" href="http://spatialreference.org" target="_top">spatialreference.org</a>から取得して下さい。 </p><p>対象領域がどのUTMゾーンになるかを決めるには、<a class="ulink" href="http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance" target="_top">utmzone PostGIS plpgsql helper function</a>を参照して下さい。 </p><p><code class="varname">SPATIAL_REF_SYS</code>テーブル定義は次の通りです。</p><pre class="programlisting">CREATE TABLE spatial_ref_sys (
  srid       INTEGER NOT NULL PRIMARY KEY,
  auth_name  VARCHAR(256),
  auth_srid  INTEGER,
  srtext     VARCHAR(2048),
  proj4text  VARCHAR(2048)
)</pre><p><code class="varname">SPATIAL_REF_SYS</code>のカラムは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="ulink" href="http://en.wikipedia.org/wiki/SRID" target="_top">SRID</a></span></dt><dd><p>一意に定められた整数値で、データベースで空間参照系 (SRS)を識別するものです。</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>その参照系の引用元である標準の名前です。たとえば「EPSG」は妥当な<code class="varname">AUTH_NAME</code>です。</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p><code class="varname">AUTH_NAME</code>で引用される団体によって定義された空間参照系のIDです。EPSGの場合、EPSG投影コードが入ります。</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>空間参照系のWell-Knownテキスト表現です。たとえば、WKT SRSの表現は、次のようになります。</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
        DATUM["North_American_Datum_1983",
          SPHEROID["GRS 1980",6378137,298.257222101]
        ],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433]
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0],
  UNIT["metre",1]
]</pre><p>EPSG投影コードと対応するWKT表現の一覧については、<a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a>をご覧下さい。WKTの一般的な議論については、OpenGISの<a class="ulink" href="http://www.opengeospatial.org/standards" target="_top">http://www.opengeospatial.org/standards</a>にある「座標変換サービス実装仕様」をご覧下さい。欧州石油調査グループ(European Petroleum Survey Group, EPSG)とEPSG空間参照系のデータベースに関する情報は、<a class="ulink" href="http://www.epsg.org/" target="_top">http://www.epsg.org/</a>をご覧下さい。</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGISは座標変換機能を提供するためにProj4ライブラリを用いています。 <code class="varname">PROJ4TEXT</code>カラムには、特定のSRIDを示すProj4座標定義文字列が入ります。たとえば次のようになります。</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>詳細情報については、Proj4ウェブサイト<a class="ulink" href="http://trac.osgeo.org/proj/" target="_top">http://trac.osgeo.org/proj/</a>をご覧下さい。<code class="filename">spatial_ref_sys.sql</code>は、全てのEPSG投影法のための<code class="varname">SRTEXT</code>と<code class="varname">PROJ4TEXT</code>とを持っています。</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="geometry_columns"></a>4.3.2. GEOMETRY_COLUMNSビュー</h3></div></div></div><p><code class="varname">GEOMETRY_COLUMNS</code>は、データベースのシステムカタログから読み取るビューです。構造は次の通りです。</p><pre class="programlisting">\d geometry_columns</pre><pre class="screen">View "public.geometry_columns"
      Column       |          Type          | Modifiers
-------------------+------------------------+-----------
 f_table_catalog   | character varying(256) |
 f_table_schema    | character varying(256) |
 f_table_name      | character varying(256) |
 f_geometry_column | character varying(256) |
 coord_dimension   | integer                |
 srid              | integer                |
 type              | character varying(30)  |</pre><p>カラムの意味は次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>ジオメトリカラムを持つフィーチャーテーブルの完全修飾名。"catalog"および"schema"の語はOracle風であることに注意して下さい。"catalog"に類似するものはPostgreSQLになく、このカラムは空白にされます。"schema"についてはPostgreSQLスキーマ名が使われています (<code class="varname">public</code>がデフォルトです)。</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>フィーチャーテーブル内のジオメトリカラムの名前。</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>そのカラムの空間の次元 (2, 3 または 4)。</p></dd><dt><span class="term">SRID</span></dt><dd><p>このテーブルの座標ジオメトリのために使われる空間参照系のID。<code class="varname">SPATIAL_REF_SYS</code>への外部キーになっています。</p></dd><dt><span class="term">TYPE</span></dt><dd><p>空間オブジェクトの型。空間カラムを単一型に制限するには、POINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTIONのうちのいずれかを、また、XYMで使う場合には、LINESTRINGM、POLYGONM、MULTIPOINTM、MULTILINESTRINGM、MULTIPOLYGONM、GEOMETRYCOLLECTIONMのうちのいずれかを使います。複数の型が混合するコレクションの場合は"GEOMETRY"を型とすることができます。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>この属性は (おそらく)OpenGIS仕様に入っていませんが、型の同一性を保証するために必要です。</p></td></tr></table></div></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Create_Spatial_Table"></a>4.3.3. 空間テーブルを作る</h3></div></div></div><p>空間データを持つテーブルの生成は、1段階でできます。2次元ラインストリングでWGS84経度緯度のジオメトリカラムを持つroadsテーブルの生成の例を次に示します。</p><pre class="programlisting">CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom geometry(LINESTRING,4326) );</pre><p>次の、3次元ラインストリングを追加する例で示す通り、標準的なALTER TABLEコマンドを使ってカラムを追加できます。</p><pre class="programlisting">ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Manual_Register_Spatial_Column"></a>4.3.4. 手動でジオメトリカラムをgeometry_columnsに登録する</h3></div></div></div><p>これが必要になる事例に、SQLビューとバルクインサートの二つがあります。バルクインサートの場合には、カラムに制約を与えるか、ALTER TABLEを実行することで、geometry_columnsテーブル内の登録を訂正することができます。ビューの場合には、CAST演算を使用します。カラムが型修飾子に基づく場合には、生成処理によって正しく登録されるので、何も行う必要がありません。ジオメトリに適用する空間関数を持たないビューも、基礎となるテーブルのジオメトリカラムと同じように登録されます。</p><pre class="programlisting">-- 次のようなビューがあるとします
CREATE VIEW public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395) As geom, f_name
        FROM public.mytable;

-- 正しく登録するには、
-- ジオメトリをキャストします。
--
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As geom, f_name
        FROM public.mytable;

-- ジオメトリタイプが確実に2次元ポリゴンだと知っているなら
-- 次のようにできます。
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name
        FROM public.mytable;</pre><pre class="programlisting">-- 次のように、バルクインサートで派生テーブルを生成したとしましょう
SELECT poi.gid, poi.geom, citybounds.city_name
INTO myschema.my_special_pois
FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);

-- 新しいテーブルに2次元インデックスを作ります
CREATE INDEX idx_myschema_myspecialpois_geom_gist
  ON myschema.my_special_pois USING gist(geom);

-- ポイントが3次元ポイントであったり、XYMポイントであったりした場合には、
-- 次のように、2次元インデックスでなくN次元インデックスを作ることになるかも
-- 知れません。
CREATE INDEX my_special_pois_geom_gist_nd
        ON my_special_pois USING gist(geom gist_geometry_ops_nd);

-- 新しいテーブルのジオメトリカラムをgeometry_columnsに手動登録するには、
-- 次のようにします。
-- カラムを型修飾子ベースにするために、基礎となるテーブル構造も変更することに
-- 注意して下さい。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);

-- PostGIS 2.0を使っていて、何らかの理由で古い制約をもとにした定義を行う
-- (派生テーブルが同じタイプやSRIDを持たないといった場合)ことが必要な場合には、
-- 新しい任意変数use_typemodをfalseにします。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false); </pre><p>古い制約を基にした手法は現在も対応していますが、制約を基にしたジオメトリカラムで直接的にビューで使われている場合は、型修飾子のようには正しくgeometry_columnsに登録されません。次の例では、型修飾子を使ったカラム定義と、制約に基づくカラムの定義とを行っています。</p><pre class="programlisting">CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom geometry(POINT,4326));
SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);</pre><p>psqlで次を実行します。</p><pre class="programlisting">\d pois_ny;</pre><p>型修飾子と制約に基づくのとでは異なった定義になっているのが見えます。</p><pre class="screen">Table "public.pois_ny"
  Column   |         Type          |                       Modifiers

-----------+-----------------------+------------------------------------------------------
 gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)
 poi_name  | text                  |
 cat       | character varying(20) |
 geom      | geometry(Point,4326)  |
 geom_2160 | geometry              |
Indexes:
    "pois_ny_pkey" PRIMARY KEY, btree (gid)
Check constraints:
    "enforce_dims_geom_2160" CHECK (st_ndims(geom_2160) = 2)
    "enforce_geotype_geom_2160" CHECK (geometrytype(geom_2160) = 'POINT'::text
        OR geom_2160 IS NULL)
    "enforce_srid_geom_2160" CHECK (st_srid(geom_2160) = 2160)</pre><p>geometry_columnsでは、両方とも正しく登録されています。</p><pre class="programlisting">SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'pois_ny';</pre><pre class="screen">f_table_name | f_geometry_column | srid | type
-------------+-------------------+------+-------
pois_ny      | geom              | 4326 | POINT
pois_ny      | geom_2160         | 2160 | POINT</pre><p>しかし、次のようにビューを作ろうとします。</p><pre class="programlisting">CREATE VIEW vw_pois_ny_parks AS
SELECT *
  FROM pois_ny
  WHERE cat='park';

SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><p>型修飾子によるgeomのビューカラムは正しく登録されますが、制約に基づくものは正しく登録されません。</p><pre class="screen">f_table_name   | f_geometry_column | srid |   type
------------------+-------------------+------+----------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY</pre><p>これは、将来的にPostGISの版で変更されるかもしれませんが、今のところは、制約に基づくビューカラムを正しく登録させるには、次のようにします。</p><pre class="programlisting">DROP VIEW vw_pois_ny_parks;
CREATE VIEW vw_pois_ny_parks AS
SELECT gid, poi_name, cat,
  geom,
  geom_2160::geometry(POINT,2160) As geom_2160
  FROM pois_ny
  WHERE cat = 'park';
SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><pre class="screen">f_table_name   | f_geometry_column | srid | type
------------------+-------------------+------+-------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         | 2160 | POINT</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="OGC_Validity"></a>4.3.5. ジオメトリのOpenGIS準拠を確実にする</h3></div></div></div><p>PostGISはOpen Geospatial Consortium (OGC)のOpenGIS仕様に準拠しています。多くのPostGISメソッドは、操作対象のジオメトリが単純かつ妥当であることが求められます (正確に言うとそう仮定します)。たとえば、ポリゴンの外に穴があるようなものの面積を計算したり、単純でない境界線を持つポリゴンを作ったりするのは、意味がありません。</p><p>OGS仕様に沿うと、<span class="emphasis"><em>単純な</em></span>ジオメトリとは、自己インタセクトや自己接触のような、異常な幾何点を持たないことです。主に0次元または1次元のジオメトリ (<code class="varname">[MULTI]POINT, [MULTI]LINESTRING</code>))に適用します。 他方、ジオメトリの妥当性は、主に2次元ジオメトリ (<code class="varname">[MULTI]POLYGON</code>)に適用し、妥当なポリゴンを特徴づける位置指定子の集合を定義します。個々のジオメトリクラスには、単純性と妥当性をさらに詳細に述べる特定の条件があります。</p><p><code class="varname">POINT</code>は0次元ジオメトリオブジェクトとして常に<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">MULTIPOINT</code>は、二つの座標値 (<code class="varname">POINT</code>)が同じでないなら<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">LINESTRING</code>は、2度同じ<code class="varname">POINT</code>を通らない (終点は除きます。この場合は線型環と呼ばれ、さらに言うと閉じていると思われます)なら<span class="emphasis"><em>単純</em></span>です。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple01.png"><div class="caption"><p><span class="bold"><strong>(a)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple02.png"><div class="caption"><p><span class="bold"><strong>(b)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple03.png"><div class="caption"><p><span class="bold"><strong>(c)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple04.png"><div class="caption"><p><span class="bold"><strong>(d)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(a)</strong></span>と<span class="bold"><strong>(c)</strong></span>は単純な<code class="varname">LINESTRING</code>です。<span class="bold"><strong>(b)</strong></span>と<span class="bold"><strong>(d)</strong></span>は単純ではありません。</p></td></tr></tbody></table></div><p><code class="varname">MULTILINESTRING</code>は、 全ての要素が単純で、かつ任意の2要素のインタセクトが要素の境界である<code class="varname">POINT</code>でだけ発生する場合に限って<span class="emphasis"><em>単純</em></span>です。 </p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple05.png"><div class="caption"><p><span class="bold"><strong>(e)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple06.png"><div class="caption"><p><span class="bold"><strong>(f)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple07.png"><div class="caption"><p><span class="bold"><strong>(g)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(e)</strong></span>と<span class="bold"><strong>(f)</strong></span>は単純な<code class="varname">MULTILINESTRING</code>です。<span class="bold"><strong>(g)</strong></span>は単純ではありません。</p></td></tr></tbody></table></div><p>定義から<code class="varname">POLYGON</code>は常に単純です。バウンダリ内の環 (外環と内環からなる)のうち二つがクロスしていないなら<span class="emphasis"><em>妥当</em></span>です。<code class="varname">POLYGON</code>の境界は、<code class="varname">POINT</code>とインタセクトするかも知れませんが、接点にしかなりません (すなわち線上にない)。<code class="varname">POLYGON</code>はカットラインまたはスパイクを持たなくても良く、内環は外環の中に完全に含まれていなければなりません。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid01.png"><div class="caption"><p><span class="bold"><strong>(h)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid02.png"><div class="caption"><p><span class="bold"><strong>(i)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid03.png"><div class="caption"><p><span class="bold"><strong>(j)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid04.png"><div class="caption"><p><span class="bold"><strong>(k)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid05.png"><div class="caption"><p><span class="bold"><strong>(l)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid06.png"><div class="caption"><p><span class="bold"><strong>(m)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(h)</strong></span>と<span class="bold"><strong>(i)</strong></span>は妥当な<code class="varname">POLYGON</code>です。<span class="bold"><strong>(jからm)</strong></span>は単一の<code class="varname">POLYGON</code>としては表現できませんが、<span class="bold"><strong>(j)</strong></span>と<span class="bold"><strong>(m)</strong></span>は妥当な<code class="varname">MULTIPOLYGON</code>として表現できます。 </p></td></tr></tbody></table></div><p><code class="varname">MULTIPOLYGON</code>は、全ての要素が妥当で、二つのポリゴン要素について内側がインタセクトしていない場合は<span class="emphasis"><em>妥当</em></span>です。ポリゴン要素の任意の二つの境界は接触してもよいですが、有限な数の<code class="varname">POINT</code>でなければなりません。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid07.png"><div class="caption"><p><span class="bold"><strong>(n)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid08.png"><div class="caption"><p><span class="bold"><strong>(o)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid09.png"><div class="caption"><p><span class="bold"><strong>(p)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(n)</strong></span>と<span class="bold"><strong>(o)</strong></span>は妥当でない<code class="varname">MULTIPOLYGON</code>です。<span class="bold"><strong>(p)</strong></span>は妥当です。</p></td></tr></tbody></table></div><p>GEOSライブラリを使って実装されている関数のほとんどは、ジオメトリがOpenGISシンプルフィーチャー仕様で定義されているように妥当であると仮定しています。ジオメトリが単純であるか、また妥当であるか、のチェックとして<a class="link" href="ST_IsSimple.html" title="ST_IsSimple">ST_IsSimple()</a>と<a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a>が使えます。</p><pre class="programlisting">-- 一般的に、線フィーチャーの妥当性のチェックは
-- 常にTRUEを返すので意味がありません
-- しかし、この例では、PostGISがOGCのIsValidの定義を拡張して
-- *一意な頂点*が2より少ないラインストリングについてFALSEを
-- 返すようにしています
gisdb=# SELECT
   ST_IsValid('LINESTRING(0 0, 1 1)'),
   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');

 st_isvalid | st_isvalid
------------+-----------
      t     |     f</pre><p>デフォルトでは、PostGISはジオメトリ入力に関するこの妥当性チェックを適用しません。複雑なジオメトリの妥当性のチェックはCPU時間を多く必要とするためです。データソースが信用できない場合は、手動でこのチェックを強制するための制約を付けることができます。</p><pre class="programlisting">ALTER TABLE mytable
  ADD CONSTRAINT geometry_valid_check
        CHECK (ST_IsValid(the_geom));</pre><p>妥当な入力ジオメトリでPostGIS関数を呼んだのに「GEOS Intersection()がエラーを投げました!」というようなエラーメッセージに遭遇したなら、PostGISまたは使用しているライブラリの中のエラーを発見しました。PostGIS開発者に連絡するべきです。PostGIS関数が妥当である入力ジオメトリから妥当でないジオメトリが返る場合も同じです。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>厳格にOGCジオメトリに準拠すると、Z値やM値を持てません。<a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a>は高次を考慮に入れません。<a class="link" href="AddGeometryColumn.html" title="AddGeometryColumn">AddGeometryColumn()</a>を実行するとジオメトリの次元をチェックする制約が加わるので、そこで2を指定すれば十分です。</p></td></tr></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="DE-9IM"></a>4.3.6. ここで、Dimensionally Extended 9 Intersection Modelまたは略してDE-9IMを見てみましょう。</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="using_postgis_dbmanagement.html#idp68487880">4.3.6.1. 理論</a></span></dt></dl></div><p>代表的な空間述語 (<a class="xref" href="ST_Intersects.html" title="ST_Intersects">ST_Intersects</a>, <a class="xref" href="ST_Contains.html" title="ST_Contains">ST_Contains</a>, <a class="xref" href="ST_Crosses.html" title="ST_Crosses">ST_Crosses</a>, <a class="xref" href="ST_Touches.html" title="ST_Touches">ST_Touches</a>, ...)は、求められる空間フィルタを適切に提供するには十分でないことが時々あります。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><div class="informalfigure-float" style="float: left;"><div class="informalfigure"><div align="left"><img src="images/de9im01.png" align="left"></div></div></div><p>たとえば、道路網を表現する線型のデータセットがあるとします。ビジネスルールを無視しているかも知れませんが、点で交差するだけでなく線上で交差する道路区間を全て判別することがGIS解析者の仕事となるかも知れません。この場合、 <a class="xref" href="ST_Crosses.html" title="ST_Crosses">ST_Crosses</a>では重要な空間フィルタとして十分ではありません。線型のフィーチャーでは、点でクロス (訳注: インタセクトより厳しい条件です)している場合のみ<code class="varname">true</code>が返ります。</p> <p>空間的にインタセクトしている (<a class="xref" href="ST_Intersects.html" title="ST_Intersects">ST_Intersects</a>)と判別された二つの区間の組み合わせについて、実際のインタセクト (<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>)を取り、 インタセクトの<a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>が''<code class="varname">LINESTRING</code>'であるかを見る (<code class="varname">[MULTI]POINT</code>や<code class="varname">[MULTI]LINESTRING</code>等からなる<code class="varname">GEOMETRYCOLLECTION</code>が帰ってくる場合にしっかり対応するため)、という2段階の方法で解くことはできます。</p> <p>よりエレガントかつ速い解法が本当に望ましいでしょう。</p></td></tr></tbody></table></div><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p> </p><div class="informalfigure-float" style="float: right;"><div class="informalfigure"><div align="right"><img src="images/de9im02.png" align="right"></div></div></div> <p>二つ目の[理論的な]例として、GIS解析者が全ての湖の境界に線でインタセクトする波止場やドックの全ての位置を特定しようとするとします。ここで、波止場の一端だけ陸にあるとします。言いかえると、波止場が湖の中にあるが完全に中に入りきってはいなくて、湖と線でインタセクトして、波止場の一方の端が完全に湖に入っていて、かつもう一方の端点が境界線上にあります。解析者は空間述語の組み合わせで、非常に望まれるフィーチャーを引き出す必要があるかも知れません。</p> <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="ST_Contains.html" title="ST_Contains">ST_Contains</a>(lake, wharf) = TRUE</p></li><li class="listitem"><p><a class="xref" href="ST_ContainsProperly.html" title="ST_ContainsProperly">ST_ContainsProperly</a>(lake, wharf) = FALSE</p></li><li class="listitem"><p><a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>(<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>(wharf, lake)) = 'LINESTRING'</p></li><li class="listitem"><p><a class="xref" href="ST_NumGeometries.html" title="ST_NumGeometries">ST_NumGeometries</a>(<a class="xref" href="ST_Multi.html" title="ST_Multi">ST_Multi</a>(<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>(<a class="xref" href="ST_Boundary.html" title="ST_Boundary">ST_Boundary</a>(wharf), <a class="xref" href="ST_Boundary.html" title="ST_Boundary">ST_Boundary</a>(lake)))) = 1</p><p>…(複雑なので以下略)</p></li></ul></div></td></tr></tbody></table></div><p>ここで、Dimensionally Extended 9 Intersection Mode、略してDE-9IMを見てみましょう。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp68487880"></a>4.3.6.1. 理論</h4></div></div></div><p><a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">OpenGIS Simple Features Implementation Specification for SQL</a>によると「二つのジオメトリの比較の基本的なアプローチは、二つのジオメトリの内部、境界、外部のインタセクションの比較と、『インタセクション行列』の要素に基づく2ジオメトリの関係の分類です」。</p><div class="glosslist"><dl><dt><span class="glossterm">境界 (Boundary)</span></dt><dd class="glossdef"><p>ジオメトリの境界は一つ低い次元のジオメトリの集合です。0次元の<code class="varname">POINT</code>の境界は空集合です。<code class="varname">LINESTRING</code>の境界は二つの端点です。 <code class="varname">POLYGON</code>の境界は外環と内環を形成する線です。</p></dd><dt><span class="glossterm">内部 (Interior)</span></dt><dd class="glossdef"><p>ジオメトリの内部は境界を取り去った際に残るジオメトリです。<code class="varname">POINT</code>の内部は<code class="varname">POINT</code>自身です。<code class="varname">LINESTRING</code>の内部は二つの端点の間の実際の点の集合です。<code class="varname">POLYGON</code>の内部はポリゴンの内側の範囲であるサーフェスです。</p></dd><dt><span class="glossterm">外部 (Exterior)</span></dt><dd class="glossdef"><p>ジオメトリの外部は、内部と境界を除いた全領域のサーフェスです。</p></dd></dl></div><p>ジオメトリ<span class="emphasis"><em>a</em></span>があり、aの内部、境界、外部をそれぞれ<span class="emphasis"><em>I(a)</em></span>、<span class="emphasis"><em>B(a)</em></span>、<span class="emphasis"><em>E(a)</em></span>とします。数学的な行列表現は次のようになります。</p><div class="styledtable"><table class="styledtable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"> </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>内部 (Interior)</strong></span></th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>境界 (Boundary)</strong></span></th><th style="border-bottom: 1px solid ; " align="center"><span class="bold"><strong>外部 (Exterior)</strong></span></th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>内部 (Interior)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ B(b) )</em></span></td><td style="border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ E(b) )</em></span></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>境界 (Boundary)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ B(b) )</em></span></td><td style="border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ E(b) )</em></span></td></tr><tr><td style="border-right: 1px solid ; " align="center"><span class="bold"><strong>外部 (Exterior)</strong></span></td><td style="border-right: 1px solid ; " align="center"><span class="emphasis"><em>dim( E(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; " align="center"><span class="emphasis"><em>dim( E(a) ∩ B(b) )</em></span></td><td style="" align="center"><span class="emphasis"><em>dim( E(a) ∩ E(b) )</em></span></td></tr></tbody></table></div><p>ここで、<span class="emphasis"><em>dim(a)</em></span>は<span class="emphasis"><em>a</em></span>の次元で、<a class="xref" href="ST_Dimension.html" title="ST_Dimension">ST_Dimension</a>で規定されますが、{0,1,2,T,F,*}の値域を持ちます。</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">0</code> =&gt; 点</p></li><li class="listitem"><p><code class="literal">1</code> =&gt; 線</p></li><li class="listitem"><p><code class="literal">2</code> =&gt; 面</p></li><li class="listitem"><p><code class="literal">T</code> =&gt; <code class="literal">{0,1,2}</code></p></li><li class="listitem"><p><code class="literal">F</code> =&gt; 空集合</p></li><li class="listitem"><p><code class="literal">*</code> =&gt; 何でも良い</p></li></ul></div><p>二つのオーバラップするポリゴンについて可視化すると、次のようになります。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col width="80pt"><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; "> </td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;"><tr><td align="center" valign="middle"><img src="images/de9im04.png" align="middle"></td></tr></table></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;"><tr><td align="center" valign="middle"><img src="images/de9im03.png" align="middle"></td></tr></table></div></div></td><td style=""><p> </p><div class="styledtable"><table class="styledtable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col><col><col><col></colgroup><thead valign="middle"><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"> </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>内部 (Interior)</strong></span></th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>境界 (Boundary)</strong></span></th><th style="border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>外部 (Exterior)</strong></span></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>内部 (Interior)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im05.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>2</strong></span></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im06.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im07.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>2</strong></span></p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>境界 (Boundary)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im08.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im09.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>0</strong></span></p></td><td style="border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im10.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>1</strong></span></p></td></tr><tr><td style="border-right: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>外部 (Exterior)</strong></span></td><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im11.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>2</strong></span></p></td><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im12.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="" align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im13.png"></div></div><p><span class="emphasis"><em>dim(...) = </em></span><span class="bold"><strong>2</strong></span></p></td></tr></tbody></table></div></td></tr></tbody></table></div><p>左から右、上から下に読むと、次元行列は'<span class="bold"><strong>212101212</strong></span>'と表現されます。</p><p>一つ目の例である、2線が線上でインタセクトする場合の関係行列は'<span class="bold"><strong>1*1***1**</strong></span>'となります。</p><pre class="programlisting">-- 線上でクロスする道路区間の判別
SELECT a.id
FROM roads a, roads b
WHERE a.id != b.id
AND a.geom &amp;&amp; b.geom
AND ST_Relate(a.geom, b.geom, '1*1***1**');</pre><p>二つ目の例である、一部が湖の水涯線上にある波止場についての関係行列は'<span class="bold"><strong>102101FF2</strong></span>'となります。</p><pre class="programlisting">-- 一部が湖の水涯線上にある波止場の判別
SELECT a.lake_id, b.wharf_id
FROM lakes a, wharfs b
WHERE a.geom &amp;&amp; b.geom
AND ST_Relate(a.geom, b.geom, '102101FF2');</pre><p>詳細情報ついては、次のページをご覧ください。</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">OpenGIS Simple Features Implementation Specification for SQL</a> (1.1版, 2.1.13.2節)</p></li><li class="listitem"><p><a class="ulink" href="https://en.wikipedia.org/wiki/DE-9IM" target="_top">Dimensionally Extended Nine-Intersection Model (DE-9IM)</a></p></li><li class="listitem"><p><a class="ulink" href="http://docs.geotools.org/latest/userguide/library/jts/dim9.html" target="_top">GeoTools: Point Set Theory and the DE-9IM Matrix</a></p></li><li class="listitem"><p>Hui Xiongさんによる<span class="emphasis"><em>Encyclopedia of GIS</em></span></p></li></ul></div></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="loading_geometry_data"></a>4.4. GIS (ベクタ)データをロードする</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68579400">4.4.1. SQLを使ってロードする</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#shp2pgsql_usage">4.4.2. shp2pgsql: ESRIシェープファイルローダを使う</a></span></dt></dl></div><p>空間テーブルを作成したら、これでGISデータをデータベースにアップロードする準備ができたことになります。現在、PostGIS/PostgreSQLデータベースにデータをロードするには、SQLステートメントを使う、またはシェープファイルのローダ/ダンパを使う、二つの方法があります。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp68579400"></a>4.4.1. SQLを使ってロードする</h3></div></div></div><p>データをテキスト表現に変換できるなら、フォーマットされたSQLを使うのがデータをPostGISに入れる最も簡単な方法です。Oracleや他のSQLデータベースを使うように、SQL端末モニタにSQLの"INSERT"ステートメントで一杯になった大きなテキストファイルをパイプで送ることで、大量のデータをロードできます。</p><p>データアップロードファイル (たとえば<code class="filename">roads.sql</code>)は次のようになるでしょう。</p><pre class="programlisting">BEGIN;
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');
COMMIT;</pre><p>データファイルは、次に示す"psql"というSQL端末モニタを使って、簡単にPostgreSQLにパイプで送ることができます。</p><pre class="programlisting">psql -d [データベース名] -f roads.sql</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="shp2pgsql_usage"></a>4.4.2. shp2pgsql: ESRIシェープファイルローダを使う</h3></div></div></div><p><code class="filename">shp2pgsql</code>データローダは、ESRIシェープファイルをPostGIS/PostgreSQLデータベースに、ジオメトリまたはジオグラフィとして挿入するための適切なSQLに変換します。ローダには、次に示すコマンドラインフラグによって区別される、いくつかの操作モードがあります。 </p><p>また、コマンドラインローダのほとんどのオプションに対応する<code class="filename">shp2pgsql-gui</code>グラフィカルユーザインタフェースがあります。一度限りのロードしか行わずスクリプト化しない場合やPostGISに不慣れな方にとって便利になるかもしれません。これはpgAdminIIIのプラグインとして構築することもできます。 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">(c|a|d|p) 相互に排他的なオプションです</span></dt><dd><p>
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-c</span></dt><dd><p>新しいテーブルの作成とシェープファイルからのデータの読み込みを行います。<span class="emphasis"><em>これがデフォルトモードです</em></span>。 </p></dd><dt><span class="term">-a</span></dt><dd><p>シェープファイルからデータベーステーブルにデータを追加します。複数のファイルをロードするためにこのオプションを使う場合は、これらのファイルは同じ属性と同じデータ型を持つ必要があります。 </p></dd><dt><span class="term">-d</span></dt><dd><p>シェープファイルにあるデータを持つ新しいテーブルを作成する前にデータベーステーブルを削除します。 </p></dd><dt><span class="term">-p</span></dt><dd><p>テーブル作成のSQLコードを生成するだけで、実際のデータは追加しません。このモードは、テーブル作成とデータロードとを完全に分けたい場合に使用します。 </p></dd></dl></div><p>
        </p></dd><dt><span class="term">-?</span></dt><dd><p>ヘルプ画面を表示します。 </p></dd><dt><span class="term">-D</span></dt><dd><p>出力データにPostgreSQLのダンプ書式を用います。このモードは-a, -c, -dと組み合わせて利用します。デフォルトの"insert"によるSQL書式よりも、大変早くロードできます。大きなデータセットではこちらを使用して下さい。 </p></dd><dt><span class="term">-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;</span></dt><dd><p>指定したSRIDを持つジオメトリテーブルの生成や追加を行います。FROM_SRIDが与えられた場合には、入力シェープファイルに、これを使います 。この場合には、ジオメトリは変更先SRIDに投影変換します。 </p></dd><dt><span class="term">-k</span></dt><dd><p>識別子 (カラム、スキーマおよび属性)の大文字小文字を保持します。シェープファイルの属性は全て大文字であることに注意して下さい。 </p></dd><dt><span class="term">-i</span></dt><dd><p>全ての整数を標準の32ビット整数に強制します。DBFヘッダではそれが正当であったとしても、64ビットのbigintを生成しません。 </p></dd><dt><span class="term">-I</span></dt><dd><p>ジオメトリカラムにGiSTインデックスを生成します。 </p></dd><dt><span class="term">-m</span></dt><dd><p>-m <code class="filename">a_file_name</code>で、長いカラム名を10文字のDBFカラム名に対応付けるファイルを指定します。ファイルは、1以上の行を持ちます。各行は空白区切りで二つの名前を持ち、行頭行末に空白を入れません。例を次に示します。 </p><pre class="programlisting">COLUMNNAME DBFFIELD1
AVERYLONGCOLUMNNAME DBFFIELD2</pre><p>
        </p></dd><dt><span class="term">-S </span></dt><dd><p>マルチ系ジオメトリの替りに単一ジオメトリを生成します。全てのジオメトリが実際に単一である (たとえば単一の外環でなるMULTIPOLYGONや単一の頂点でなるMULTIPOINT)場合にのみ成功します。 </p></dd><dt><span class="term">-t &lt;次元&gt;</span></dt><dd><p>出力ジオメトリが特定の次元を持つよう強制します。次元は、2D, 3DZ, 3DM, 4Dの文字列を使います。 </p><p>入力の次元が出力より小さい場合には、出力では0が入ります。入力の次元が大きい場合には、外されます。 </p></dd><dt><span class="term">-w</span></dt><dd><p>出力書式をWKBでなくWKTにします。精度が低下して、座標変動が発生しうることに注意が必要です。 </p></dd><dt><span class="term">-e</span></dt><dd><p>トランザクションを使わずに、ステートメントごとに実行するようにします。エラーの元となる不良なジオメトリがいくつか含んでいる時に、大半の良好なデータのロードが可能にするものです。ダンプ書式ではトランザクションを常に使うので、-Dフラグを指定している場合には使えません。 </p></dd><dt><span class="term">-W &lt;エンコーディング&gt;</span></dt><dd><p>入力データ (dbfファイル)のエンコーディングを指定します。全てのdbfの属性は指定されたエンコーディングからUTF8に変換されます。SQL出力結果には <code class="code">SET CLIENT_ENCODING to UTF8</code>が含まれるようになり、バックエンドはUTF-8からデータベースが内部利用のために設定したエンコーディングに再変換できます。 </p></dd><dt><span class="term">-N &lt;方針&gt;</span></dt><dd><p>NULLジオメトリ操作方針(insert*=挿入, skip=スキップ, abort=強制終了)を選択します。 </p></dd><dt><span class="term">-n</span></dt><dd><p>DBFファイルのみインポートします。対応するシェープファイルを持っていない場合、 自動的にこのモードになり、DBFファイルのみロードします。 このフラグは、完全なシェープファイル群を持っていて、属性データだけが欲しくてジオメトリが欲しくない時のみ使用します。 </p></dd><dt><span class="term">-G</span></dt><dd><p>ジオメトリ型のかわりに、ジオグラフィ型で、WGS84経度緯度 (SRID=4326)を使用します (経度緯度データが必要です)。 </p></dd><dt><span class="term">-T &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのテーブル空間を指定します。 -Xパラメータが使われない場合には、インデックスはデフォルトのテーブル空間を使用します。PostgreSQL文書には、テーブル空間を用いるべき時に関する良い文書があります。 </p></dd><dt><span class="term">-X &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのインデックスで使われるテーブル空間を指定します。 主キーインデックスに適用され、-Iが合わせて使われている場合にはGiST空間インデックスにも適用されます。 </p></dd></dl></div><p>ローダを使って入力ファイルを生成してアップロードするセッション例は次の通りです。 </p><pre class="programlisting"># shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql
# psql -d roadsdb -f roads.sql</pre><p>変換とアップロードはUNIXのパイプを使うと一回で実行できます。 </p><pre class="programlisting"># shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="retrieving_vector-data"></a>4.5. GISデータを検索する</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68658248">4.5.1. SQLを使ってデータを検索する</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68668744">4.5.2. ダンパを使う</a></span></dt></dl></div><p>データは、SQLまたはシェープファイルローダ/ダンパを使ってデータベースから抜き出すことができます。SQLに関する節において、空間テーブルでの比較とクエリを行うために用いることができる演算子のいくつかを議論します。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp68658248"></a>4.5.1. SQLを使ってデータを検索する</h3></div></div></div><p>データベースからデータを引き出す最も直接的な手段は、次のように、SQLのSELECTクエリを使って返ってくるレコードとカラムの数を減らし、結果のカラムを可読テキストファイルにダンプするやり方です。</p><pre class="programlisting">db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;

road_id | geom                                    | road_name
--------+-----------------------------------------+-----------
          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd
          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd
          3 | LINESTRING(192783 228138,192612 229814) | Paul St
          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
          7 | LINESTRING(218421 284121,224123 241231) | Chris Way
(6 rows)</pre><p>しかし、返ってくる結果の数を削るために、なんらかの制限をかけることが重要となるときがあるでしょう。属性ベースの制限の場合、非空間テーブルで使う通常の文法と同じSQLを使うだけです。空間ベースの制限の場合、次の演算子が使用可能であり、便利です。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ST_Intersects</span></dt><dd><p>この関数は、二つのジオメトリが空間を共有しているかどうかをテストします。</p></dd><dt><span class="term">=</span></dt><dd><p>この関数で、二つのジオメトリが幾何的に同一であるかを見ることができます。たとえば、'POLYGON((0 0,1 1,1 0,0 0))' は 'POLYGON((0 0,1 1,1 0,0 0))' と同じかを見ることができます (これは同じとなります)。 </p><p>ご注意: PostGIS 2.4より前では、これはジオメトリのボックスでの比較でした。</p></dd></dl></div><p>次に、これらの演算子をクエリで使うことができます。SQLコマンドラインからジオメトリとボックスの指定を行うときは、明示的に文字列表現をジオメトリに変換しなければならないことに注意して下さい。たとえば、次のようになります。ただし312は架空の空間参照系番号で、ここでのデータに合致しています。</p><pre class="programlisting">SELECT road_id, road_name
  FROM roads
  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::geometry;</pre><p>上のクエリは"ROADS_GEOM"テーブルから、その値と等価である単一のレコードを返します。</p><p>道路がポリゴンで定義した面を通過するかどうかをチェックするには次のようにします。</p><pre class="programlisting">SELECT road_id, road_name
FROM roads
WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');</pre><p>最も一般的な空間クエリは「フレームベース」のクエリでしょう。これは、表示するためのデータの価値のある「マップフレーム」を取得するために、データブラウザやウェブマッパのようなクライアントソフトウェアに使われます。 </p><p>"&amp;&amp;"演算子を使うとき、比較フィーチャーをBOX3DかGEOMETRYかに指定することができます。ただし、GEOMETRYを指定すると、それのバウンディングボックスが比較に使われます。</p><p>次に示すクエリのように、フレームにBOX3Dオブジェクトを使います。</p><pre class="programlisting">SELECT ST_AsText(roads_geom) AS geom
FROM roads
WHERE
  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);</pre><p>エンベロープの投影を指定するためにSRID 312を使っていることに注意して下さい。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp68668744"></a>4.5.2. ダンパを使う</h3></div></div></div><p><code class="filename">pgsql2shp</code>テーブルダンパは、データベースに直接接続して、テーブル (あるいはクエリによって定義されたもの)をシェープファイルに変換するものです。基本的な文法は次の通りです。</p><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;database&gt; [&lt;スキーマ&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; &lt;クエリ&gt;</pre><p>コマンドラインオプションは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-f &lt;ファイル名&gt;</span></dt><dd><p>特定のファイル名に出力を書きこみます。</p></dd><dt><span class="term">-h &lt;ホスト&gt;</span></dt><dd><p>接続先データベースのホスト名。</p></dd><dt><span class="term">-p &lt;ポート&gt;</span></dt><dd><p>接続先データベースのポート。</p></dd><dt><span class="term">-P &lt;パスワード&gt;</span></dt><dd><p>データベースに接続するためのパスワード。</p></dd><dt><span class="term">-u &lt;ユーザ名&gt;</span></dt><dd><p>データベースに接続する際のユーザ名。</p></dd><dt><span class="term">-g &lt;ジオメトリカラム&gt;</span></dt><dd><p>複数のジオメトリカラムを持つテーブルの場合の、シェープファイルの出力に使用するジオメトリカラム。</p></dd><dt><span class="term">-b</span></dt><dd><p>バイナリカーソルを使います。これは、実行時間を短くしますが、テーブルの非ジオメトリ属性がテキストへのキャストを持っていない場合には、動作しません。</p></dd><dt><span class="term">-r</span></dt><dd><p>Rawモード。<code class="varname">gid</code>フィールドを落としたり、カラム名をエスケープしてはいけません。</p></dd><dt><span class="term">-m <code class="varname">ファイル名</code></span></dt><dd><p>識別名を10文字名に再割り当てします。 ファイルの中身は、一つの空白で区切られ、前と後に空白が無い二つのシンボルの行からなります。VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER等となります。</p></dd></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp68686664"></a>4.6. インデックスを構築する</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#gist_indexes">4.6.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#brin_indexes">4.6.2. BRINインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#spgist_indexes">4.6.3. SP-GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68713544">4.6.4. インデックスを使う</a></span></dt></dl></div><p>インデックスは大きなデータセットを持つ空間データベースの利用を可能にするものです。インデックスなしでは、地物の検索でデータベースの全レコードを「シーケンシャルスキャン」する必要があります。インデックスをつけることで、データを検索木に組織化して、特定のレコードを発見するための検索をより早くすることができます。 PostgreSQLは、B木、SP-GiST、GiSTの3種類のインデックスにデフォルトで対応しています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>B木は、数字、文字、日付といった、一つの軸に沿ってソートできるデータに使用します。 空間データは空間充填曲線、Z階数曲線またはヒルベルト曲線に沿ってソートされます。しかし、この表現は一般的な演算子の速度向上を許しません。 </p></li><li class="listitem"><p>GiST (Generalized Search Trees)インデックスはデータを「一方へのもの」 (訳注: 「左側にあるもの」「上側にあるもの」など)、「オーバラップするもの」、「中にあるもの」に分割して、GISデータを含む幅広いデータ型で使えるようにしたものです。PostGISではGISデータにインデックスを付けるためにGiSTの上でR木インデックス実装を使用しています。</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="gist_indexes"></a>4.6.1. GiSTインデックス</h3></div></div></div><p>GiSTは「汎用的な検索木 (Generalized Search Tree)」の意味で、インデックスの一般化された形式です。GISインデックスに加えて、GiSTは通常のB木インデックスに従わない全ての種類の不規則なデータ構造 (整数配列, スペクトラルデータ等)の検索速度を向上させるために使います。</p><p>ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデックスを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常のインデックスを属性フィールドに追加します)。</p><p>GiSTインデックスをジオメトリカラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>上の文では常に2次元インデックスを構築します。n次元インデックスをジオメトリ型で使うには、次の文でインデックスを生成できます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] gist_geometry_ops_nd);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムではより遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="brin_indexes"></a>4.6.2. BRINインデックス</h3></div></div></div><p>BRINは"Block Range Index"のことで、PostgreSQL 9.5で導入された一般性のあるインデックスの形式です。BRINは不可逆インデックスで、主に読み取り効率と書き込み効率とを妥協させるために使われます。主要な目標は、非常に大きなテーブルの取り扱いで、そのテーブルのために、テーブル内の物理的な位置との自然な相関があるカラムを一部に持ちます。GISインデックスだけでなく、BRINは規則的だったりそうでない多種多様なデータ構造 (整数、配列等)における検索速度の向上のために使われます。</p><p>ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデックスを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常のインデックスを属性フィールドに追加します)。GiSTインデックスは、サイズがデータベースに割り当てられているRAM容量を超えずに、ストレージサイズが十分であり、かつ書き込みワークロードのペナルティに余裕がある限りは、本当に高性能です。その他の場合にはBRINインデックスが他の選択肢として考えられます。 </p><p>BRINインデックスの原理は、テーブルブロックの集合の全ての行に含まれる全てのジオメトリを余すところなく取り込んだバウンディングボックスだけを格納することです。明らかに、このインデックス手法は、ブロックレンジの結果バウンディングボックスが相互に排他的になるように、データが物理的に並ぶ場合にだけ効率が良くなります。結果インデックスは本当に小さいのですが、多くの場合で、GiSTインデックスより効率が落ちます。</p><p>BRINインデックスの構築はGiSTインデックスの構築より少ない資源集約で済みます。BRINインデックスがGiSTインデックスが求めるよりも十分の一以下であるのが本当に一般的です。BRINインデックスは、多数のテーブルブロックに対して一つのバウンディングボックスを格納するだけなので、この手の他のインデックスよりもディスク使用量が数千分の一程度で済むのが一般的です。</p><p>レンジ内で要約するブロック数を選択できます。この数字を減らすと、インデックスは大きくなりますが、効率向上の助けになる可能性があります。</p><p>BRINインデックスを「ジオメトリ」カラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ); </pre><p>上の文では常に2次元インデックスを構築します。3次元インデックスは次の文で生成できます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_3d);</pre><p>また、4次元演算子クラスを使う4次元インデックスを使うこともできます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_4d);</pre><p>上の書式では、デフォルトの数値やレンジ内ブロック数を使っていますが、値は128です。ブロック数を指定するには、レンジ内の要約をすることになります。次の文のようにして作ります。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ) WITH (pages_per_range = [数字]); </pre><p>また、BRINインデックスは、多数の行で一つのインデックス値を格納することを心に留めておいて下さい。テーブルに違う次元のジオメトリを格納する場合には、インデックスの効率が悪くなります。この効率欠落を回避するには、格納したジオメトリの次元数の最小値となる演算子クラスを選択します。 </p><p>「ジオグラフィ」型もまたBRINインデックスに対応しています。BRINインデックスを「ジオグラフィ」カラムに構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオグラフィカラム名] ); </pre><p>上の書式では常に回転楕円対面上の地理空間オブジェクトの2次元インデックスを構築します。 </p><p>現在のところは「包括対応」だけをここで考えています。これは、<code class="varname">&amp;&amp;</code>、<code class="varname">~</code>と<code class="varname">@</code>演算子だけが2次元の場合に使われることを意味します (「ジオメトリ」「ジオグラフィ」の両方)。<code class="varname">&amp;&amp;&amp;</code>演算子は3次元ジオメトリで使えます。しばらくはKNN検索に対応しません。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="spgist_indexes"></a>4.6.3. SP-GiSTインデックス</h3></div></div></div><p>SP-GiSTは、「空間分割された一般探索木」を表します。四分木、k次元木、基数木 (トライ木)のような分割探索木に対応するインデックスの総称的な形式です。このデータ構造の一般的な機能は、検索空間を反復して分割することですが、分割は等しいサイズである必要はありません。SP-GiSTは、GISインデックスだけでなく、電話回線のルーティングや、IPルーティング、部分文字列検索等といった、様々な種類のデータを探索する速度の向上に使われます。 </p><p>GiSTインデックスのためのケースですので、空間オブジェクトを覆うバウンディングボックスを保存するという意味で、SP-GiSTインデックスは不可逆です。SP-GiSTインデックスは、GiSTインデックスの選択肢の一つとして考えることができます。能率試験によって、SP-GiSTインデックスは,、多数のオーバラップするオブジェクトがある「スパゲッティデータ」と呼ばれる状態のときに、特に有利であることが分かりました。</p><p>一度GISデータテーブルが数千行を超えると、データの空間探索の速度向上にSP-GiSTインデックスを使うと良いかも知れません。「ジオメトリ」カラムにSP-GiSTインデックスを構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>上の文では、2次元インデックスを構築します。ジオメトリ型の3次元インデックスは、次のように、3次元演算子クラスを使用して生成します。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ([ジオメトリカラム] spgist_geometry_ops_3d);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムでは、より遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre><p>SP-GiSTインデックスは次の演算子を含むクエリの実行速度を向上させられます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>2次元インデックスについては &lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, |&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~= 。</p></li><li class="listitem"><p>3次元インデックスについては &amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@ 。</p></li></ul></div><p>現時点ではkNN探索に対応していません。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp68713544"></a>4.6.4. インデックスを使う</h3></div></div></div><p>通常、インデックスは見えないところでデータアクセスの速度向上を行います。すなわち、ひとたびインデックスが構築されたら、クエリプランナは透過的に、クエリプランの速度を向上させるためにインデックス情報を使うべき時を判断します。残念なことに、PostgreSQLクエリプランナは、GiSTインデックスの使用について十分に最適化できず、時々、検索で空間インデックスを使用すべきなのに、テーブル全体を順に走査することがあります。</p><p>空間インデックスが使用されていない (または属性インデックスがその問題のために使用されていない)場合、次の二つのことができます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>まず、クエリプランを読んで、クエリが実際に必要な計算をしようとしているか確認します。JOIN条件を忘れていたり、間違ったテーブルに付けていたりすることで、暴走することがあり、予期せずに何度もテーブル全体を得ることになります。クエリプランを取得するには、クエリの前にEXPLAINキーワードを追加します。</p></li><li class="listitem"><p>次に、テーブル内の値の数量と分布に関する統計情報を収集するとともに、クエリプランナにインデックス使用にかかる意思決定のための、より良い情報を与えるようにします。<span class="command"><strong>VACUUM ANALYZE</strong></span>は両方を計算します。</p><p>データベースに対する定期的なvacuumは常に実行するべきです。多くのPostgreSQLデータベースエージェントは、閑散時のcronジョブとして定期的に<span class="command"><strong>VACUUM</strong></span>を実行します。</p></li><li class="listitem"><p>vacuumが働かないなら、<span class="command"><strong>set enable_seqscan to off;</strong></span>コマンドで、一時的にプランナに対してインデックス情報の使用を強制することができます。この方法で、プランナがインデックスを使用するプランを生成できるかどうか確認できます。このコマンドはデバッグにのみ使用すべきです。一般的に言うと、プランナはあなたよりインデックスを使うべき時を知っています。クエリを実行したら、<code class="varname">ENABLE_SEQSCAN</code>設定を戻して、他のクエリでは通常通りプランナを使用します。</p></li><li class="listitem"><p>もし、<span class="command"><strong>set enable_seqscan to off;</strong></span>がクエリの実行に役立っているなら、お使いのPostgreSQLはハードウェアにあわせた調整をしていないようです。順に走査する際のコストとインデックスを使う際のコストとを比較してプランナが間違っていることに気付いたら、postgresql.confで<code class="varname">random_page_cost</code>の値を減らしてみるか、<span class="command"><strong>set random_page_cost to 1.1;</strong></span>を使ってみてください。このパラメータのデフォルト値は4ですが、それを1 (SSDの場合)または2 (高速磁気ディスクの場合)にして下さい。値を減らすことで、プランナがよりインデックススキャンを行う傾向になります。</p></li><li class="listitem"><p><span class="command"><strong>set enable_seqscan to off;</strong></span>がクエリの役に立たない場合には、PostgreSQLがまだ解決できない構文を使ってしまっているのかもしれません。インラインSELECTのサブクエリが一つの例です。プランナが最適化できるように書き直す必要があります。LATERAL JOINと呼びます。</p></li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp68723528"></a>4.7. 複雑なクエリ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#idp68731080">4.7.1. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="using_postgis_dbmanagement.html#examples_spatial_sql">4.7.2. 空間SQLの例</a></span></dt></dl></div><p>空間データベース機能の<span class="emphasis"><em>レゾンデートル</em></span>は、通常はデスクトップGISに求める機能を、データベース内部のクエリで実現してすることです。PostGISを効果的に使用するには、どの空間関数が有効かを知り、また、良好なパフォーマンスを提供する所に適切にインデックスがあることが保証されていることが求められます。なお、本例ではSRID 312を使っていますが、これは純粋に例として出しているだけです。spatial_ref_sysテーブルにあり、データの投影法に合致している、本当のSRIDを使ってください。空間参照系を持たないデータについては、なぜ持っていないのか、持つべきなのかも知れないのか、をじっくり*考えてください*。 たとえば分子内部や火星旅行の到達位置といった、定義された空間参照系を持たない場合には、単にSRIDを無視するか、一つ作成して<code class="varname">spatial_ref_sys</code>テーブルに追加して下さい。</p><p>分子の内部構造や開発前の遊園地の間取り図といった、空間参照系を持たないものを扱うためだったら、問題ありません。ただし、遊園地の位置が決まっている場合だと、遊園地が既存構造の上に入り込まないようにするためだけでも、その位置に適切な平面座標系を使うようにします。</p><p>核戦争時に人類を輸送するための火星遠征を計画し、火星居住用の地図を作成する場合であったとしても、<a class="ulink" href="http://spatialreference.org/ref/iau2000/mars-2000/" target="_top">Mars 2000</a>といった地球以外の座標系を作成し、<code class="varname">spatial_ref_sys</code>に挿入して使うことができます。この火星座標系は非平面 (回転楕円体面の度)ですが、ジオグラフィ型で長さや、計測近似値を、度単位でなくメートル単位で得ることができます。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp68731080"></a>4.7.1. インデックスの利点を使う</h3></div></div></div><p>クエリを作成するとき、&amp;&amp;のようなバウンディングボックスを基準とした演算子によってのみGiST空間インデックスの利点が出てくることだけは覚えておくことが重要です。<code class="varname">ST_Distance()</code>のような関数では演算の最適化を行うためにインデックスを使うことができません。たとえば、次のクエリでは、大きなテーブルでは本当に遅くなります。</p><pre class="programlisting">SELECT the_geom
FROM geom_table
WHERE ST_Distance(the_geom, 'SRID=312;POINT(100000 200000)') &lt; 100</pre><p>このクエリは、geom_tableにおける (100000, 200000)の点から距離が100単位以内にある全てのジオメトリを選択します。このクエリは、テーブル内にあるそれぞれの点と指定した点との距離を計算する、すなわち、それぞれの行で一つの<code class="varname">ST_Distance()</code>計算を行うため、遅くなります。1ステップでインデックスを利用するST_DWithin関数を使って、求められる距離計算の量を減らすことで回避できます。次のようにします。</p><pre class="programlisting">SELECT the_geom
FROM geom_table
WHERE ST_DWithin(the_geom, 'SRID=312;POINT(100000 200000)', 100)
</pre><p>このクエリは、同じジオメトリを選択しますが、より効果的な方法で行われます。the_geomにGiSTインデックスがあると仮定すると、クエリプランナは<code class="varname">ST_Distance()</code>関数の結果を計算する前にインデックスを使って行を減らせると認識します。 &amp;&amp;演算子で使われる<code class="varname">ST_MakeEnvelope</code>ジオメトリは、元のポイントに中央寄せした200単位の正方形です。これは「クエリボックス」です。&amp;&amp;演算子は、結果セットを「クエリボックス」にオーバラップするバウンディングボックスを持つジオメトリだけに素早く減らすためにインデックスを使います。「クエリボックス」がジオメトリテーブル全体の範囲より十分に小さいと仮定すると、行われなければならない距離計算の量は劇的に減少します。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="examples_spatial_sql"></a>4.7.2. 空間SQLの例</h3></div></div></div><p>本節の例では、線型の道、ポリゴンの自治体境界、の二つのテーブルを使います。テーブルの定義をしまします。<code class="varname">bc_roads</code>については次の通りです。</p><pre class="programlisting">Column      | Type              | Description
------------+-------------------+-------------------
gid         | integer           | Unique ID
name        | character varying | Road Name
the_geom    | geometry          | Location Geometry (Linestring)</pre><p><code class="varname">bc_municipality</code>テーブルの定義については次の通りです。</p><pre class="programlisting">Column     | Type              | Description
-----------+-------------------+-------------------
gid        | integer           | Unique ID
code       | integer           | Unique ID
name       | character varying | City / Town Name
the_geom   | geometry          | Location Geometry (Polygon)</pre><div class="qandaset"><a name="idp68738760"></a><dl><dt>4.7.2.1. <a href="using_postgis_dbmanagement.html#qa_total_length_roads">道路の総延長はkm表記でいくらになるでしょう?</a></dt><dt>4.7.2.2. <a href="using_postgis_dbmanagement.html#idp68745800">プリンスジョージ市の大きさはha表記でいくらになるでしょう?</a></dt><dt>4.7.2.3. <a href="using_postgis_dbmanagement.html#idp68748360">県内で最も大きな面積となる自治体はどこでしょう?</a></dt><dt>4.7.2.4. <a href="using_postgis_dbmanagement.html#idp68751176">各自治体内に含まれる道路の総延長はいくらでしょう?</a></dt><dt>4.7.2.5. <a href="using_postgis_dbmanagement.html#idp68753992">プリンスジョージ市内の全ての道路からなるテーブルを作る</a></dt><dt>4.7.2.6. <a href="using_postgis_dbmanagement.html#idp68756424">ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</a></dt><dt>4.7.2.7. <a href="using_postgis_dbmanagement.html#idp68758472">穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="qa_total_length_roads"></a><a name="idp68739400"></a><p><b>4.7.2.1.</b></p></td><td align="left" valign="top"><p>道路の総延長はkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>この問題は、次のようなとても単純なSQLで答えを得ることができます。</p><pre class="programlisting">SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;

km_roads
------------------
70842.1243039643
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68745800"></a><a name="idp68746056"></a><p><b>4.7.2.2.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市の大きさはha表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリでは、属性条件 (municipality name, 自治体名)に空間計算 (面積)を併用しています。</p><pre class="programlisting">SELECT
  ST_Area(the_geom)/10000 AS hectares
FROM bc_municipality
WHERE name = 'PRINCE GEORGE';

hectares
------------------
32657.9103824927
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68748360"></a><a name="idp68748616"></a><p><b>4.7.2.3.</b></p></td><td align="left" valign="top"><p>県内で最も大きな面積となる自治体はどこでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリは、空間計測をクエリ条件に持ってきています。この問題へのアプローチの方法はいくつかありますが、最も効率的なのは次の通りです。</p><pre class="programlisting">SELECT
  name,
  ST_Area(the_geom)/10000 AS hectares
FROM
  bc_municipality
ORDER BY hectares DESC
LIMIT 1;

name           | hectares
---------------+-----------------
TUMBLER RIDGE  | 155020.02556131
(1 row)</pre><p>このクエリの答えを出すためには、全てのポリゴンの面積を求める必要があることに注意して下さい。このクエリを多く実行する場合、性能向上のためにテーブルにareaカラムを追加して、別のインデックスを追加することができるようにするのは、意義のあることです。結果を距離について降順に並べ替え、PostgreSQLの"LIMIT"コマンドを用いることで、max()のような集約関数を使わずに、簡単に最も大きい値を集約関数を得ることができます。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68751176"></a><a name="idp68751432"></a><p><b>4.7.2.4.</b></p></td><td align="left" valign="top"><p>各自治体内に含まれる道路の総延長はいくらでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、二つのテーブルからデータを持ち込んで (結合して)いるので「空間結合」の例です。しかし、結合の条件として共通キーの上で接続するという普通のリレーションのやり方でなく空間インタラクション条件 (「含む」)を使っています。</p><pre class="programlisting">SELECT
  m.name,
  sum(ST_Length(r.the_geom))/1000 as roads_km
FROM
  bc_roads AS r,
  bc_municipality AS m
WHERE
  ST_Contains(m.the_geom, r.the_geom)
GROUP BY m.name
ORDER BY roads_km;

name                        | roads_km
----------------------------+------------------
SURREY                      | 1539.47553551242
VANCOUVER                   | 1450.33093486576
LANGLEY DISTRICT            | 833.793392535662
BURNABY                     | 773.769091404338
PRINCE GEORGE               | 694.37554369147
...</pre><p>このクエリは、テーブル内の全ての道路の合計を最終結果 (この例での話ですが約250Kmの道です)にまとめられるので、少し時間がかかります。より小さいオーバレイ (数百の道路で数千のレコード)の場合、応答はもっと早くなりえます。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68753992"></a><a name="idp68754248"></a><p><b>4.7.2.5.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市内の全ての道路からなるテーブルを作る</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは「オーバレイ」の例です。つまり、二つのテーブルを取得して、空間的に切り取られた結果からなる新しいテーブルを出力します。上で示した「空間結合」と違い、このクエリは実際に新しいジオメトリを生成します。生成されたオーバレイはターボのかかった空間結合みたいなもので、より確かな解析作業に便利です。</p><pre class="programlisting">CREATE TABLE pg_roads as
SELECT
  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,
  ST_Length(r.the_geom) AS rd_orig_length,
  r.*
FROM
  bc_roads AS r,
  bc_municipality AS m
WHERE
  m.name = 'PRINCE GEORGE'
        AND ST_Intersects(r.the_geom, m.the_geom);</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68756424"></a><a name="idp68756680"></a><p><b>4.7.2.6.</b></p></td><td align="left" valign="top"><p>ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT
  sum(ST_Length(r.the_geom))/1000 AS kilometers
FROM
  bc_roads r,
  bc_municipality m
WHERE
        r.name = 'Douglas St'
        AND m.name = 'VICTORIA'
        AND ST_Intersects(m.the_geom, r.the_geom);

kilometers
------------------
4.89151904172838
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp68758472"></a><a name="idp68758728"></a><p><b>4.7.2.7.</b></p></td><td align="left" valign="top"><p>穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT gid, name, ST_Area(the_geom) AS area
FROM bc_municipality
WHERE ST_NRings(the_geom) &gt; 1
ORDER BY area DESC LIMIT 1;

gid  | name         | area
-----+--------------+------------------
12   | SPALLUMCHEEN | 257374619.430216
(1 row)</pre></td></tr></tbody></table></div></div></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="PostGIS_FAQ.html">戻る</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="using_raster_dataman.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第3章 PostGIS よくある質問 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第5章 ラスタデータの管理、クエリ、アプリケーション</td></tr></table></div></body></html>
