<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第7章 性能向上に関する技法</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.0.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.0.0 マニュアル"><link rel="prev" href="ch06.html" title="第6章 PostGISを使う: アプリケーションを構築する"><link rel="next" href="reference.html" title="第8章 PostGISリファレンス"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第7章 性能向上に関する技法</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="performance_tips"></a>第7章 性能向上に関する技法</h1></div></div></div><div class="toc"><div class="toc-title">目次</div><dl class="toc"><dt><span class="sect1"><a href="performance_tips.html#small_tables_large_objects">7.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance_tips.html#idp70094280">7.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp70110792">7.1.2. 応急処置</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance_tips.html#database_clustering">7.2. ジオメトリインデクスでCLUSTERを実行する</a></span></dt><dt><span class="sect1"><a href="performance_tips.html#avoiding_dimension_conversion">7.3. 次元変換の回避</a></span></dt><dt><span class="sect1"><a href="performance_tips.html#database_tuning_configuration">7.4. コンフィギュレーションのチューン</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance_tips.html#idp70129096">7.4.1. 起動時</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp70167240">7.4.2. 実行時</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="small_tables_large_objects"></a>7.1. 大きなジオメトリを持つ小さなテーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="performance_tips.html#idp70094280">7.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp70110792">7.1.2. 応急処置</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp70094280"></a>7.1.1. 問題の説明</h3></div></div></div><p>現版のPostgreSQL (9.6を含む)では、TOASTテーブルに従うクエリオプティマイザの弱さに苦しみます。 TOASTテーブルは、(長いテキスト、イメージ、多数の頂点を持つ複合ジオメトリといった)通常のデータページに適合しない、(データサイズという意味では)巨大な値を納めるための「拡張部屋」の一種です。詳細情報は <a class="ulink" href="http://www.postgresql.org/docs/current/static/storage-toast.html" target="_top">the PostgreSQL Documentation for TOAST</a>をご覧ください。</p><p>(高解像度で全てのヨーロッパの国の境界を含むテーブルのような)大きなジオメトリがあるうえ、行がそう多くないテーブルを持つようになると、この問題が出てきます。テーブル自体は小さいのですが、多くのTOASTスペースを使います。例として、テーブル自体は概ね80行で3データページしか使わなくてもTOASTテーブルで8225ページを使うとします。</p><p>ここで、ジオメトリ演算子の&amp;&amp;を使って、ほとんどマッチしないようなバウンダリボックスを検索するクエリを出してみます。クエリオプティマイザにはテーブルは3ページ80行しかないように見えます。オプティマイザは、小さなテーブルを順に走査する方がインデクスを使うよりも早いと見積もります。そして、GiSTインデクスは無視すると決めます。通常なら、この見積もりは正しいです。しかし、この場合は&amp;&amp;演算子が全てのジオメトリをディスクから呼び出してバウンディングボックスと比較しなければならなくなり、ゆえに、全てのTOASTページもまた呼び出す必要があります。</p><p>この問題に苦しむかどうかを見るには、PostgreSQLの"EXPLAIN ANALYZE"コマンドを使います。詳細情報と技術情報については、PostgreSQL性能メーリングリストのスレッド<a class="ulink" href="http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php" target="_top">http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</a>をご覧下さい。</p><p>また、PostGISの新しいスレッド<a class="ulink" href="https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html" target="_top">https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html</a>もご覧下さい。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp70110792"></a>7.1.2. 応急処置</h3></div></div></div><p>PostgreSQLコミュニティでは、TOASTを意識したクエリ見積もりを作ることで、この問題を解決しようとしています。今のところは、二つの応急処置があります。</p><p>一つは、クエリプランナにインデクスの使用を強制することです。クエリを発行する前に"SET enable_seqscan TO off;"をサーバに送信します。これは基本的にクエリプランナに対して可能な限り順に走査することを避けるよう強制します。そのためGiSTインデクスを通常使うようになります。しかし、このフラグは接続するたびに設定しなければならず、他のケースにおいてはクエリプランナに誤った見積もりをさせることになるので、 "SET enable_seqscan TO on;"をクエリの後に送信すべきです。</p><p>もう一つは、順に走査することをクエリプランナが考える程度に早くすることです。これは、バウンダリボックスの「キャッシュ」を行う追加カラムを作成し、このカラムにマッチさせるようにすることで達成することができます。ここでの例では次のようになります。</p><pre class="programlisting">SELECT AddGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2');
UPDATE mytable SET bbox = ST_Envelope(ST_Force2D(the_geom));</pre><p>そして、次のように、&amp;&amp;演算子をgeom_columnに対して行っていたものをbboxに変更します。</p><pre class="programlisting">SELECT geom_column
FROM mytable
WHERE bbox &amp;&amp; ST_SetSRID('BOX3D(0 0,1 1)'::box3d,4326);</pre><p>もちろん、mytableの行を変更または追加したら、bboxを「同期」するようにしなければなりません。最もすっきりした方法はトリガです。もしくは、アプリケーションを変更してbboxカラムの現状を保持するか、テーブル更新後にいつもUPDATEクエリを実行するかでも対応できます。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database_clustering"></a>7.2. ジオメトリインデクスでCLUSTERを実行する</h2></div></div></div><p>読み込むことがほとんどで、かつほとんどのクエリでひとつのインデクスを使うようなテーブルのために、PostgreSQLはCLUSTERコマンドを提供しています。このコマンドは、全てのデータ行を、インデクス基準にあわせて物理的に再整理するので、二つの性能の利点を生みます。一つは、インデクスの範囲走査のために、データテーブルのシーク回数が劇的に減少することです。もう一つは、いくつかの小さなインデクス間隔に集中する場合には、データ行が分布するデータページがより少なくなるので、より効率的なキャッシュを持つことです (この点で、PostgreSQLマニュアルのCLUSTERコマンドのドキュメントを読むように仕向けられていると感じて下さい)。</p><p>しかし、GiSTインデクスは単純にNULL値を無視するため現在のところPostGISのGiSTインデクスのクラスタリングはできず、次のようなエラーメッセージを得ます。</p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table;
ERROR: cannot cluster when index access method does not handle null values
(エラー: インデクスアクセスメソッドがNULL値を扱わない場合クラスタ化できません)
HINT: You may be able to work around this by marking column "the_geom" NOT NULL.
(ヒント: 列"the_geom"をNOT NULLとすることで、これを回避できるかもしれません)</pre><p>ヒントメッセージにある通り、テーブルに"not null"制限を追加することで、この欠陥にとりあえず対応できます。例を示します。</p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null;
ALTER TABLE</pre><p>もちろん、ジオメトリカラムで実際にNULL値が必要な場合、この対応はできません。さらには、制限を追加するには上の方法を使わなければならず、"ALTER TABLE blubb ADD CHECK (geometry is not null);"のようなCHECK制限は使えません。</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="avoiding_dimension_conversion"></a>7.3. 次元変換の回避</h2></div></div></div><p>ときどき、テーブルで3次元、4次元のデータを持つのに、常にOpenGIS準拠のST_AsText()またはST_AsBinary()関数を使ってアクセスして 2次元ジオメトリを出力させるようなことが起きます。内部でST_Force_2d()関数を呼んでいるために発生しますが、これは、大きなジオメトリでは重大なオーバヘッドを誘引することになります。このオーバヘッドを回避するには、一度追加された次元を前もって落とし、かつこれを永続化するのが適当かも知れません。</p><pre class="programlisting">UPDATE mytable SET the_geom = ST_Force2D(the_geom);
VACUUM FULL ANALYZE mytable;</pre><p>AddGeometryColumn()を使ってジオメトリカラムを追加した場合、ジオメトリの次元に関する制限があることに注意してください。この制限を迂回するには、制限の削除が必要になります。geometry_columnsテーブル内のエントリを更新して、その後で制限を再作成することを忘れないで下さい。</p><p>大きなテーブルの場合、WHERE節、およびプライマリキー若しくは他の適切な基準によってテーブルの一部へのUPDATEを制限させて、UPDATEの実行の間に単に"VACUUM;"と実行することで、UPDATEをより小さい塊に分割するのが賢いやり方かもしれません。これにより、テンポラリディスクスペースが劇的に減少します。さらに、次元混合のジオメトリを持つ場合、"WHERE dimension(the_geom)&gt;2"によってUPDATEを制限することで、2次元で書かれているジオメトリの再書き込みをスキップさせることができます。</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="database_tuning_configuration"></a>7.4. コンフィギュレーションのチューン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="performance_tips.html#idp70129096">7.4.1. 起動時</a></span></dt><dt><span class="sect2"><a href="performance_tips.html#idp70167240">7.4.2. 実行時</a></span></dt></dl></div><p>PostGISの調整はPostgreSQLの作業量の調整と非常に似ています。ジオメトリとラスタは重く、メモリ関連の最適化は他のPostgreSQLクエリと比べて影響が大きい点だけは留意して下さい。</p><p>PostgreSQLの最適化に関する一般的な詳細は、<a class="ulink" href="https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server" target="_top">Tuning your PostgreSQL Server</a>をご覧ください。</p><p>PostgreSQL 9.4以上では、<code class="code">ALTER SYSTEM..</code>を使うことで、postgresql.confやpostgresql.auto.confを触ることなくサーバレベルで設定できます。</p><pre class="programlisting">ALTER SYSTEM SET work_mem = '256MB';
-- 起動時設定でない設定を強制します。新規接続に影響を与えます。
SELECT pg_reload_conf();
-- 現在の設定値を表示
-- 全ての設定を見るにはSHOW ALLを使います
SHOW work_mem;</pre><p>この設定に追加して、PostGISには、<a class="xref" href="reference.html#PostGIS_GUC" title="8.22. Grand Unified Custom変数 (GUC)">「Grand Unified Custom変数 (GUC)」</a>で示している、いくつかの独特の設定があります。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp70129096"></a>7.4.1. 起動時</h3></div></div></div><p>これらの設定はpostgresql.conf内にあります。 </p><p>
           <a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-query.html#GUC-CONSTRAINT-EXCLUSION" target="_top">constraint_exclusion</a>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: partition </p></li><li class="listitem"><p>一般的にテーブルのパーティショニングに使われます。デフォルトとして"partition"に設定されています。継承階層内にあり、プランナにペナルティ以外を払わないなら、クエリプランナにテーブルの制約条件の解析だけを行わせるので、PostgreSQL 8.4以上ではこれが理想的です。 </p></li></ul></div><p>
           <a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-SHARED-BUFFERS" target="_top">shared_buffers</a>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: PostgreSQL 9.6では128MB以下 </p></li><li class="listitem"><p>利用可能なRAMの25%から40%を設定します。Windowsでは高く設定することができないかも知れません。 </p></li></ul></div><p><a class="ulink" href="https://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES" target="_top">max_worker_processes</a> これは、PostgreSQL 9.4以上で有効です。PostgreSQL 9.6以上では、パラレルクエリ処理に使うプロセス数の最大値の制御で、さらに重要なものとなっています。 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: 8 </p></li><li class="listitem"><p>システムが対応できるバックグラウンドプロセスの最大値を設定します。このパラメータはサーバ起動時のみ設定できます。 </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp70167240"></a>7.4.2. 実行時</h3></div></div></div><p><a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-WORK-MEM" target="_top">work_mem</a> (並べ替えや複雑なクエリに使われるメモリ) </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: 1-4MB </p></li><li class="listitem"><p>大きなデータベースの場合や、複雑なクエリの場合、RAMが多い場合は値を大きくするように調整します。 </p></li><li class="listitem"><p>同時接続ユーザ数が多い場合や、RAMが少ない場合には値を小さくするように調整します。 </p></li><li class="listitem"><p>たくさんのRAMを持ち、少数の開発者しかいない場合は次のようにします。 </p><pre class="programlisting">SET work_mem TO '256MB';</pre><p>
            </p></li></ul></div><p><a class="ulink" href="http://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM" target="_top">maintenance_work_mem</a> (VACUUM, CREATE INDEX等で使われるメモリ) </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: 16-64MB </p></li><li class="listitem"><p>一般的には低すぎます - メモリスワップの間、入出力が拘束され、オブジェクトがロックされます。 </p></li><li class="listitem"><p>たくさんのRAMを持つ本番サーバでは32MBから1GBが推奨ですが、同時接続ユーザ数に依存します。たくさんのRAMを持ち、少数の開発者しかいない場合は次のようにします。 </p><pre class="programlisting">SET maintenance_work_mem TO '1GB';</pre><p>
            </p></li></ul></div><p>
          <a class="ulink" href="https://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER" target="_top">max_parallel_workers_per_gather</a>
        </p><p>この設定はPostgreSQL 9.6以上で使用でき、並列クエリに対応しているPostGIS 2.3以上に影響は限られます。0より大きい値に設定すると、<code class="code">ST_Intersects</code>といった関係関数を含むクエリで、複数プロセッサが使われるようにできます。その時、2倍を超える速度が出る可能性があります。予備のプロセッサが多数ある場合には、この値をプロセッサ数に変更するべきです。また、<code class="code">max_worker_processes</code>をこの値と同じにするようにします。 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>デフォルト: 0 </p></li><li class="listitem"><p>単一の<code class="varname">Gather</code>ノードが開始できるワーカの最大数を設定します。並列ワーカは、<code class="varname">max_worker_processes</code>で確立されたプロセスのプールから取得されます。要求したワーカ数は、実際には実行可能になっていない場合があることに注意して下さい。これが発生する場合には、想定より少ないワーカでプランが実行され、非効率になります。これの値を0 (デフォルト値)にすると、パラレルクエリ実行が無効になります。 </p></li></ul></div></div></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">戻る</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第6章 PostGISを使う: アプリケーションを構築する </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第8章 PostGISリファレンス</td></tr></table></div></body></html>
