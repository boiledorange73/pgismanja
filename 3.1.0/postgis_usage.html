<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第4章 PostGISの使用</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.1.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.1.0 マニュアル"><link rel="prev" href="postgis_administration.html" title="第3章 PostGIS管理"><link rel="next" href="getfaceedges_returntype.html" title="getfaceedges_returntype"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第4章 PostGISの使用</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="postgis_administration.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="getfaceedges_returntype.html">次へ</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="postgis_usage"></a>第4章 PostGISの使用</h1></div></div></div><div class="toc"><div class="toc-title">目次</div><dl class="toc"><dt><span class="sect1"><a href="postgis_usage.html#using_postgis_dbmanagement">4.1. データ管理</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#RefObject">4.1.1. GISオブジェクト</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#PostGIS_Geography">4.1.2. PostGISジオグラフィ型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp52850168">4.1.3. 空間メタデータテーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#OGC_Validity">4.1.4. ジオメトリ検証</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#loading-data">4.1.5. 空間データのロード</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#extracting-data">4.1.6. 空間データの抽出</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#build-indexes">4.1.7. 空間インデックスを構築する</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#using_postgis_query">4.2. 空間クエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#eval_spatial_rel">4.2.1. 空間関係の決定</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#using-query-indexes">4.2.2. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#examples_spatial_sql">4.2.3. 空間SQLの例</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#performance_tips">4.3. 性能向上に関する技法</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#small_tables_large_objects">4.3.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#database_clustering">4.3.2. ジオメトリインデクスでCLUSTERを実行する</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#avoiding_dimension_conversion">4.3.3. 次元変換の回避</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#idp54158328">4.4. アプリケーションのビルド</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#Using_MapServer">4.4.1. MapServerを使う</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp54217848">4.4.2. Javaクライアント (JDBC)</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp54220792">4.4.3. Cクライアント (libpq)</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#using_raster_dataman">4.5. ラスタデータの管理、クエリ、アプリケーション</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#RT_Loading_Rasters">4.5.1. ラスタのロードと生成</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#RT_Raster_Catalog">4.5.2. ラスタカタログ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#RT_Raster_Applications">4.5.3. PostGISラスタを使ったカスタムアプリケーションの構築</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#Topology">4.6. トポロジ</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#Topology_Types">4.6.1. トポロジ型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Domains">4.6.2. トポロジドメイン</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_ManagementFunctions">4.6.3. トポロジ管理とTopoGeometry管理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_StatsManagement">4.6.4. トポロジ統計管理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Constructors">4.6.5. トポロジコンストラクタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Editing">4.6.6. トポロジエディタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Accessors">4.6.7. トポロジアクセサ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Processing">4.6.8. トポロジ処理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Constructors">4.6.9. TopoGeometryコンストラクタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Editors">4.6.10. TopoGeometryエディタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeom_Accessors">4.6.11. TopoGeometryアクセサ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Outputs">4.6.12. TopoGeometry出力</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Relationships">4.6.13. トポロジ空間関係関数</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#Address_Standardizer">4.7. 住所標準化</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Basics">4.7.1. パーサの動作</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Types">4.7.2. 住所標準化の型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Tables">4.7.3. 住所標準化テーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Functions">4.7.4. 住所標準化関数</a></span></dt></dl></dd><dt><span class="sect1"><a href="postgis_usage.html#Extras">4.8. PostGIS追加機能</a></span></dt><dd><dl><dt><span class="sect2"><a href="postgis_usage.html#Tiger_Geocoder">4.8.1. Tigerジオコーダ</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using_postgis_dbmanagement"></a>4.1. データ管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#RefObject">4.1.1. GISオブジェクト</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#PostGIS_Geography">4.1.2. PostGISジオグラフィ型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp52850168">4.1.3. 空間メタデータテーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#OGC_Validity">4.1.4. ジオメトリ検証</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#loading-data">4.1.5. 空間データのロード</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#extracting-data">4.1.6. 空間データの抽出</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#build-indexes">4.1.7. 空間インデックスを構築する</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="RefObject"></a>4.1.1. GISオブジェクト</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#OpenGISWKBWKT">4.1.1.1. OpenGIS WKBとWKT</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#EWKB_EWKT">4.1.1.2. PostGIS EWKB, EWKTと標準形式</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#SQL_MM_Part3">4.1.1.3. SQL-MM第3部</a></span></dt></dl></div><p>PostGISでサポートされるGISオブジェクトは、OpenGIS Consortium (OGC)が定義する"Simple Features"標準のスーパーセットです。 PostGISはOGCの"Simple Features for SQL" (SFS)仕様で定められた全てのオブジェクトと関数に対応しています。</p><p>PostGISは標準から拡張してSRIDの組み込みに対応しています。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="OpenGISWKBWKT"></a>4.1.1.1. OpenGIS WKBとWKT</h4></div></div></div><p>OpenGIS仕様は空間オブジェクトの表現について二つの標準を定義しています。Well-Knownテキスト (WKT)形式とWell-Knownバイナリ (WKB)形式です。WKTもWKBも、オブジェクトの型とオブジェクトを形成する座標に関する情報を持っています。</p><p>フィーチャーの空間オブジェクトのテキスト表現 (WKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0)</p></li><li class="listitem"><p>POINT Z (0 0 0)</p></li><li class="listitem"><p>POINT ZM (0 0 0 0)</p></li><li class="listitem"><p>LINESTRING(0 0,1 1,1 2)</p></li><li class="listitem"><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li class="listitem"><p>MULTIPOINT((0 0),(1 2))</p></li><li class="listitem"><p>MULTIPOINT Z ((0 0 0),(1 2 3))</p></li><li class="listitem"><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))</p></li></ul></div><p>OpenGIS仕様では、空間オブジェクトの内部保存書式は空間参照系識別子 (Spatial Referencing System IDentifier, SRID)を含むことも求められます。SRIDはデータベースへの挿入のために空間オブジェクトが生成される時に求められます。</p><p>これらの書式の入出力は次のインタフェースを用いて実現できます。</p><pre class="programlisting">バイト配列 WKB = ST_AsBinary(geometry);
テキスト WKT = ST_AsText(geometry);
ジオメトリ = ST_GeomFromWKB (bytea WKB、SRID);
ジオメトリ = ST_GeometryFromText (テキスト WKT、SRID);</pre><p>たとえば、OGC空間オブジェクトを生成して挿入する妥当なINSERTステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="EWKB_EWKT"></a>4.1.1.2. PostGIS EWKB, EWKTと標準形式</h4></div></div></div><p>最初のOpenGIS使用 (1.2.0より前)は2次元ジオメトリしかサポートされておらず、また、入出力の表現においてSRIDは*決して*埋め込まれません。</p><p>最後のOpenGIS 1.2.1仕様ではZ,M修飾子を指定するXYM座標とXYZ座標に対応していますが、入出力表現に、関連するSRIDが含まれていません。</p><p>PostGIS EWKB/EWKT では 3DM, 3DZ, 4D の座標サポートが追加され、SRID情報が埋め込まれます。しかしながら、EWKB/EWKT出力には次のような相違点があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>XYZジオメトリの場合、Z修飾子は削除されます。</p><p>OpenGIS: POINT Z (1 2 3)</p><p>EWKB/EWKT: POINT(1 2 3)</p></li><li class="listitem"><p>XYMジオメトリはM修飾子を保持します。</p><p>OpenGIS: POINT M (1 2 3)</p><p>EWKB/EWKT: POINTM(1 2 3)</p></li><li class="listitem"><p>XYZMジオメトリではZM修飾子が削除されます。</p><p>OpenGIS: POINT ZM (1 2 3 4)</p><p>EWKB/EWKT: POINT(1 2 3 4)</p></li></ul></div><p>こうすることで、EWKB/EWKTは次元を過度に指定することや、次に示すようなISOが認める潜在的エラーの種別全体を回避しています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT ZM (1 1)</p></li><li class="listitem"><p>POINT ZM (1 1 1)</p></li><li class="listitem"><p>POINT (1 1 1 1)</p></li></ul></div><div class="caution"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/caution.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>PostGIS拡張書式は現在のところOGC書式のスーパーセットとなっています (全ての妥当なWKB/WKTは妥当なEWKB/EWKTです)。しかし、特にもしOGCがPostGIS拡張と矛盾する新しい書式を出すことがあるなら、これは将来変更されるかも知れません。ゆえにこの機能に頼るべきではありません。</p></td></tr></table></div><p>拡張された空間オブジェクトのテキスト表現 (EWKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT(0 0 0) -- XYZ</p></li><li class="listitem"><p>SRID=32632;POINT(0 0) -- SRID付きXY</p></li><li class="listitem"><p>POINTM(0 0 0) -- XYM</p></li><li class="listitem"><p>POINT(0 0 0 0) -- XYZM</p></li><li class="listitem"><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID付きXYM</p></li><li class="listitem"><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))</p></li><li class="listitem"><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )</p></li><li class="listitem"><p>MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )</p></li><li class="listitem"><p>POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</p></li><li class="listitem"><p>TRIANGLE ((0 0, 0 9, 9 0, 0 0))</p></li><li class="listitem"><p>TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</p></li></ul></div><p>これらの書式の変換は次のインタフェースを用いて実現できます。</p><pre class="programlisting">バイト配列 EWKB = ST_AsEWKB(geometry);
テキスト EWKT = ST_AsEWKT(geometry);
ジオメトリ = ST_GeomFromEWKB(bytea EWKB);
ジオメトリ = ST_GeomFromEWKT(text EWKT);</pre><p>たとえば、PostGISの空間オブジェクトを作成し挿入する妥当なINSERTステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO geotable ( the_geom, the_name )
  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre><p>PostgreSQLの「標準的な形式」は単純なクエリ (全く関数呼び出しが無い)で得る表現であり、単純なINSERT, UPDATE, COPYで受け付けられることが保障されるものです。PostGISの"geometory"型の場合は次の通りです。 </p><pre class="programlisting">- 出力
  - バイナリ: EWKB
        ascii: HEXEWKB (EWKBのHEX表現)
- 入力
  - バイナリ: EWKB
        ascii: HEXEWKB|EWKT </pre><p>たとえば、次のステートメントは、標準的なASCII文字列による入出力の処理でEWKTを読み、HEXEWKBを返すものです。</p><pre class="programlisting">=# SELECT 'SRID=4;POINT(0 0)'::geometry;

geometry
----------------------------------------------------
01010000200400000000000000000000000000000000000000
(1 row)</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="SQL_MM_Part3"></a>4.1.1.3. SQL-MM第3部</h4></div></div></div><p>SQLマルチメディア・アプリケーション空間仕様は、円弧補完曲線を定義したSQL仕様の拡張です。</p><p>SQL-MMの定義では、3DM、3DZと4Dの座標を含みますが、SRID情報の埋め込みはできません。</p><p>Well-Known Text拡張はまだ完全にはサポートされていません。単純な曲線ジオメトリの例を次に示します。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>CIRCULARSTRING(0 0, 1 1, 1 0)</p><p>CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)</p><p>CIRCULARSTRINGは基本的な曲線型で、線型のLINESTRINGに似ています。一つの辺で、始点、終点 (一つめと三つめ)と弧上の任意の点、の3点が必要です。例外として、始点と終点が同じとなる閉曲線があります。閉曲線では二つ目の点が弧の中心、すなわち円の反対側にならなければなりません。弧の連結では、LINESTRINGと同じように、前の弧の最後の点が次の弧の最初の点となります。よって、妥当なCIRCULARSTRINGは1以上の奇数になります。</p></li><li class="listitem"><p>COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</p><p>複合曲線は、曲線 (円弧)セグメントと線型セグメントの両方を持つ、単一の連続した曲線です。 よって、要素が的確である必要があることに加え、各要素 (最終要素は除く)の終点は次の要素の始点と同じになる必要があります。</p></li><li class="listitem"><p>CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))</p><p>曲線ポリゴンの中に複合ポリゴンがある例は次の通りです。 CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) ) </p><p>CURVEPOLYGONは外環と0以上の内環とを持つ点でPOLYGONと似ています。 異なる点は、環に曲線ストリング、線型ストリング、複合ストリングのいずれも取れる点です。</p><p>PostGIS 1.4から、PostGISで曲線ポリゴンで複合曲線をサポートするようになりました。</p></li><li class="listitem"><p>MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))</p><p>MULTICURVEは曲線のコレクションで、線型ストリング、曲線ストリング、複合ストリングを取れます。</p></li><li class="listitem"><p>MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))</p><p>サーフェスのコレクションです。(線型)ポリゴンか曲線ポリゴンを取れます。</p></li></ul></div><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>SQL-MM実装での全ての浮動小数点数の比較では、所定の丸め誤差があります。現在は1E-8です。</p></td></tr></table></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="PostGIS_Geography"></a>4.1.2. PostGISジオグラフィ型</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#Geography_Basics">4.1.2.1. ジオグラフィ基礎</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#PostGIS_GeographyVSGeometry">4.1.2.2. ジオグラフィ型をジオメトリ型にして使用すべき時</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#PostGIS_Geography_AdvancedFAQ">4.1.2.3. ジオグラフィに関する高度なよくある質問</a></span></dt></dl></div><p>ジオグラフィ型は、「地理」座標 (しばしば「測地」座標、"lat/lon"、"lon/lat"、緯度経度, 経度緯度などとも呼ばれます)上で表現された空間フィーチャーのネイティブサポートするためのものです。地理座標は角度の単位 (度)で表現される球面座標です。 </p><p>PostGISジオメトリ型の基礎は平面です。平面上の二点間の最短コースは直線になります。よって、ジオメトリ上の計算 (面積、距離、長さ、インタセクション等)は、デカルト座標と線型ベクトルを使用することができます。</p><p>PostGISのジオグラフィ型の基礎は球面です。球面上での二点間の最短距離は大圏の弧です。よって、ジオグラフィ上の計算 (面積、距離、長さ、インタセクション等)は、球面上で計算しなければならず、複雑な計算が必要となります。より正確な計測のためには、世界の実際の回転楕円体の形を考慮に入れなければならず、非常に複雑です。</p><p>基礎となる数学が大変に複雑なので、ジオグラフィ型用に定義された関数は、ジオメトリ型よりも少ないです。時間とともに、新しいアルゴリズムが追加されて、ジオグラフィ型の能力は拡大していくでしょう。</p><p><code class="varname">geography</code>と呼ばれるデータ型を使用します。GEOS関数は<code class="varname">geography</code>型に対応していません。回避策として、ジオメトリとジオグラフィの型変換を行うことができます。</p><p>PostGIS 2.2より前は、ジオグラフィ型はWGS84経度緯度 (SRID:4326)だけに対応していました。PostGIS 2.2以降は、<code class="varname">spatial_ref_sys</code>で定義されている経度緯度ベースの空間参照系の全てが使えます。<a class="ulink" href="http://www.bostongis.com/blog/index.php?/archives/266-geography-type-is-not-limited-to-earth.html" target="_top">geography type is not limited to earth</a>の記述にある通り、独自の回転楕円体の空間参照系を追加することもできます。</p><p>どの空間参照系を使用しても、計測関数 (<a class="xref" href="ST_Distance.html" title="ST_Distance">ST_Distance</a>, <a class="xref" href="ST_Length.html" title="ST_Length">ST_Length</a>, <a class="xref" href="ST_Perimeter.html" title="ST_Perimeter">ST_Perimeter</a>, <a class="xref" href="ST_Area.html" title="ST_Area">ST_Area</a>)の返り値の単位と、<a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a>の入力の単位はメートルです。</p><p>ジオグラフィ型はPostgreSQLのtypmod定義書式を使います。ジオグラフィカラムを持つテーブルに1ステップで追加できます。標準OGC書式は曲線を除いてサポートします。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Geography_Basics"></a>4.1.2.1. ジオグラフィ基礎</h4></div></div></div><p>ジオグラフィ型はシンプルフィーチャーの最も簡単なもののみサポートします。標準的なジオメトリ型データで、SRIDが4326の場合は、ジオグラフィに自動でキャストされます。またデータ挿入においてEWKTとEWKBの取り決めを使うこともできます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POINT: SRID指定なしでの2次元ポイントジオグラフィのテーブル生成は次の通りです。デフォルトは4326 WGS84経度緯度となります。</p><pre class="programlisting">CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );</pre><p>POINT: NAD83経度緯度での2次元ポイントジオグラフィのテーブル生成は次の通りです。</p><pre class="programlisting">CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog geography(POINT,4269) );</pre><p>Z値を持ち、明示的にSRIDを指定したポイントのテーブル生成は次の通りです。</p><pre class="programlisting">CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog geography(POINTZ,4326) );</pre></li><li class="listitem"><p>LINESTRING</p><pre class="programlisting">CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );</pre></li><li class="listitem"><p>POLYGON</p><pre class="programlisting">-- ポリゴン NAD 1927経度緯度
CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog geography(POLYGON,4267) );</pre></li><li class="listitem"><p>MULTIPOINT</p></li><li class="listitem"><p>MULTILINESTRING</p></li><li class="listitem"><p>MULTIPOLYGON</p></li><li class="listitem"><p>GEOMETRYCOLLECTION</p></li></ul></div><p>ジオグラフィ型のフィールドは<code class="varname">geography_columns</code>システムビューに登録されます。</p><p>"geography_columns"ビューをチェックして、テーブルが一覧にあるか見て下さい。</p><p>CREATE TABLEの文法でジオグラフィカラムを持つテーブルを新規に生成できます。</p><p>
</p><pre class="programlisting">CREATE TABLE global_points (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    location GEOGRAPHY(POINT,4326)
  );</pre><p>
		</p><p>locationカラムはジオグラフィ型で、二つの任意修飾子に対応していることにご注意ください。一つは、そのカラムで使用できる形状と次元を限定する型修飾子です。もう一つは、座標参照IDを特定の数に限定するSRID修飾子です。</p><p>型修飾子として受け付ける値は、POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGONです。型修飾子は、Z, M, ZMの後置子を付けることで次元制限にも対応します。たとえば、'LINESTRINGM'という型修飾子で、三つ目の次元をMとする3次元のラインストリングのみ受け付けることになります。同じように'POINTZM'で、4次元データを期待します。</p><p>SRIDを指定していない場合には、SRIDは4326 WGS84経度緯度が使われ、全ての計算はWGS 84を使って行われます。</p><p>テーブルを作ったら、次のようにしてGEOGRAPHY_COLUMNSを見ることができます。</p><pre class="programlisting">-- メタデータビューの中身を見る
SELECT * FROM geography_columns;</pre><p>ジオメトリカラムを使うのと同じようにテーブルへのデータの挿入ができます。</p><pre class="programlisting">-- testテーブルにデータを追加する
INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;POINT(-110 30)');
INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;POINT(-109 29)');
INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;POINT(0 49)');</pre><p>ジオメトリと同じ操作でインデックスを作成します。PostGISは、カラム型がジオグラフィであるかを見て、ジオメトリで使われる平面用インデックスの代わりに球面ベースのインデックスを作成します。</p><pre class="programlisting">-- testテーブルに球面インデックスを作成
  CREATE INDEX global_points_gix ON global_points USING GIST ( location );</pre><p>
</p><p>クエリと計測関数はメートル単位となります。そのため距離パラメータはメートル (面積の場合は平方メートル)単位となります。</p><pre class="programlisting">-- 距離クエリの表示。ロンドンは1000km範囲外です
  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;POINT(-110 29)'::geography, 1000000);</pre><p>
</p><p>ジオグラフィの威力については、シアトルからロンドンまで (LINESTRING(-122.33 47.606, 0.0 51.5))の飛行機がレイキャビク (POINT(-21.96 64.15))に最も近くなるときの距離を求めてみると分かります。</p><pre class="programlisting">-- ジオグラフィを使った距離計算 (122.2km)
  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)'::geography);</pre><p>
</p><pre class="programlisting">-- ジオメトリを使った計算 (13.3 "度")
  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)'::geometry);</pre><p>
</p><p>異なる経度緯度座標系を試します。<code class="varname">spatial_ref_sys</code>テーブルで挙げられている経度緯度の空間参照系なら全て可能です。</p><p>	</p><pre class="programlisting">-- NAD83経度緯度
SELECT 'SRID=4269;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AD1000000000000000C05EC00000000000004140
(1 row)</pre><p>

</p><pre class="programlisting">-- NAD27経度緯度
SELECT 'SRID=4267;POINT(-123 34)'::geography;

                    geography
----------------------------------------------------
 0101000020AB1000000000000000C05EC00000000000004140
(1 row)</pre><p>

</p><pre class="programlisting">-- メートル単位のNAD83 UTM、メートル単位の投影法ですのでエラーが出ます
SELECT 'SRID=26910;POINT(-123 34)'::geography;

ERROR:  Only lon/lat coordinate systems are supported in geography.
LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;</pre><p>ジオグラフィ型は、レイキャビクとシアトル-ロンドン間の飛行機の大圏コースとの間の、球面上での本当に最も近い距離を計算します。</p><p><a class="ulink" href="http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR" target="_top">大圏コースマップ</a> ジオメトリ型は、平面の世界地図上にプロットされたレイキャビクとシアトル-ロンドン間の直線とのデカルト距離という意味のない値を出します。結果の名目上の単位は「度」ですが、点間の本当の角度差にあっていませんので、「度」と言うこと自体不正確です。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="PostGIS_GeographyVSGeometry"></a>4.1.2.2. ジオグラフィ型をジオメトリ型にして使用すべき時</h4></div></div></div><p>ジオグラフィ型によって、経度緯度座標でデータを格納できるようになりましたが、ジオグラフィで定義されている関数が、ジオメトリより少ないのと、実行にCPU時間がかかる、というところが犠牲になっています。</p><p>選択した型が、期待する領域から出ないことを、ジオメトリ型にして使用する条件とすべきです。使用するデータは地球全体か、大陸か、州か、自治体か? </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>データが小さいエリア内におさまるなら、適切な投影を選択してジオメトリを使うのが、効率面でも機能面でも最も良い方法です。</p></li><li class="listitem"><p>データが地球全体か大陸なら、ジオグラフィで投影法の細かい問題を気にせずにシステムを構築できるでしょう。経度/緯度のデータを保存して、ジオグラフィで定義された関数使います。</p></li><li class="listitem"><p>投影法を理解していなくて、学習したくもなくて、かつ、ジオグラフィで使える関数が限られていることを受け入れるのなら、ジオグラフィを使った方が簡単です。単純にデータを経度/緯度でロードして、そこから進めて下さい。</p></li></ul></div><p>ジオグラフィとジオメトリ間のサポート状況の比較については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_TypeFunctionMatrix" title="9.11. PostGIS関数対応マトリクス">「PostGIS関数対応マトリクス」</a>をご覧下さい。ジオグラフィ関数の簡潔なリストと説明については<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_GeographyFunctions" title="9.4. PostGISジオグラフィ対応関数">「PostGISジオグラフィ対応関数」</a>をご覧下さい。 </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="PostGIS_Geography_AdvancedFAQ"></a>4.1.2.3. ジオグラフィに関する高度なよくある質問</h4></div></div></div><div class="qandaset"><a name="idp52840696"></a><dl><dt>4.1.2.3.1. <a href="postgis_usage.html#idp52840952">球または回転楕円体のどちらで計算するのでしょうか?</a></dt><dt>4.1.2.3.2. <a href="postgis_usage.html#idp52843256">日付変更線や極に関してはどうなっていますか?</a></dt><dt>4.1.2.3.3. <a href="postgis_usage.html#idp52845176">処理できる最も長い弧はどうなりますか?</a></dt><dt>4.1.2.3.4. <a href="postgis_usage.html#idp52847096">なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idp52840952"></a><a name="idp52841208"></a><p><b>4.1.2.3.1.</b></p></td><td align="left" valign="top"><p>球または回転楕円体のどちらで計算するのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>デフォルトでは、全ての距離と面積の計算は回転楕円体で行います。局所的なエリアでの計算結果と良好な投影を施した平面での結果と比較して下さい。大きなエリアの場合は、回転楕円体計算は、投影平面上でのどの計算よりも精度が高くなります。 </p><p>全てのジオグラフィ関数には、最後の真偽パラメータを'FALSE'にすると球面を使った計算を行うというオプションがあります。これは、特にジオメトリが非常に単純である場合に計算を速くするためのものです。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52843256"></a><a name="idp52843512"></a><p><b>4.1.2.3.2.</b></p></td><td align="left" valign="top"><p>日付変更線や極に関してはどうなっていますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>全ての計算に日付変更線や極の概念がありません。座標は球 (経度/緯度)であるので、日付変更線とクロスする形状は、計算の観点からは、他のものと変わりありません。 </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52845176"></a><a name="idp52845432"></a><p><b>4.1.2.3.3.</b></p></td><td align="left" valign="top"><p>処理できる最も長い弧はどうなりますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>大圏の弧を2点の「補完線」として使用しています。任意の2点は、実際には2方向につながっていて、どちらの方向に行くかに依存します。PostGISの全てのコードは、大圏コースの2コースのうち*短い*方でつながっていると仮定しています。結果として、180度以上の弧を持つ形状は正しくモデル化されません。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp52847096"></a><a name="idp52847352"></a><p><b>4.1.2.3.4.</b></p></td><td align="left" valign="top"><p>なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ポリゴンがとんでもなく大きいからです。二つの理由から、大きなエリアは悪いです。一つは、バウンダリボックスが大きいため、どのようなクエリを走らせても、インデックスがフィーチャーを引っ張ってくる傾向にあるためです。もう一つは、頂点数が巨大で、テスト (距離、包含)関数では、少なくとも1回、通常はN (Nは、もう一方のフィーチャーの頂点数)回、頂点を横断しなければならないためです。 </p><p>ジオメトリでは、大きなポリゴンを持っているけれども小さな範囲のクエリを実行する時、ジオメトリデータ情報を小片に「非正規化」します。これにより、インデックスが効果的にオブジェクトの一部を問い合わせるようになり、またクエリが常にオブジェクト全体を引っ張りこむようなことがないようになります。<a class="xref" href="ST_Subdivide.html" title="ST_Subdivide">ST_Subdivide</a>を参照して下さい。ヨーロッパ全体を一つのポリゴンに*格納できる*からといって、*そうすべき*だというわけではありません。</p></td></tr></tbody></table></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp52850168"></a>4.1.3. 空間メタデータテーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#spatial_ref_sys">4.1.3.1. SPATIAL_REF_SYSテーブルと空間参照系</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#geometry_columns">4.1.3.2. GEOMETRY_COLUMNSビュー</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#Create_Spatial_Table">4.1.3.3. 空間テーブルを作る</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#Manual_Register_Spatial_Column">4.1.3.4. 手動でジオメトリカラムをgeometry_columnsに登録する</a></span></dt></dl></div><p>OpenGIS "Simple Features Specification for SQL"では、ジオメトリと座標系のテーブル構造を記述するメタデータテーブルが定義されています。このメタデータの一貫性を保つために、空間カラムの生成と削除といった操作が、OpenGISが定義する特別な手続きを通して実行されます。</p><p>OpenGISメタデータテーブルには<code class="varname">SPATIAL_REF_SYS</code>と<code class="varname">GEOMETRY_COLUMNS</code>の二つがあります。<code class="varname">SPATIAL_REF_SYS</code>テーブルは空間データベースで用いられる座標系の、数字によるIDと文字による説明を持っています。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="spatial_ref_sys"></a>4.1.3.1. SPATIAL_REF_SYSテーブルと空間参照系</h4></div></div></div><p>PostGISで使用される<code class="varname">SPATIAL_REF_SYS</code>は、OGC準拠のデータベーステーブルで3000件の空間参照系 (<a class="ulink" href="https://en.wikipedia.org/wiki/Spatial_reference_system" target="_top">spatial reference systems</a>)と、空間参照系間を変換 (投影変換)するのに必要な詳細の一覧を持っています。</p><p>PostGISの<code class="varname">SPATIAL_REF_SYS</code>テーブルには、<a class="ulink" href="https://proj.org" target="_top">PROJ</a>投影ライブラリで処理される最も一般的な空間参照系の定義が3000件以上存在します。しかし、このテーブルに含まれていない多くの座標系があります。PROJに精通している場合には、独自の空間参照系を定義できます。ほとんどの空間参照系は地域的なものであり、範囲外で使用する場合は意味を持たない点に注意してください。</p><p>PostGISのコアセットに入っていない空間参照系を探すための素晴らしい資料が<a class="ulink" href="http://spatialreference.org/" target="_top">http://spatialreference.org/</a>にあります。</p><p>一般的に使用される空間参照系には<a class="ulink" href="http://spatialreference.org/ref/epsg/4326/" target="_top">4326 - WGS 84経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/4269/" target="_top">4269 - NAD 83 経度緯度</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/3395/" target="_top">3395 - WGS 84 メルカトル</a>、<a class="ulink" href="http://spatialreference.org/ref/epsg/2163/" target="_top">2163 - 米国ナショナルアトラス正積図法</a>、60個のWGS84 UTMゾーンがあります。UTMゾーンは計測に最適ですが、6度 (訳注: 経度)の領域のみをカバーします (対象地域に使用するUTMゾーンを決定するには<a class="ulink" href="http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance" target="_top">utmzone PostGIS plpgsql helper function</a>を参照してください)。 </p><p>米国の州では、州平面空間参照系 (メートルまたはフィート単位)を使用します。この空間参照系は州ごとに一つか二つ存在します。ほとんどのメートル単位のものはコアのセットに存在しますが、フィート単位の多数のものやESRIが作成したものは<a class="ulink" href="http://spatialreference.org" target="_top">spatialreference.org</a>からロードする必要があります。 </p><p>地球外の座標系でさえも定義することができます。たとえば<a class="ulink" href="http://spatialreference.org/ref/iau2000/mars-2000/" target="_top">Mars 2000</a>です。この火星の座標系は非平面 (回転楕円体の度)ですが、<code class="varname">geography</code>型で、度でなくメートル単位で長さや近接測定値を取得することができます。</p><p><code class="varname">SPATIAL_REF_SYS</code>テーブル定義は次の通りです。</p><pre class="programlisting">CREATE TABLE spatial_ref_sys (
  srid       INTEGER NOT NULL PRIMARY KEY,
  auth_name  VARCHAR(256),
  auth_srid  INTEGER,
  srtext     VARCHAR(2048),
  proj4text  VARCHAR(2048)
)</pre><p>カラムは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">SRID</span></dt><dd><p>データベース内の<a class="ulink" href="http://en.wikipedia.org/wiki/SRID" target="_top">Spatial Reference System</a> (SRS, 空間参照系)で一意に識別される整数コードです。</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>その参照系の引用元である標準や標準団体の名前です。たとえば「EPSG」は妥当な<code class="varname">AUTH_NAME</code>です。</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p><code class="varname">AUTH_NAME</code>で引用される団体によって定義された空間参照系のIDです。EPSGの場合、EPSG投影コードが入ります。</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>空間参照系のWell-Knownテキスト表現です。たとえば、WKT SRSの表現は、次のようになります。</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
        DATUM["North_American_Datum_1983",
          SPHEROID["GRS 1980",6378137,298.257222101]
        ],
        PRIMEM["Greenwich",0],
        UNIT["degree",0.0174532925199433]
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0],
  UNIT["metre",1]
]</pre><p>EPSG投影コードと対応するWKT表現の一覧については、<a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a>をご覧下さい。SRSのWKTについての一般的な議論については、OpenGISの<a class="ulink" href="http://www.opengeospatial.org/standards" target="_top">http://www.opengeospatial.org/standards</a>にある「座標変換サービス実装仕様」をご覧下さい。欧州石油調査グループ(European Petroleum Survey Group, EPSG)とEPSG空間参照系のデータベースに関する情報は、<a class="ulink" href="http://www.epsg.org/" target="_top">http://www.epsg.org/</a>をご覧下さい。</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGISは座標変換機能を提供するためにProj4ライブラリを用いています。 <code class="varname">PROJ4TEXT</code>カラムには、特定のSRIDを示すProj4座標定義文字列が入ります。たとえば次のようになります。</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>詳細情報については<a class="ulink" href="https://proj.org/" target="_top">PROJウェブサイト</a>をご覧下さい。<code class="filename">spatial_ref_sys.sql</code>ファイルには、全てのEPSG投影について、<code class="varname">SRTEXT</code>と<code class="varname">PROJ4TEXT</code>の定義があります。</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="geometry_columns"></a>4.1.3.2. GEOMETRY_COLUMNSビュー</h4></div></div></div><p><code class="varname">GEOMETRY_COLUMNS</code>は、データベースのシステムカタログから読み取るビューです。構造は次の通りです。</p><pre class="programlisting">\d geometry_columns</pre><pre class="screen">View "public.geometry_columns"
      Column       |          Type          | Modifiers
-------------------+------------------------+-----------
 f_table_catalog   | character varying(256) |
 f_table_schema    | character varying(256) |
 f_table_name      | character varying(256) |
 f_geometry_column | character varying(256) |
 coord_dimension   | integer                |
 srid              | integer                |
 type              | character varying(30)  |</pre><p>カラムは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>ジオメトリカラムを持つフィーチャーテーブルの完全修飾名。"catalog"および"schema"の語はOracle風であることに注意して下さい。"catalog"に類似するものはPostgreSQLになく、このカラムは空白にされます。"schema"についてはPostgreSQLスキーマ名が使われています (<code class="varname">public</code>がデフォルトです)。</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>フィーチャーテーブル内のジオメトリカラムの名前。</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>そのカラムの空間の次元 (2, 3 または 4)。</p></dd><dt><span class="term">SRID</span></dt><dd><p>このテーブルの座標ジオメトリのために使われる空間参照系のID。<code class="varname">SPATIAL_REF_SYS</code>への外部キーになっています。</p></dd><dt><span class="term">TYPE</span></dt><dd><p>空間オブジェクトの型。空間カラムを単一型に制限するには、POINT、LINESTRING、POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTIONのうちのいずれかを、また、XYMで使う場合には、LINESTRINGM、POLYGONM、MULTIPOINTM、MULTILINESTRINGM、MULTIPOLYGONM、GEOMETRYCOLLECTIONMのうちのいずれかを使います。複数の型が混合するコレクションの場合は"GEOMETRY"を型とすることができます。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>この属性は (おそらく)OpenGIS仕様に入っていませんが、型の同一性を保証するために必要です。</p></td></tr></table></div></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Create_Spatial_Table"></a>4.1.3.3. 空間テーブルを作る</h4></div></div></div><p>空間データを持つテーブルの生成は、1段階でできます。2次元ラインストリングでWGS84経度緯度のジオメトリカラムを持つroadsテーブルの生成の例を次に示します。</p><pre class="programlisting">CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom geometry(LINESTRING,4326) );</pre><p>次の、3次元ラインストリングを追加する例で示す通り、標準的なALTER TABLEコマンドを使ってカラムを追加できます。</p><pre class="programlisting">ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="Manual_Register_Spatial_Column"></a>4.1.3.4. 手動でジオメトリカラムをgeometry_columnsに登録する</h4></div></div></div><p>これが必要になる事例に、SQLビューとバルクインサートの二つがあります。バルクインサートの場合には、カラムに制約を与えるか、ALTER TABLEを実行することで、geometry_columnsテーブル内の登録を訂正することができます。ビューの場合には、CAST演算を使用します。カラムが型修飾子に基づく場合には、生成処理によって正しく登録されるので、何も行う必要がありません。ジオメトリに適用する空間関数を持たないビューも、基礎となるテーブルのジオメトリカラムと同じように登録されます。</p><pre class="programlisting">-- 次のようなビューがあるとします
CREATE VIEW public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395) As geom, f_name
        FROM public.mytable;

-- 正しく登録するには、
-- ジオメトリをキャストします。
--
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As geom, f_name
        FROM public.mytable;

-- ジオメトリタイプが確実に2次元ポリゴンだと知っているなら
-- 次のようにできます。
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name
        FROM public.mytable;</pre><pre class="programlisting">-- 次のように、バルクインサートで派生テーブルを生成したとしましょう
SELECT poi.gid, poi.geom, citybounds.city_name
INTO myschema.my_special_pois
FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);

-- 新しいテーブルに2次元インデックスを作ります
CREATE INDEX idx_myschema_myspecialpois_geom_gist
  ON myschema.my_special_pois USING gist(geom);

-- ポイントが3次元ポイントであったり、XYMポイントであったりした場合には、
-- 次のように、2次元インデックスでなくN次元インデックスを作ることになるかも
-- 知れません。
CREATE INDEX my_special_pois_geom_gist_nd
        ON my_special_pois USING gist(geom gist_geometry_ops_nd);

-- 新しいテーブルのジオメトリカラムをgeometry_columnsに手動登録するには、
-- 次のようにします。
-- カラムを型修飾子ベースにするために、基礎となるテーブル構造も変更することに
-- 注意して下さい。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);

-- PostGIS 2.0を使っていて、何らかの理由で古い制約をもとにした定義を行う
-- (派生テーブルが同じタイプやSRIDを持たないといった場合)ことが必要な場合には、
-- 新しい任意変数use_typemodをfalseにします。
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false); </pre><p>古い制約を基にした手法は現在も対応していますが、制約を基にしたジオメトリカラムで直接的にビューで使われている場合は、型修飾子のようには正しくgeometry_columnsに登録されません。次の例では、型修飾子を使ったカラム定義と、制約に基づくカラムの定義とを行っています。</p><pre class="programlisting">CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom geometry(POINT,4326));
SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);</pre><p>psqlで次を実行します。</p><pre class="programlisting">\d pois_ny;</pre><p>型修飾子と制約に基づくのとでは異なった定義になっているのが見えます。</p><pre class="screen">Table "public.pois_ny"
  Column   |         Type          |                       Modifiers

-----------+-----------------------+------------------------------------------------------
 gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)
 poi_name  | text                  |
 cat       | character varying(20) |
 geom      | geometry(Point,4326)  |
 geom_2160 | geometry              |
Indexes:
    "pois_ny_pkey" PRIMARY KEY, btree (gid)
Check constraints:
    "enforce_dims_geom_2160" CHECK (st_ndims(geom_2160) = 2)
    "enforce_geotype_geom_2160" CHECK (geometrytype(geom_2160) = 'POINT'::text
        OR geom_2160 IS NULL)
    "enforce_srid_geom_2160" CHECK (st_srid(geom_2160) = 2160)</pre><p>geometry_columnsでは、両方とも正しく登録されています。</p><pre class="programlisting">SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'pois_ny';</pre><pre class="screen">f_table_name | f_geometry_column | srid | type
-------------+-------------------+------+-------
pois_ny      | geom              | 4326 | POINT
pois_ny      | geom_2160         | 2160 | POINT</pre><p>しかし、次のようにビューを作ろうとします。</p><pre class="programlisting">CREATE VIEW vw_pois_ny_parks AS
SELECT *
  FROM pois_ny
  WHERE cat='park';

SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><p>型修飾子によるgeomのビューカラムは正しく登録されますが、制約に基づくものは正しく登録されません。</p><pre class="screen">f_table_name   | f_geometry_column | srid |   type
------------------+-------------------+------+----------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY</pre><p>これは、将来的にPostGISの版で変更されるかもしれませんが、今のところは、制約に基づくビューカラムを正しく登録させるには、次のようにします。</p><pre class="programlisting">DROP VIEW vw_pois_ny_parks;
CREATE VIEW vw_pois_ny_parks AS
SELECT gid, poi_name, cat,
  geom,
  geom_2160::geometry(POINT,2160) As geom_2160
  FROM pois_ny
  WHERE cat = 'park';
SELECT f_table_name, f_geometry_column, srid, type
        FROM geometry_columns
        WHERE f_table_name = 'vw_pois_ny_parks';</pre><pre class="screen">f_table_name   | f_geometry_column | srid | type
------------------+-------------------+------+-------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         | 2160 | POINT</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="OGC_Validity"></a>4.1.4. ジオメトリ検証</h3></div></div></div><p>PostGISはOpen Geospatial Consortium (OGC)のOpenGIS仕様に準拠しています。多くのPostGISメソッドは、操作対象のジオメトリが単純かつ妥当であることが求められます (正確に言うとそう仮定します)。たとえば、ポリゴンの外に穴があるようなものの面積を計算したり、単純でない境界線を持つポリゴンを作ったりするのは、意味がありません。</p><p>OGS仕様に沿うと、<span class="emphasis"><em>単純な</em></span>ジオメトリとは、自己インタセクトや自己接触のような、異常な幾何点を持たないことです。主に0次元または1次元のジオメトリ (<code class="varname">[MULTI]POINT, [MULTI]LINESTRING</code>))に適用します。 他方、ジオメトリの妥当性は、主に2次元ジオメトリ (<code class="varname">[MULTI]POLYGON</code>)に適用し、妥当なポリゴンを特徴づける位置指定子の集合を定義します。個々のジオメトリクラスには、単純性と妥当性をさらに詳細に述べる特定の条件があります。</p><p><code class="varname">POINT</code>は0次元ジオメトリオブジェクトとして常に<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">MULTIPOINT</code>は、二つの座標値 (<code class="varname">POINT</code>)が同じでないなら<span class="emphasis"><em>単純</em></span>です。</p><p><code class="varname">LINESTRING</code>は、2度同じ<code class="varname">POINT</code>を通らない (終点は除きます。この場合は線型環と呼ばれ、さらに言うと閉じていると思われます)なら<span class="emphasis"><em>単純</em></span>です。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple01.png"><div class="caption"><p><span class="bold"><strong>(a)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple02.png"><div class="caption"><p><span class="bold"><strong>(b)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple03.png"><div class="caption"><p><span class="bold"><strong>(c)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple04.png"><div class="caption"><p><span class="bold"><strong>(d)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(a)</strong></span>と<span class="bold"><strong>(c)</strong></span>は単純な<code class="varname">LINESTRING</code>です。<span class="bold"><strong>(b)</strong></span>と<span class="bold"><strong>(d)</strong></span>は単純ではありません。</p></td></tr></tbody></table></div><p><code class="varname">MULTILINESTRING</code>は、 全ての要素が単純で、かつ任意の2要素のインタセクトが要素の境界である<code class="varname">POINT</code>でだけ発生する場合に限って<span class="emphasis"><em>単純</em></span>です。 </p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple05.png"><div class="caption"><p><span class="bold"><strong>(e)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple06.png"><div class="caption"><p><span class="bold"><strong>(f)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_issimple07.png"><div class="caption"><p><span class="bold"><strong>(g)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(e)</strong></span>と<span class="bold"><strong>(f)</strong></span>は単純な<code class="varname">MULTILINESTRING</code>です。<span class="bold"><strong>(g)</strong></span>は単純ではありません。</p></td></tr></tbody></table></div><p>定義から<code class="varname">POLYGON</code>は常に単純です。バウンダリ内の環 (外環と内環からなる)のうち二つがクロスしていないなら<span class="emphasis"><em>妥当</em></span>です。<code class="varname">POLYGON</code>の境界は、<code class="varname">POINT</code>とインタセクトするかも知れませんが、接点にしかなりません (すなわち線上にない)。<code class="varname">POLYGON</code>はカットラインまたはスパイクを持たなくても良く、内環は外環の中に完全に含まれていなければなりません。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid01.png"><div class="caption"><p><span class="bold"><strong>(h)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid02.png"><div class="caption"><p><span class="bold"><strong>(i)</strong></span></p></div></div></div></td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid03.png"><div class="caption"><p><span class="bold"><strong>(j)</strong></span></p></div></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid04.png"><div class="caption"><p><span class="bold"><strong>(k)</strong></span></p></div></div></div></td><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid05.png"><div class="caption"><p><span class="bold"><strong>(l)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid06.png"><div class="caption"><p><span class="bold"><strong>(m)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(h)</strong></span>と<span class="bold"><strong>(i)</strong></span>は妥当な<code class="varname">POLYGON</code>です。<span class="bold"><strong>(jからm)</strong></span>は単一の<code class="varname">POLYGON</code>としては表現できませんが、<span class="bold"><strong>(j)</strong></span>と<span class="bold"><strong>(m)</strong></span>は妥当な<code class="varname">MULTIPOLYGON</code>として表現できます。 </p></td></tr></tbody></table></div><p><code class="varname">MULTIPOLYGON</code>は、全ての要素が妥当で、二つのポリゴン要素について内側がインタセクトしていない場合は<span class="emphasis"><em>妥当</em></span>です。ポリゴン要素の任意の二つの境界は接触してもよいですが、有限な数の<code class="varname">POINT</code>でなければなりません。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col><col></colgroup><tbody><tr><td style="border-right: 1px solid ; " align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid07.png"><div class="caption"><p><span class="bold"><strong>(n)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid08.png"><div class="caption"><p><span class="bold"><strong>(o)</strong></span></p></div></div></div></td><td style="" align="center"><div class="informalfigure"><div class="mediaobject"><img src="images/st_isvalid09.png"><div class="caption"><p><span class="bold"><strong>(p)</strong></span></p></div></div></div></td></tr></tbody></table><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p><span class="bold"><strong>(n)</strong></span>と<span class="bold"><strong>(o)</strong></span>は妥当でない<code class="varname">MULTIPOLYGON</code>です。<span class="bold"><strong>(p)</strong></span>は妥当です。</p></td></tr></tbody></table></div><p>GEOSライブラリを使って実装されている関数のほとんどは、ジオメトリがOpenGISシンプルフィーチャー仕様で定義されているように妥当であると仮定しています。ジオメトリが単純であるか、また妥当であるか、のチェックとして<a class="link" href="ST_IsSimple.html" title="ST_IsSimple">ST_IsSimple()</a>と<a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a>が使えます。</p><pre class="programlisting">-- 一般的に、線フィーチャーの妥当性のチェックは
-- 常にTRUEを返すので意味がありません
-- しかし、この例では、PostGISがOGCのIsValidの定義を拡張して
-- *一意な頂点*が2より少ないラインストリングについてFALSEを
-- 返すようにしています
gisdb=# SELECT
   ST_IsValid('LINESTRING(0 0, 1 1)'),
   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');

 st_isvalid | st_isvalid
------------+-----------
      t     |     f</pre><p>デフォルトでは、PostGISはジオメトリ入力に関するこの妥当性チェックを適用しません。複雑なジオメトリの妥当性のチェックはCPU時間を多く必要とするためです。データソースが信用できない場合は、手動でこのチェックを強制するための制約を付けることができます。</p><pre class="programlisting">ALTER TABLE mytable
  ADD CONSTRAINT geometry_valid_check
        CHECK (ST_IsValid(the_geom));</pre><p>妥当な入力ジオメトリでPostGIS関数を呼んだのに「GEOS Intersection()がエラーを投げました!」というようなエラーメッセージに遭遇したなら、PostGISまたは使用しているライブラリの中のエラーを発見しました。PostGIS開発者に連絡するべきです。PostGIS関数が妥当である入力ジオメトリから妥当でないジオメトリが返る場合も同じです。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>厳格にOGCジオメトリに準拠すると、Z値やM値を持てません。<a class="link" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid()</a>は高次を考慮に入れません。<a class="link" href="AddGeometryColumn.html" title="AddGeometryColumn">AddGeometryColumn()</a>を実行するとジオメトリの次元をチェックする制約が加わるので、そこで2を指定すれば十分です。</p></td></tr></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="loading-data"></a>4.1.5. 空間データのロード</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp53003512">4.1.5.1. SQLを使ってロードする</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#shp2pgsql_usage">4.1.5.2. シェープファイルローダを使う</a></span></dt></dl></div><p>空間テーブルを作成したら、これでGISデータをデータベースにアップロードする準備ができたことになります。現在、PostGIS/PostgreSQLデータベースにデータをロードするには、SQLステートメントを使う、またはシェープファイルのローダ/ダンパを使う、という二つの方法があります。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53003512"></a>4.1.5.1. SQLを使ってロードする</h4></div></div></div><p>空間データを文字表現 (WKTかWKB)に変換できたら、SQLを使うのがPostGISにデータを持たせる最も簡単です。SQLユーティリティの<code class="code">psql</code>を使用して、SQLの<code class="code">INSERT</code>ステートメントのテキストファイルをロードすると、データをPostGIS/PostgreSQLに一括読み込みできます。</p><p>データアップロードファイル (たとえば<code class="filename">roads.sql</code>)は次のようになるでしょう。</p><pre class="programlisting">BEGIN;
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');
COMMIT;</pre><p>SQLファイルのPostgreSQLへのロードは<code class="code">psql</code>を使います。次のようにします。</p><pre class="programlisting">psql -d [データベース名] -f roads.sql</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="shp2pgsql_usage"></a>4.1.5.2. シェープファイルローダを使う</h4></div></div></div><p><code class="filename">shp2pgsql</code>データローダは、ESRIシェープファイルをPostGIS/PostgreSQLデータベースに、ジオメトリまたはジオグラフィとして挿入するための適切なSQLに変換します。ローダには、次に示すコマンドラインフラグによって区別される、いくつかの操作モードがあります。 </p><p>グラフィカルユーザインタフェースを持つ<code class="filename">shp2pgsql-gui</code>もあります。コマンドラインローダのオプションのほとんどが使えます。これは、スクリプト化されていない1回限りのロードの場合や、PostGIS初心者がロードする場合に、簡単に使用できます。PgAdminIIIのプラグインとすることもできます。 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">(c|a|d|p) 相互に排他的なオプションです</span></dt><dd><p>
          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-c</span></dt><dd><p>新しいテーブルの作成とシェープファイルからのデータの読み込みを行います。<span class="emphasis"><em>これがデフォルトモードです</em></span>。 </p></dd><dt><span class="term">-a</span></dt><dd><p>シェープファイルからデータベーステーブルにデータを追加します。複数のファイルをロードするためにこのオプションを使う場合は、これらのファイルは同じ属性と同じデータ型を持つ必要があります。 </p></dd><dt><span class="term">-d</span></dt><dd><p>シェープファイルにあるデータを持つ新しいテーブルを作成する前にデータベーステーブルを削除します。 </p></dd><dt><span class="term">-p</span></dt><dd><p>テーブル作成のSQLコードを生成するだけで、実際のデータは追加しません。このモードは、テーブル作成とデータロードとを完全に分けたい場合に使用します。 </p></dd></dl></div><p>
        </p></dd><dt><span class="term">-?</span></dt><dd><p>ヘルプ画面を表示します。 </p></dd><dt><span class="term">-D</span></dt><dd><p>出力データにPostgreSQLのダンプ書式を用います。このモードは-a, -c, -dと組み合わせて利用します。デフォルトの"insert"によるSQL書式よりも、大変早くロードできます。大きなデータセットではこちらを使用して下さい。 </p></dd><dt><span class="term">-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;</span></dt><dd><p>指定したSRIDを持つジオメトリテーブルの生成や追加を行います。FROM_SRIDが与えられた場合には、入力シェープファイルに、これを使います 。この場合には、ジオメトリは変更先SRIDに投影変換します。 </p></dd><dt><span class="term">-k</span></dt><dd><p>識別子 (カラム、スキーマおよび属性)の大文字小文字を保持します。シェープファイルの属性は全て大文字であることに注意して下さい。 </p></dd><dt><span class="term">-i</span></dt><dd><p>全ての整数を標準の32ビット整数に強制します。DBFヘッダではそれが正当であったとしても、64ビットのbigintを生成しません。 </p></dd><dt><span class="term">-I</span></dt><dd><p>ジオメトリカラムにGiSTインデックスを生成します。 </p></dd><dt><span class="term">-m</span></dt><dd><p>-m <code class="filename">a_file_name</code>で、長いカラム名を10文字のDBFカラム名に対応付けるファイルを指定します。ファイルは、1以上の行を持ちます。各行は空白区切りで二つの名前を持ち、行頭行末に空白を入れません。例を次に示します。 </p><pre class="programlisting">COLUMNNAME DBFFIELD1
AVERYLONGCOLUMNNAME DBFFIELD2</pre><p>
        </p></dd><dt><span class="term">-S </span></dt><dd><p>マルチ系ジオメトリの替りに単一ジオメトリを生成します。全てのジオメトリが実際に単一である (たとえば単一の外環でなるMULTIPOLYGONや単一の頂点でなるMULTIPOINT)場合にのみ成功します。 </p></dd><dt><span class="term">-t &lt;次元&gt;</span></dt><dd><p>出力ジオメトリが特定の次元を持つよう強制します。次元は、2D, 3DZ, 3DM, 4Dの文字列を使います。 </p><p>入力の次元が出力より小さい場合には、出力では0が入ります。入力の次元が大きい場合には、外されます。 </p></dd><dt><span class="term">-w</span></dt><dd><p>出力書式をWKBでなくWKTにします。精度が低下して、座標変動が発生しうることに注意が必要です。 </p></dd><dt><span class="term">-e</span></dt><dd><p>トランザクションを使わずに、ステートメントごとに実行するようにします。エラーの元となる不良なジオメトリがいくつか含んでいる時に、大半の良好なデータのロードが可能にするものです。ダンプ書式ではトランザクションを常に使うので、-Dフラグを指定している場合には使えません。 </p></dd><dt><span class="term">-W &lt;エンコーディング&gt;</span></dt><dd><p>入力データ (dbfファイル)のエンコーディングを指定します。全てのdbfの属性は指定されたエンコーディングからUTF8に変換されます。SQL出力結果には <code class="code">SET CLIENT_ENCODING to UTF8</code>が含まれるようになり、バックエンドはUTF-8からデータベースが内部利用のために設定したエンコーディングに再変換できます。 </p></dd><dt><span class="term">-N &lt;方針&gt;</span></dt><dd><p>NULLジオメトリ操作方針(insert*=挿入, skip=スキップ, abort=強制終了)を選択します。 </p></dd><dt><span class="term">-n</span></dt><dd><p>DBFファイルのみインポートします。対応するシェープファイルを持っていない場合、 自動的にこのモードになり、DBFファイルのみロードします。 このフラグは、完全なシェープファイル群を持っていて、属性データだけが欲しくてジオメトリが欲しくない時のみ使用します。 </p></dd><dt><span class="term">-G</span></dt><dd><p>ジオメトリ型のかわりに、ジオグラフィ型で、WGS84経度緯度 (SRID=4326)を使用します (経度緯度データが必要です)。 </p></dd><dt><span class="term">-T &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのテーブル空間を指定します。 -Xパラメータが使われない場合には、インデックスはデフォルトのテーブル空間を使用します。PostgreSQL文書には、テーブル空間を用いるべき時に関する良い文書があります。 </p></dd><dt><span class="term">-X &lt;tablespace&gt;</span></dt><dd><p>新しいテーブルのインデックスで使われるテーブル空間を指定します。 主キーインデックスに適用され、-Iが合わせて使われている場合にはGiST空間インデックスにも適用されます。 </p></dd></dl></div><p>ローダを使って入力ファイルを生成してアップロードするセッション例は次の通りです。 </p><pre class="programlisting"># shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql
# psql -d roadsdb -f roads.sql</pre><p>変換とアップロードはUNIXのパイプを使うと一回で実行できます。 </p><pre class="programlisting"># shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="extracting-data"></a>4.1.6. 空間データの抽出</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp53067000">4.1.6.1. SQLを使ってデータを抽出する</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#pgsql2shp-usage">4.1.6.2. ダンパを使う</a></span></dt></dl></div><p>空間データはSQLかシェープファイルダンパを使うと抽出できます。SQLの節では空間テーブルで比較とクエリに使用できる関数を示します。 </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53067000"></a>4.1.6.1. SQLを使ってデータを抽出する</h4></div></div></div><p>データベース外へのデータ抽出の最も簡単な方法は、抽出するデータセットを定義し、<code class="code">SELECT</code>問い合わせを使って、結果カラムを解析可能なテキストファイルにダンプすることです。</p><pre class="programlisting">db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;

road_id | geom                                    | road_name
--------+-----------------------------------------+-----------
          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd
          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd
          3 | LINESTRING(192783 228138,192612 229814) | Paul St
          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
          7 | LINESTRING(218421 284121,224123 241231) | Chris Way
(6 rows)</pre><p>返されるレコードの数を減らすためにある種の制限が必要になる場合があります。属性ベースで制限をかける場合には、非空間テーブルで使うのと同じSQL文を使います。空間に制限をかけるには次の関数を使います。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ST_Intersects</span></dt><dd><p>この関数は、二つのジオメトリが空間を共有しているかどうかをテストします。</p></dd><dt><span class="term">=</span></dt><dd><p>この関数で、二つのジオメトリが幾何的に同一であるかを見ることができます。たとえば、'POLYGON((0 0,1 1,1 0,0 0))' は 'POLYGON((0 0,1 1,1 0,0 0))' と同じかを見ることができます (これは同じとなります)。 </p></dd></dl></div><p>次に、これらの演算子をクエリで使うことができます。SQLコマンドラインからジオメトリとボックスの指定を行うときは、明示的に文字列表現をジオメトリに変換しなければならないことに注意して下さい。たとえば、次のようになります。ただし312は架空の空間参照系番号で、ここでのデータに合致しています。</p><pre class="programlisting">SELECT road_id, road_name
  FROM roads
  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::geometry;</pre><p>上のクエリは"ROADS_GEOM"テーブルから、その値と等価である単一のレコードを返します。</p><p>道路がポリゴンで定義した面を通過するかどうかをチェックするには次のようにします。</p><pre class="programlisting">SELECT road_id, road_name
FROM roads
WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');</pre><p>最も一般的な空間クエリは「フレームベース」のクエリでしょう。これは、表示するためのデータの価値のある「マップフレーム」を取得するために、データブラウザやウェブマッパのようなクライアントソフトウェアに使われます。 </p><p>"&amp;&amp;"演算子を使うとき、比較フィーチャーをBOX3DかGEOMETRYかに指定することができます。ただし、GEOMETRYを指定すると、それのバウンディングボックスが比較に使われます。</p><p>次に示すクエリのように、フレームにBOX3Dオブジェクトを使います。</p><pre class="programlisting">SELECT ST_AsText(roads_geom) AS geom
FROM roads
WHERE
  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);</pre><p>エンベロープの投影を指定するためにSRID 312を使っていることに注意して下さい。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="pgsql2shp-usage"></a>4.1.6.2. ダンパを使う</h4></div></div></div><p><code class="filename">pgsql2shp</code>テーブルダンパは、データベースに直接接続して、テーブル (あるいはクエリによって定義されたもの)をシェープファイルに変換するものです。基本的な文は次の通りです。</p><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;database&gt; [&lt;スキーマ&gt;.]&lt;table&gt;</pre><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; &lt;クエリ&gt;</pre><p>コマンドラインオプションは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-f &lt;ファイル名&gt;</span></dt><dd><p>特定のファイル名に出力を書きこみます。</p></dd><dt><span class="term">-h &lt;ホスト&gt;</span></dt><dd><p>接続先データベースのホスト名。</p></dd><dt><span class="term">-p &lt;ポート&gt;</span></dt><dd><p>接続先データベースのポート。</p></dd><dt><span class="term">-P &lt;パスワード&gt;</span></dt><dd><p>データベースに接続するためのパスワード。</p></dd><dt><span class="term">-u &lt;ユーザ名&gt;</span></dt><dd><p>データベースに接続する際のユーザ名。</p></dd><dt><span class="term">-g &lt;ジオメトリカラム&gt;</span></dt><dd><p>複数のジオメトリカラムを持つテーブルの場合の、シェープファイルの出力に使用するジオメトリカラム。</p></dd><dt><span class="term">-b</span></dt><dd><p>バイナリカーソルを使います。これは、実行時間を短くしますが、テーブルの非ジオメトリ属性がテキストへのキャストを持っていない場合には、動作しません。</p></dd><dt><span class="term">-r</span></dt><dd><p>Rawモード。<code class="varname">gid</code>フィールドを落としたり、カラム名をエスケープしてはいけません。</p></dd><dt><span class="term">-m <code class="varname">ファイル名</code></span></dt><dd><p>識別名を10文字名に再割り当てします。 ファイルの中身は、一つの空白で区切られ、前と後に空白が無い二つのシンボルの行からなります。VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER等となります。</p></dd></dl></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="build-indexes"></a>4.1.7. 空間インデックスを構築する</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#gist_indexes">4.1.7.1. GiSTインデックス</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#brin_indexes">4.1.7.2. BRINインデックス</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#spgist_indexes">4.1.7.3. SP-GiSTインデックス</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp53172984">4.1.7.4. インデックスを使う</a></span></dt></dl></div><p>インデックスによって巨大データセットの空間データベースの使用が可能となります。インデックス無しでは、地物の検索を行う際に、データベースの全てのレコードに対するシーケンシャルスキャンが必要となります。インデックスによって、データからレコード探索のために早く移動できる構造を構築するので、検索速度が向上します。 </p><p>一般に属性データ使われるB木インデックスによる方法は、空間データにはあまり使いやすくはありません。1次元のデータの格納と問い合わせにしか対応していないためです。ジオメトリのように2以上の次元を持つデータには、データの次元の全ての範囲に対応するインデックス手法が必要です (B木と明示的な範囲検索を使って、いわゆるXYデータのインデックスを生成することが可能です)。空間データ処理におけるPostgreSQLの主な利点は、高次元データで有効に動作する数種類のインデックス、すなわちGiST、BRIN、SP-GiSTを提供していることです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>GiST (Generalized Search Tree)</strong></span>インデックスは、データを「一方にあるもの」「オーバラップするもの」「内部にあるもの」に分解するもので、GISデータを含む幅広い範囲で使えます。PostGISはGiSTインデックス空間データをR木インデックス実装のベースにています。GiSTは最も一般的に使われ、多目的なインデックス手法で、非常に良好な問い合わせ効率を提供しています。 </p></li><li class="listitem"><p><span class="bold"><strong>BRIN (Block Range Index)</strong></span>インデックスは、空間範囲を集計することで動作します。探索は範囲のスキャンを通して行われます。BRINは一部の種類 (空間的にソートされ、更新がほぼ無いか全く無い)のデータだけに適切です。しかし、インデックス生成時間は非所に早く、インデックスサイズは非常に小さくなります。 </p></li><li class="listitem"><p><span class="bold"><strong>SP-GiST (Space-Partitioned Generalized Search Tree)</strong></span>は4分木、kd木、基数木 (トライ木)のような部分木探索に対応する一般的なインデックス手法です。 </p></li></ul></div><p>詳細情報については<a class="ulink" href="https://postgis.net/workshops/postgis-intro/indexing.html" target="_top">PostGIS Workshop</a>と<a class="ulink" href="https://www.postgresql.org/docs/current/indexes.html" target="_top">PostgreSQL documentation</a>を参照して下さい。 </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="gist_indexes"></a>4.1.7.1. GiSTインデックス</h4></div></div></div><p>GiSTは「汎用的な検索木 (Generalized Search Tree)」の意味で、インデックスの一般化された形式です。GISインデックスに加えて、GiSTは通常のB木インデックスに従わない全ての種類の不規則なデータ構造 (整数配列, スペクトラルデータ等)の検索速度を向上させるために使います。</p><p>ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデックスを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常のインデックスを属性フィールドに追加します)。</p><p>GiSTインデックスをジオメトリカラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>上の文では常に2次元インデックスを構築します。n次元インデックスをジオメトリ型で使うには、次の文でインデックスを生成できます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] gist_geometry_ops_nd);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムではより遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム名] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="brin_indexes"></a>4.1.7.2. BRINインデックス</h4></div></div></div><p>BRINは"Block Range Index"の略です。PostgreSQL 9.5で導入された汎用<a class="ulink" href="https://www.postgresql.org/docs/current/brin.html" target="_top">index method</a>です。BRINは<span class="emphasis"><em>不可逆</em></span>インデックス手法であり、レコードが与えた検索条件に合致することを確認する二番目のチェックが必要であることを意味しています (全ての空間インデックスで言えます)。非常に速いインデックス作成、非常に小さいインデックスサイズで、合理的な読み込み効率を持ちます。主目的は、非常に大きいテーブルのテーブル内の物理位置と関係があるカラムにインデックスを作ることに対応するためです。空間インデックスに加えて、BRINは様々な種類の属性データ構造 (整数、配列等)で速度向上させることができます。</p><p>空間テーブルが、ひとたび数千行を超えると、データの空間検索の速度向上にインデックスが必要と感じることになります。GiSTインデックスは、サイズがデータベースで使えるRAM容量を超えず、インデックスのストレージサイズに余裕があり、書き込み時のインデックス更新コストにも余裕があるなら、非常に高いパフォーマンスを発揮します。そうでない場合には、非常に大きなテーブルにおいては、BRINインデックスを代替に考えることができます。</p><p>BRINインデックスは、連続するテーブルブロックの集合 (<span class="emphasis"><em>ブロック範囲</em></span>と言います)の全てのジオメトリを囲むバウンディングボックスを格納します。インデックスを使用した問い合わせを実行する時に、問い合わせ範囲とインタセクトするブロック範囲を見つけるためにスキャンします。これは、データが物理的に整列していて、ブロック範囲のバウンディングボックスのオーバラップが最小である (理想的には相互に排他的である)場合に限って効率的です。結果インデックスは非常に小さいサイズですが、通常、読み込み効率は、同じデータにおけるGiSTインデックスより悪くなります。</p><p>BRINインデックスの構築は、はGiSTインデックスと比べて、CPU集中を非常に減らします。BRINインデックスはGiSTインデックスよりも、同じデータに対して10倍速く構築するのが普通です。BRINインデックスはテーブルブロックの範囲ごとに一つのバウンディングボックスしか格納しないので、GiSTインデックスと比べて、ディスクスペースを1000倍少なくできます。</p><p>レンジ内で要約するブロック数を選択できます。この数字を減らすと、インデックスは大きくなりますが、効率向上の助けになる可能性があります。</p><p>BRINを効果的にするには、テーブルデータをブロック範囲のオーバラップの量を最小にするような物理的オーダーで格納します。データが既に適切に並び替えられているかも知れません (たとえば、既に空間オーダーで並び替えられているデータセットを他のデータベースからロードする場合)。そうでない場合には、一つの空間キーによるデータの並べ替えで実現できます。一つの方法として、ジオメトリ値で並べ替えた新しいテーブルを生成することです (最近のPostGISのバージョンで効果的なヒルベルト曲線オーダーが使われています)。 </p><pre class="programlisting">CREATE TABLE table_sorted AS
   SELECT * FROM table  ORDER BY geom;
</pre><p>もしくは、データは、ジオハッシュを (一時的な)インデックスに使い、そのインデックスでクラスタリングを行うことによって適切に並べ替えることができます。 </p><pre class="programlisting">CREATE INDEX idx_temp_geohash ON table
    USING btree (ST_GeoHash( ST_Transform( geom, 4326 ), 20));
CLUSTER table USING idx_temp_geohash;
</pre><p>BRINインデックスを<code class="code">ジオメトリ</code>カラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ); </pre><p>上の文で2次元インデックスを構築します。3次元インデックスをビルドするには、この文を使います。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_3d);</pre><p>また、4次元演算子クラスを使う4次元インデックスを使うこともできます。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] brin_geometry_inclusion_ops_4d);</pre><p>上記のコマンドでは、範囲のブロック数はデフォルトの128を使用しています。集計で範囲のブロック数を指定するには、この文を使います。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名]
    USING BRIN ( [ジオメトリカラム名] ) WITH (pages_per_range = [数字]); </pre><p>また、BRINインデックスは、多数の行で一つのインデックス値を格納することを心に留めておいて下さい。テーブルに違う次元のジオメトリを格納する場合には、インデックスの効率が悪くなります。この効率欠落を回避するには、格納したジオメトリの次元数の最小値となる演算子クラスを選択します。 </p><p>「ジオグラフィ」型もまたBRINインデックスに対応しています。BRINインデックスを「ジオグラフィ」カラムに構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING BRIN ( [ジオメトリカラム名] ); </pre><p>上の文では常に回転楕円体面上の地理空間オブジェクトの2次元インデックスを構築します。 </p><p>現在のところは「包括対応」だけをここで考えています。これは、<code class="varname">&amp;&amp;</code>, <code class="varname">~</code>, <code class="varname">@</code>の演算子だけが2次元で使われることを意味します (<code class="code">ジオメトリ</code>と<code class="code">ジオグラフィ</code>の両方)。 <code class="varname">&amp;&amp;&amp;</code>演算子は3次元ジオメトリで使えます。しばらくはKNN検索に対応しません。</p><p>BRINと他のインデックスとの重要な違いは、データベースがインデックスを動的に保守しないことです。テーブルの空間データを変更すると、単純にインデックスの末尾に追加しています。このためインデックス探索の能率が時間とともに低下します。インデックスは<code class="code">VACUUM</code>か空間関数<code class="code">brin_summarize_new_values(regclass)</code>を実行することで更新できます。このため、BRINは読み込み専用か、書き込みがほとんど発生しないよなデータでの利用では最も適切になりえます。詳細情報については、<a class="ulink" href="https://www.postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION" target="_top">manual</a>をご覧下さい。 </p><p>空間データにBRINを使用して集計するには: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>インデックス構築時間は非常に速く、インデックスサイズは非常に小さいです。</p></li><li class="listitem"><p>インデックスのクエリ時間はGiSTより遅いですが、十分許容できます。</p></li><li class="listitem"><p>テーブルデータを空間順序で並べ替える必要があります。</p></li><li class="listitem"><p>手動でインデックスの保守をする必要があります。</p></li><li class="listitem"><p>巨大なテーブルであって、オーバラップが少ないか無く (ポイントなど)、かつ静的か頻繁には変更しないようなものに、最も適しています。</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="spgist_indexes"></a>4.1.7.3. SP-GiSTインデックス</h4></div></div></div><p>SP-GiSTは、「空間分割された一般探索木」を表します。四分木、k次元木、基数木 (トライ木)のような分割探索木に対応するインデックスの総称的な形式です。このデータ構造の一般的な機能は、検索空間を反復して分割することですが、分割は等しいサイズである必要はありません。SP-GiSTは、GISインデックスだけでなく、電話回線のルーティングや、IPルーティング、部分文字列検索等といった、様々な種類のデータを探索する速度の向上に使われます。 </p><p>GiSTインデックスのためのケースですので、空間オブジェクトを覆うバウンディングボックスを保存するという意味で、SP-GiSTインデックスは不可逆です。SP-GiSTインデックスは、GiSTインデックスの選択肢の一つとして考えることができます。能率試験によって、SP-GiSTインデックスは,、多数のオーバラップするオブジェクトがある「スパゲッティデータ」と呼ばれる状態のときに、特に有利であることが分かりました。</p><p>一度GISデータテーブルが数千行を超えると、データの空間探索の速度向上にSP-GiSTインデックスを使うと良いかも知れません。「ジオメトリ」カラムにSP-GiSTインデックスを構築するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>上の文では、2次元インデックスを構築します。ジオメトリ型の3次元インデックスは、次のように、3次元演算子クラスを使用して生成します。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING SPGIST ([ジオメトリカラム] spgist_geometry_ops_3d);</pre><p>空間インデックスの構築は、計算量を集中させて行われます。また、この時には、テーブルへの書き込みアクセスがブロックされます。そのため、本番システムでは、より遅いCONCURRENTLYを選択するかも知れません。次のようにします。</p><pre class="programlisting">CREATE INDEX CONCURRENTLY [インデックス名] ON [テーブル名] USING SPGIST ( [ジオメトリカラム] ); </pre><p>インデックス構築後に、時々PostgreSQLにテーブルの統計情報を集めさせると助かります。クエリプランの最適化に使われます。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [(カラム名)];</pre><p>SP-GiSTインデックスは次の演算子を含むクエリの実行速度を向上させられます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>2次元インデックスについては &lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, |&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~= 。</p></li><li class="listitem"><p>3次元インデックスについては &amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@ 。</p></li></ul></div><p>現時点ではkNN探索に対応していません。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53172984"></a>4.1.7.4. インデックスを使う</h4></div></div></div><p>通常、インデックスは見えないところでデータアクセスの速度向上を行います。すなわち、ひとたびインデックスが構築されたら、クエリプランナは自動的に、クエリプランの速度を向上させるためにインデックス情報を使うべき時を判断します。残念なことに、クエリプランナはGiSTインデックスの使用について十分に最適化できず、時々、検索で空間インデックスを使用すべきなのに、テーブル全体を順に走査することがあります。</p><p>空間インデックスが使われていないのが分かった場合には、少しの行えることがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>クエリプランの試験とクエリの確認で、必要なものを計算できます。誤ったJOINや忘れ去られたテーブルや間違ったテーブルでは、予期しないテーブルレコード検索が複数回行われることがありえます。クエリプランを得るにはクエリの先頭に<code class="code">EXPLAIN</code>を付けて実行します。</p></li><li class="listitem"><p>テーブル内の値の数量と分布に関する統計情報を収集するとともに、クエリプランナにインデックス使用にかかる意思決定のための、より良い情報を与えるようにします。<span class="command"><strong>VACUUM ANALYZE</strong></span>は両方を計算します。</p><p>データベースに対する定期的なvacuumは常に実行するべきです。多くのPostgreSQLデータベースエージェントは、閑散時のcronジョブとして定期的に<span class="command"><strong>VACUUM</strong></span>を実行します。</p></li><li class="listitem"><p>vacuumが働かないなら、<span class="command"><strong>set enable_seqscan to off;</strong></span>コマンドで、一時的にプランナに対してインデックス情報の使用を強制することができます。この方法で、プランナがインデックスを使用するプランを生成できるかどうか確認できます。このコマンドはデバッグにのみ使用すべきです。一般的に言うと、プランナはあなたよりインデックスを使うべき時を知っています。クエリを実行したら、<code class="varname">ENABLE_SEQSCAN</code>設定を戻して、他のクエリでは通常通りプランナを使用します。</p></li><li class="listitem"><p>もし、<span class="command"><strong>set enable_seqscan to off;</strong></span>がクエリの実行に役立っているなら、お使いのPostgreSQLはハードウェアにあわせた調整をしていないようです。順に走査する際のコストとインデックスを使う際のコストとを比較してプランナが間違っていることに気付いたら、postgresql.confで<code class="varname">random_page_cost</code>の値を減らしてみるか、<span class="command"><strong>set random_page_cost to 1.1;</strong></span>を使ってみてください。このパラメータのデフォルト値は4ですが、それを1 (SSDの場合)または2 (高速磁気ディスクの場合)にして下さい。値を減らすことで、プランナがよりインデックススキャンを行う傾向になります。</p></li><li class="listitem"><p><span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span>がクエリの助けにならないなら、クエリはPostgreSQLプランナがまだ最適化できないSQL構成なのかも知れません。プランナが処理できるようにクエリを再記述できるかもしれません。例えば、インラインSELECTを持つ副問い合わせがあると、効果的なプランを作らないことがあり、LATERAL JOINを使うように書き換えることができます。</p></li></ul></div></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using_postgis_query"></a>4.2. 空間クエリ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#eval_spatial_rel">4.2.1. 空間関係の決定</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#using-query-indexes">4.2.2. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#examples_spatial_sql">4.2.3. 空間SQLの例</a></span></dt></dl></div><p>空間データベースの<span class="emphasis"><em>レゾンデートル</em></span>は、通常はデスクトップGISの機能が必要なクエリをデータベース内で実行することです。PostGISを使うには、使用可能な空間関数は何かを知り、またクエリ内でどう使うかを知って、適切なインデックスで能率を向上させることが求められます。 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="eval_spatial_rel"></a>4.2.1. 空間関係の決定</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp53695992">4.2.1.1. Dimensionally Extended 9-Intersection Model</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp53782904">4.2.1.2. 名前付き空間関係</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp53795704">4.2.1.3. 一般的な空間関係</a></span></dt></dl></div><p>空間関係は、二つのジオメトリについて、一方がもう一方にどのような相互関係ちなっているかを示すものです。ジオメトリのクエリにおける基本的な機能です。 </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53695992"></a>4.2.1.1. Dimensionally Extended 9-Intersection Model</h4></div></div></div><p><a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">OpenGIS Simple Features Implementation Specification for SQL</a>によると「二つのジオメトリの比較の基本的なアプローチは、二つのジオメトリの内部、境界、外部のインタセクションの比較と、『インタセクション行列』の要素に基づく2ジオメトリの関係の分類です」。</p><p>点集合トポロジ理論では、2次元空間に埋め込まれたジオメトリの中にあるポイントは、次に示す三つの集合に分類されます。 </p><div class="glosslist"><dl><dt><span class="glossterm">境界 (Boundary)</span></dt><dd class="glossdef"><p>ジオメトリの境界は、一次元低いジオメトリです。<code class="varname">POINT</code>では、次元が0になり、境界は空集合です。<code class="varname">LINESTRING</code>の境界は二つの端点です。<code class="varname">POLYGON</code>の境界は、外環と内環の線です。</p></dd><dt><span class="glossterm">内部 (Interior)</span></dt><dd class="glossdef"><p>ジオメトリの内部は、ジオメトリの境界以外のポイントです。<code class="varname">POINT</code>では、内部はポイント自体です。<code class="varname">LINESTRING</code>の内部は端点の間のポイントの集合です。<code class="varname">POLYGON</code>の内部は、ポリゴン内部の面です。</p></dd><dt><span class="glossterm">外部 (Exterior)</span></dt><dd class="glossdef"><p>ジオメトリの外部はジオメトリが組み込まれた空間の残りです。言い換えると、ジオメトリの内部にも境界にもない点の全てです。これは2次元の閉じていない面になります。 </p></dd></dl></div><p><a class="ulink" href="http://en.wikipedia.org/wiki/DE-9IM" target="_top">Dimensionally Extended 9-Intersection Model</a> (DE-9IM)は、二つのジオメトリの空間関係を九つの交差の次元を指定することで記述します。交差次元は3×3の<span class="bold"><strong>交差行列</strong></span>で正式に表現することができます。 </p><p>ジオメトリ<span class="emphasis"><em>g</em></span>に対する<span class="emphasis"><em>内部</em></span>、<span class="emphasis"><em>境界</em></span>、<span class="emphasis"><em>外部</em></span>は<span class="emphasis"><em>I(g)</em></span>、<span class="emphasis"><em>B(g)</em></span>、<span class="emphasis"><em>E(g)</em></span>と表記します。また、<span class="emphasis"><em>dim(s)</em></span>は<span class="emphasis"><em>s</em></span>の集合を<code class="literal">{0,1,2,F}</code>の値で示すます。 </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">0</code> =&gt; 点</p></li><li class="listitem"><p><code class="literal">1</code> =&gt; 線</p></li><li class="listitem"><p><code class="literal">2</code> =&gt; 面</p></li><li class="listitem"><p><code class="literal">F</code> =&gt; 空集合</p></li></ul></div><p>この表記法を使うと、二つのジオメトリ<span class="emphasis"><em>a</em></span>と<span class="emphasis"><em>b</em></span>の交差行列は次の通りです。</p><div class="styledtable"><table class="styledtable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col><col><col><col></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"> </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>内部 (Interior)</strong></span></th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>境界 (Boundary)</strong></span></th><th style="border-bottom: 1px solid ; " align="center"><span class="bold"><strong>外部 (Exterior)</strong></span></th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>内部 (Interior)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ B(b) )</em></span></td><td style="border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( I(a) ∩ E(b) )</em></span></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="bold"><strong>境界 (Boundary)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ B(b) )</em></span></td><td style="border-bottom: 1px solid ; " align="center"><span class="emphasis"><em>dim( B(a) ∩ E(b) )</em></span></td></tr><tr><td style="border-right: 1px solid ; " align="center"><span class="bold"><strong>外部 (Exterior)</strong></span></td><td style="border-right: 1px solid ; " align="center"><span class="emphasis"><em>dim( E(a) ∩ I(b) )</em></span></td><td style="border-right: 1px solid ; " align="center"><span class="emphasis"><em>dim( E(a) ∩ B(b) )</em></span></td><td style="" align="center"><span class="emphasis"><em>dim( E(a) ∩ E(b) )</em></span></td></tr></tbody></table></div><p>二つのオーバラップするポリゴンについて可視化すると、次のようになります。</p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col width="80pt"><col></colgroup><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; "> </td><td style="border-bottom: 1px solid ; " align="center"><div class="informalfigure"><div align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;"><tr><td align="center" valign="middle"><img src="images/de9im04.png" align="middle"></td></tr></table></div></div></td></tr><tr><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;"><tr><td align="center" valign="middle"><img src="images/de9im03.png" align="middle"></td></tr></table></div></div></td><td style=""><p> </p><div class="styledtable"><table class="styledtable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col><col><col><col></colgroup><thead valign="middle"><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"> </th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>内部 (Interior)</strong></span></th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>境界 (Boundary)</strong></span></th><th style="border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>外部 (Exterior)</strong></span></th></tr></thead><tbody valign="middle"><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>内部 (Interior)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im05.png"></div></div><p><span class="emphasis"><em>dim( I(a) ∩ I(b) ) = </em></span><span class="bold"><strong>2</strong></span></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im06.png"></div></div><p><span class="emphasis"><em>dim( I(a) ∩ B(b) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im07.png"></div></div><p><span class="emphasis"><em>dim( I(a) ∩ E(b) ) = </em></span><span class="bold"><strong>2</strong></span></p></td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>境界 (Boundary)</strong></span></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im08.png"></div></div><p><span class="emphasis"><em>dim( B(a) ∩ I(b) ) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im09.png"></div></div><p><span class="emphasis"><em>dim( B(a) ∩ B(b) ) = </em></span><span class="bold"><strong>0</strong></span></p></td><td style="border-bottom: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im10.png"></div></div><p><span class="emphasis"><em>dim( B(a) ∩ E(b) ) = </em></span><span class="bold"><strong>1</strong></span></p></td></tr><tr><td style="border-right: 1px solid ; " align="center" valign="middle"><span class="bold"><strong>外部 (Exterior)</strong></span></td><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im11.png"></div></div><p><span class="emphasis"><em>dim( E(a) ∩ I(b) ) = </em></span><span class="bold"><strong>2</strong></span></p></td><td style="border-right: 1px solid ; " align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im12.png"></div></div><p><span class="emphasis"><em>dim( E(a) ∩ B(b) ) = </em></span><span class="bold"><strong>1</strong></span></p></td><td style="" align="center" valign="middle"><div class="informalfigure"><div><img src="images/de9im13.png"></div></div><p><span class="emphasis"><em>dim( E(a) ∩ E(b) = </em></span><span class="bold"><strong>2</strong></span></p></td></tr></tbody></table></div></td></tr></tbody></table></div><p>左から右に、上から下に読みます。交差行列の文字列表現は'<span class="bold"><strong>212101212</strong></span>'です。</p><p>詳細情報については次をご覧下さい。</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">OpenGIS Simple Features Implementation Specification for SQL</a> (1.1版, 2.1.13.2節)</p></li><li class="listitem"><p><a class="ulink" href="https://en.wikipedia.org/wiki/DE-9IM" target="_top">Wikipedia: Dimensionally Extended Nine-Intersection Model (DE-9IM)</a></p></li><li class="listitem"><p><a class="ulink" href="http://docs.geotools.org/latest/userguide/library/jts/dim9.html" target="_top">GeoTools: Point Set Theory and the DE-9IM Matrix</a></p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53782904"></a>4.2.1.2. 名前付き空間関係</h4></div></div></div><p>共通の空間関係を簡単に決定できるように、PGC SFSは<span class="emphasis"><em>名前付き空間関係述語</em></span>の集合を定義しています。PostGISでは<a class="xref" href="ST_Contains.html" title="ST_Contains">ST_Contains</a>、<a class="xref" href="ST_Crosses.html" title="ST_Crosses">ST_Crosses</a>、<a class="xref" href="ST_Disjoint.html" title="ST_Disjoint">ST_Disjoint</a>、<a class="xref" href="ST_Equals.html" title="ST_Equals">ST_Equals</a>、<a class="xref" href="ST_Intersects.html" title="ST_Intersects">ST_Intersects</a>、<a class="xref" href="ST_Overlaps.html" title="ST_Overlaps">ST_Overlaps</a>、<a class="xref" href="ST_Touches.html" title="ST_Touches">ST_Touches</a>、<a class="xref" href="ST_Within.html" title="ST_Within">ST_Within</a>が提供されています。非標準の空間関係述語<a class="xref" href="ST_Covers.html" title="ST_Covers">ST_Covers</a>、<a class="xref" href="ST_CoveredBy.html" title="ST_CoveredBy">ST_CoveredBy</a>、<a class="xref" href="ST_ContainsProperly.html" title="ST_ContainsProperly">ST_ContainsProperly</a>も定義されています。 </p><p>空間述語は通常SQLの<code class="code">WHERE</code>節や<code class="code">JOIN</code>節内で条件に使用されます。名前付き空間述語は、インデックスが有効なら自動的に空間インデックスを使うので、バウンディングボックス演算子<code class="code">&amp;&amp;</code>を使う必要はありません。例えば次のようになります。 </p><pre class="programlisting">SELECT city.name, state.name, city.geom
FROM city JOIN state ON ST_Intersects(city.geom, state.geom);
</pre><p>詳細や図については<a class="ulink" href="https://postgis.net/workshops/postgis-intro/spatial_relationships.html" target="_top">PostGIS Workshop</a>をご覧下さい。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp53795704"></a>4.2.1.3. 一般的な空間関係</h4></div></div></div><p>名前付き空間関係が求める空間フィルタ条件を与えるのに不十分となる場合があります。 </p><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><div class="informalfigure-float" style="float: right;"><div class="informalfigure"><div align="left"><img src="images/de9im01.png" align="left"></div></div></div><p>例えば、道路ネットワークを表現する線データセットを考えてみます。点でなく線で交差する全ての道路の辺を識別しなければならないことがあります (ビジネスルールの検証のためならありえます)。この場合、<a class="xref" href="ST_Crosses.html" title="ST_Crosses">ST_Crosses</a>では、点で交差する場合しか<code class="varname">true</code>を返さないので、必要な空間フィルタになりません。 </p>
                <p>2ステップ解決法を示します。まず、空間的にインタセクトしている同路線の二本を抜き出し (<a class="xref" href="ST_Intersects.html" title="ST_Intersects">ST_Intersects</a>)、実際にインタセクトしている部分を計算 (<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>)します。次いで、インタセクトしている部分の<a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>が<code class="varname">LINESTRING</code>' かどうかを確認します (<code class="varname">[MULTI]POINT</code>、<code class="varname">[MULTI]LINESTRING</code>等の<code class="varname">GEOMETRYCOLLECTION</code>を返す場合に適切に処理します)。</p>
                <p>明らかに、より単純でより速い解法が望ましいです。</p></td></tr></tbody></table></div><div class="informaltable"><table class="informaltable" style="border: none;"><colgroup><col></colgroup><tbody><tr><td style=""><p> </p><div class="informalfigure-float" style="float: right;"><div class="informalfigure"><div align="right"><img src="images/de9im02.png" align="right"></div></div></div> <p>二つ目の例では、湖の境界とインタセクトし、かつ終端が岸に上がっている波止場を見つけます。言い換えると、波止場が湖に含まれるが完全には含まれず、湖の境界線とインタセクトして、波止場の終端が確実に湖内または境界にある場合を指します。空間述語を併用すると求める地物を見つけることができます。</p> <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="ST_Contains.html" title="ST_Contains">ST_Contains</a>(lake, wharf) = TRUE</p></li><li class="listitem"><p><a class="xref" href="ST_ContainsProperly.html" title="ST_ContainsProperly">ST_ContainsProperly</a>(lake, wharf) = FALSE</p></li><li class="listitem"><p><a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>(<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>(wharf, lake)) = 'LINESTRING'</p></li><li class="listitem"><p><a class="xref" href="ST_NumGeometries.html" title="ST_NumGeometries">ST_NumGeometries</a>(<a class="xref" href="ST_Multi.html" title="ST_Multi">ST_Multi</a>(<a class="xref" href="ST_Intersection.html" title="ST_Intersection">ST_Intersection</a>(<a class="xref" href="ST_Boundary.html" title="ST_Boundary">ST_Boundary</a>(wharf), <a class="xref" href="ST_Boundary.html" title="ST_Boundary">ST_Boundary</a>(lake)))) = 1</p><p>… 言うまでもないですが非常に複雑ですね。</p></li></ul></div></td></tr></tbody></table></div><p>この要件は完全なDE-9IM交差行列の計算で満たすことができます。PostGISは、これを行う<a class="xref" href="ST_Relate.html" title="ST_Relate">ST_Relate</a>関数を提供しています。次のようにします。 </p><pre class="programlisting">SELECT ST_Relate( 'LINESTRING (1 1, 5 5)',
                  'POLYGON ((3 3, 3 7, 7 7, 7 3, 3 3))' );
st_relate
-----------
1010F0212
</pre><p>特定の空間関係をテストするには、<span class="bold"><strong>交差行列パターン</strong></span>を使います。これは、追加シンボル<code class="literal">{T,*}</code>で拡張された行列表現です。 </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">T</code> =&gt; インタセクションの次元は空ではないという意味です。すなわち<code class="literal">{0,1,2}</code>のいずれかです。</p></li><li class="listitem"><p><code class="literal">*</code> =&gt; 何でも良い</p></li></ul></div><p>交差行列パターンを使って、特定の空間関係の評価がより簡潔な方法で可能です。交差行列パターンのテストに<a class="xref" href="ST_Relate.html" title="ST_Relate">ST_Relate</a>と<a class="xref" href="ST_RelateMatch.html" title="ST_RelateMatch">ST_RelateMatch</a>を使うことができます。上に挙げた一つ目の例では、二つのラインがライン内部でインタセクトする交差行列パターンは'<span class="bold"><strong>1*1***1**</strong></span>'となります。</p><pre class="programlisting">-- ライン内でインタセクトする道路区間を見つける
SELECT a.id
FROM roads a, roads b
WHERE a.id != b.id
      AND a.geom &amp;&amp; b.geom
      AND ST_Relate(a.geom, b.geom, '1*1***1**');</pre><p>二つ目の例です。一本のラインが部分的にポリゴン内部とポリゴン外部とにある場合の交差行列パターンは '<span class="bold"><strong>102101FF2</strong></span>'となります。</p><pre class="programlisting">-- 一部が湖の水涯線上にある波止場を見つける
SELECT a.lake_id, b.wharf_id
FROM lakes a, wharfs b
WHERE a.geom &amp;&amp; b.geom
      AND ST_Relate(a.geom, b.geom, '102101FF2');</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="using-query-indexes"></a>4.2.2. インデックスの利点を使う</h3></div></div></div><p>空間条件を使うクエリを構築する時、空間インデックスが存在する場合 (<a class="xref" href="postgis_usage.html#build-indexes" title="4.1.7. 空間インデックスを構築する">「空間インデックスを構築する」</a>を参照して下さい)には、空間インデックスを使うようにすることが重要です。これを行うには、<code class="code">WHERE</code>節や<code class="code">ON</code>節内でインデックスに対応する空間演算子や空間関数を使わなければなりません。空間演算子はバウンディングボックスを使った演算を行い (最も多く使われるのが<a class="xref" href="geometry_overlaps.html" title="&amp;&amp;">&amp;&amp;</a>です)、距離演算子は最近傍クエリを使います (最も使われるのが<a class="xref" href="geometry_distance_knn.html" title="&lt;-&gt;">&lt;-&gt;</a>です)。インデックスに対応する関数には、ほとんどの名前付き述語 (<a class="xref" href="ST_Intersects.html" title="ST_Intersects">ST_Intersects</a>等)と、ほとんどの距離述語 (<a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a>等)が含まれます。 </p><p><a class="xref" href="ST_Distance.html" title="ST_Distance">ST_Distance</a>のような関数は、演算最適化にインデックスを使いません。例えば、次のクエリは、大きいテーブルでは非常に遅くなります。</p><pre class="programlisting">SELECT the_geom
FROM geom_table
WHERE ST_Distance(the_geom, 'SRID=312;POINT(100000 200000)') &lt; 100</pre><p>このクエリは<code class="code">geom_table</code>テーブル内の、(100000, 200000)のポイントから100単位内にある全てのジオメトリを選択します。テーブル内の個々のポイントと指定したポイントとの距離を計算しているため、非常に遅くなります。すなわち、1回の<code class="varname">ST_Distance()</code>の計算で、テーブルの<span class="bold"><strong>全ての</strong></span>行について計算することになります。 </p><p>インデックス対応関数である<a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a>を使用すると処理対象行の数を減らすことができます。</p><pre class="programlisting">SELECT the_geom
FROM geom_table
WHERE ST_DWithin(the_geom, 'SRID=312;POINT(100000 200000)', 100)
</pre><p>このクエリは、同じジオメトリを選択しますが、より効率的な方法を取ります。 <code class="varname">ST_DWithin()</code>が内部で<code class="varname">&amp;&amp;</code>演算子をクエリジオメトリのバウンディングボックスを拡大したボックスで使うことによって可能となります。<code class="code">the_geom</code>上に空間インデックスが存在するなら、クエリプランナは距離計算の前に対象行数を減らすためにインデックスを使えることを認識します。空間インデックスによって、バウンディングボックスが拡張された範囲とオーバラップするジオメトリだけを検索して、そのため、求めようとする距離内にある<span class="emphasis"><em>かも知れない</em></span>ジオメトリを検索することができます。その後で、結果集合内のレコードを含めるかどうかを確認するための実際の距離計算が行われます。 </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="examples_spatial_sql"></a>4.2.3. 空間SQLの例</h3></div></div></div><p>本節の例では、線型の道、ポリゴンの自治体境界、の二つのテーブルを使います。テーブルの定義をしまします。<code class="varname">bc_roads</code>については次の通りです。</p><pre class="programlisting">Column      | Type              | Description
------------+-------------------+-------------------
gid         | integer           | Unique ID
name        | character varying | Road Name
the_geom    | geometry          | Location Geometry (Linestring)</pre><p><code class="varname">bc_municipality</code>テーブルの定義については次の通りです。</p><pre class="programlisting">Column     | Type              | Description
-----------+-------------------+-------------------
gid        | integer           | Unique ID
code       | integer           | Unique ID
name       | character varying | City / Town Name
the_geom   | geometry          | Location Geometry (Polygon)</pre><div class="qandaset"><a name="idp53846776"></a><dl><dt>4.2.3.1. <a href="postgis_usage.html#qa_total_length_roads">道路の総延長はkm表記でいくらになるでしょう?</a></dt><dt>4.2.3.2. <a href="postgis_usage.html#idp53849720">プリンスジョージ市の大きさはha表記でいくらになるでしょう?</a></dt><dt>4.2.3.3. <a href="postgis_usage.html#idp53852280">県内で最も大きな面積となる自治体はどこでしょう?</a></dt><dt>4.2.3.4. <a href="postgis_usage.html#idp53855096">各自治体内に含まれる道路の総延長はいくらでしょう?</a></dt><dt>4.2.3.5. <a href="postgis_usage.html#idp53857912">プリンスジョージ市内の全ての道路からなるテーブルを作る</a></dt><dt>4.2.3.6. <a href="postgis_usage.html#idp53860344">ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</a></dt><dt>4.2.3.7. <a href="postgis_usage.html#idp53862392">穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="qa_total_length_roads"></a><a name="idp53847416"></a><p><b>4.2.3.1.</b></p></td><td align="left" valign="top"><p>道路の総延長はkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>この問題は、次のようなとても単純なSQLで答えを得ることができます。</p><pre class="programlisting">SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;

km_roads
------------------
70842.1243039643
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53849720"></a><a name="idp53849976"></a><p><b>4.2.3.2.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市の大きさはha表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリでは、属性条件 (municipality name, 自治体名)に空間計算 (面積)を併用しています。</p><pre class="programlisting">SELECT
  ST_Area(the_geom)/10000 AS hectares
FROM bc_municipality
WHERE name = 'PRINCE GEORGE';

hectares
------------------
32657.9103824927
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53852280"></a><a name="idp53852536"></a><p><b>4.2.3.3.</b></p></td><td align="left" valign="top"><p>県内で最も大きな面積となる自治体はどこでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリは、空間計測をクエリ条件に持ってきています。この問題へのアプローチの方法はいくつかありますが、最も効率的なのは次の通りです。</p><pre class="programlisting">SELECT
  name,
  ST_Area(the_geom)/10000 AS hectares
FROM
  bc_municipality
ORDER BY hectares DESC
LIMIT 1;

name           | hectares
---------------+-----------------
TUMBLER RIDGE  | 155020.02556131
(1 row)</pre><p>このクエリの答えを出すためには、全てのポリゴンの面積を求める必要があることに注意して下さい。このクエリを多く実行する場合、性能向上のためにテーブルにareaカラムを追加して、別のインデックスを追加することができるようにするのは、意義のあることです。結果を距離について降順に並べ替え、PostgreSQLの"LIMIT"コマンドを用いることで、max()のような集約関数を使わずに、簡単に最も大きい値を集約関数を得ることができます。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53855096"></a><a name="idp53855352"></a><p><b>4.2.3.4.</b></p></td><td align="left" valign="top"><p>各自治体内に含まれる道路の総延長はいくらでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、二つのテーブルからデータを持ち込んで (結合して)いるので「空間結合」の例です。しかし、結合の条件として共通キーの上で接続するという普通のリレーションのやり方でなく空間インタラクション条件 (「含む」)を使っています。</p><pre class="programlisting">SELECT
  m.name,
  sum(ST_Length(r.the_geom))/1000 as roads_km
FROM
  bc_roads AS r,
  bc_municipality AS m
WHERE
  ST_Contains(m.the_geom, r.the_geom)
GROUP BY m.name
ORDER BY roads_km;

name                        | roads_km
----------------------------+------------------
SURREY                      | 1539.47553551242
VANCOUVER                   | 1450.33093486576
LANGLEY DISTRICT            | 833.793392535662
BURNABY                     | 773.769091404338
PRINCE GEORGE               | 694.37554369147
...</pre><p>このクエリは、テーブル内の全ての道路の合計を最終結果 (この例での話ですが約250Kmの道です)にまとめられるので、少し時間がかかります。より小さいオーバレイ (数百の道路で数千のレコード)の場合、応答はもっと早くなりえます。</p></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53857912"></a><a name="idp53858168"></a><p><b>4.2.3.5.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市内の全ての道路からなるテーブルを作る</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは「オーバレイ」の例です。つまり、二つのテーブルを取得して、空間的に切り取られた結果からなる新しいテーブルを出力します。上で示した「空間結合」と違い、このクエリは実際に新しいジオメトリを生成します。生成されたオーバレイはターボのかかった空間結合みたいなもので、より確かな解析作業に便利です。</p><pre class="programlisting">CREATE TABLE pg_roads as
SELECT
  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,
  ST_Length(r.the_geom) AS rd_orig_length,
  r.*
FROM
  bc_roads AS r,
  bc_municipality AS m
WHERE
  m.name = 'PRINCE GEORGE'
        AND ST_Intersects(r.the_geom, m.the_geom);</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53860344"></a><a name="idp53860600"></a><p><b>4.2.3.6.</b></p></td><td align="left" valign="top"><p>ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT
  sum(ST_Length(r.the_geom))/1000 AS kilometers
FROM
  bc_roads r,
  bc_municipality m
WHERE
        r.name = 'Douglas St'
        AND m.name = 'VICTORIA'
        AND ST_Intersects(m.the_geom, r.the_geom);

kilometers
------------------
4.89151904172838
(1 row)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp53862392"></a><a name="idp53862648"></a><p><b>4.2.3.7.</b></p></td><td align="left" valign="top"><p>穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">SELECT gid, name, ST_Area(the_geom) AS area
FROM bc_municipality
WHERE ST_NRings(the_geom) &gt; 1
ORDER BY area DESC LIMIT 1;

gid  | name         | area
-----+--------------+------------------
12   | SPALLUMCHEEN | 257374619.430216
(1 row)</pre></td></tr></tbody></table></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance_tips"></a>4.3. 性能向上に関する技法</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#small_tables_large_objects">4.3.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#database_clustering">4.3.2. ジオメトリインデクスでCLUSTERを実行する</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#avoiding_dimension_conversion">4.3.3. 次元変換の回避</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="small_tables_large_objects"></a>4.3.1. 大きなジオメトリを持つ小さなテーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp54078968">4.3.1.1. 問題の説明</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp54087288">4.3.1.2. 応急処置</a></span></dt></dl></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54078968"></a>4.3.1.1. 問題の説明</h4></div></div></div><p>現版のPostgreSQL (9.6を含む)では、TOASTテーブルに従うクエリオプティマイザの弱さに苦しみます。 TOASTテーブルは、(長いテキスト、イメージ、多数の頂点を持つ複合ジオメトリといった)通常のデータページに適合しない、(データサイズという意味では)巨大な値を納めるための「拡張部屋」の一種です。詳細情報は <a class="ulink" href="http://www.postgresql.org/docs/current/static/storage-toast.html" target="_top">the PostgreSQL Documentation for TOAST</a>をご覧ください。</p><p>(高解像度で全てのヨーロッパの国の境界を含むテーブルのような)大きなジオメトリがあるうえ、行がそう多くないテーブルを持つようになると、この問題が出てきます。テーブル自体は小さいのですが、多くのTOASTスペースを使います。例として、テーブル自体は概ね80行で3データページしか使わなくてもTOASTテーブルで8225ページを使うとします。</p><p>ここで、ジオメトリ演算子の&amp;&amp;を使って、ほとんどマッチしないようなバウンダリボックスを検索するクエリを出してみます。クエリオプティマイザにはテーブルは3ページ80行しかないように見えます。オプティマイザは、小さなテーブルを順に走査する方がインデクスを使うよりも早いと見積もります。そして、GiSTインデクスは無視すると決めます。通常なら、この見積もりは正しいです。しかし、この場合は&amp;&amp;演算子が全てのジオメトリをディスクから呼び出してバウンディングボックスと比較しなければならなくなり、ゆえに、全てのTOASTページもまた呼び出す必要があります。</p><p>この問題に苦しむかどうかを見るには、PostgreSQLの"EXPLAIN ANALYZE"コマンドを使います。詳細情報と技術情報については、PostgreSQL性能メーリングリストのスレッド<a class="ulink" href="http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php" target="_top">http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</a>をご覧下さい。</p><p>また、PostGISの新しいスレッド<a class="ulink" href="https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html" target="_top">https://lists.osgeo.org/pipermail/postgis-devel/2017-June/026209.html</a>もご覧下さい。</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54087288"></a>4.3.1.2. 応急処置</h4></div></div></div><p>PostgreSQLコミュニティでは、TOASTを意識したクエリ見積もりを作ることで、この問題を解決しようとしています。今のところは、二つの応急処置があります。</p><p>一つは、クエリプランナにインデクスの使用を強制することです。クエリを発行する前に"SET enable_seqscan TO off;"をサーバに送信します。これは基本的にクエリプランナに対して可能な限り順に走査することを避けるよう強制します。そのためGiSTインデクスを通常使うようになります。しかし、このフラグは接続するたびに設定しなければならず、他のケースにおいてはクエリプランナに誤った見積もりをさせることになるので、 "SET enable_seqscan TO on;"をクエリの後に送信すべきです。</p><p>もう一つは、順に走査することをクエリプランナが考える程度に早くすることです。これは、バウンダリボックスの「キャッシュ」を行う追加カラムを作成し、このカラムにマッチさせるようにすることで達成することができます。ここでの例では次のようになります。</p><pre class="programlisting">SELECT AddGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2');
UPDATE mytable SET bbox = ST_Envelope(ST_Force2D(the_geom));</pre><p>そして、次のように、&amp;&amp;演算子をgeom_columnに対して行っていたものをbboxに変更します。</p><pre class="programlisting">SELECT geom_column
FROM mytable
WHERE bbox &amp;&amp; ST_SetSRID('BOX3D(0 0,1 1)'::box3d,4326);</pre><p>もちろん、mytableの行を変更または追加したら、bboxを「同期」するようにしなければなりません。最もすっきりした方法はトリガです。もしくは、アプリケーションを変更してbboxカラムの現状を保持するか、テーブル更新後にいつもUPDATEクエリを実行するかでも対応できます。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="database_clustering"></a>4.3.2. ジオメトリインデクスでCLUSTERを実行する</h3></div></div></div><p>読み込むことがほとんどで、かつほとんどのクエリでひとつのインデクスを使うようなテーブルのために、PostgreSQLはCLUSTERコマンドを提供しています。このコマンドは、全てのデータ行を、インデクス基準にあわせて物理的に再整理するので、二つの性能の利点を生みます。一つは、インデクスの範囲走査のために、データテーブルのシーク回数が劇的に減少することです。もう一つは、いくつかの小さなインデクス間隔に集中する場合には、データ行が分布するデータページがより少なくなるので、より効率的なキャッシュを持つことです (この点で、PostgreSQLマニュアルのCLUSTERコマンドのドキュメントを読むように仕向けられていると感じて下さい)。</p><p>しかし、GiSTインデクスは単純にNULL値を無視するため現在のところPostGISのGiSTインデクスのクラスタリングはできず、次のようなエラーメッセージを得ます。</p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table;
ERROR: cannot cluster when index access method does not handle null values
(エラー: インデクスアクセスメソッドがNULL値を扱わない場合クラスタ化できません)
HINT: You may be able to work around this by marking column "the_geom" NOT NULL.
(ヒント: 列"the_geom"をNOT NULLとすることで、これを回避できるかもしれません)</pre><p>ヒントメッセージにある通り、テーブルに"not null"制限を追加することで、この欠陥にとりあえず対応できます。例を示します。</p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null;
ALTER TABLE</pre><p>もちろん、ジオメトリカラムで実際にNULL値が必要な場合、この対応はできません。さらには、制限を追加するには上の方法を使わなければならず、"ALTER TABLE blubb ADD CHECK (geometry is not null);"のようなCHECK制限は使えません。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="avoiding_dimension_conversion"></a>4.3.3. 次元変換の回避</h3></div></div></div><p>ときどき、テーブルで3次元、4次元のデータを持つのに、常にOpenGIS準拠のST_AsText()またはST_AsBinary()関数を使ってアクセスして 2次元ジオメトリを出力させるようなことが起きます。内部でST_Force_2d()関数を呼んでいるために発生しますが、これは、大きなジオメトリでは重大なオーバヘッドを誘引することになります。このオーバヘッドを回避するには、一度追加された次元を前もって落とし、かつこれを永続化するのが適当かも知れません。</p><pre class="programlisting">UPDATE mytable SET the_geom = ST_Force2D(the_geom);
VACUUM FULL ANALYZE mytable;</pre><p>AddGeometryColumn()を使ってジオメトリカラムを追加した場合、ジオメトリの次元に関する制限があることに注意してください。この制限を迂回するには、制限の削除が必要になります。geometry_columnsテーブル内のエントリを更新して、その後で制限を再作成することを忘れないで下さい。</p><p>大きなテーブルの場合、WHERE節、およびプライマリキー若しくは他の適切な基準によってテーブルの一部へのUPDATEを制限させて、UPDATEの実行の間に単に"VACUUM;"と実行することで、UPDATEをより小さい塊に分割するのが賢いやり方かもしれません。これにより、テンポラリディスクスペースが劇的に減少します。さらに、次元混合のジオメトリを持つ場合、"WHERE dimension(the_geom)&gt;2"によってUPDATEを制限することで、2次元で書かれているジオメトリの再書き込みをスキップさせることができます。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54158328"></a>4.4. アプリケーションのビルド</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#Using_MapServer">4.4.1. MapServerを使う</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp54217848">4.4.2. Javaクライアント (JDBC)</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#idp54220792">4.4.3. Cクライアント (libpq)</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Using_MapServer"></a>4.4.1. MapServerを使う</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp54163192">4.4.1.1. 基本的な使い方</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp54182904">4.4.1.2. よくある質問</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp54202872">4.4.1.3. 踏み込んだ使用法</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp54211320">4.4.1.4. 例</a></span></dt></dl></div><p>Minnesota MapServer は、OpenGIS Web Map Service仕様に準拠したインターネットWebマッピングサーバです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>MapServerのウェブサイトは<a class="ulink" href="http://mapserver.org/" target="_top">http://mapserver.org/</a>です。</p></li><li class="listitem"><p>OpenGIS Web Map Serviceの仕様書は<a class="ulink" href="http://www.opengeospatial.org/standards/wms" target="_top">http://www.opengeospatial.org/standards/wms</a>にあります。</p></li></ul></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54163192"></a>4.4.1.1. 基本的な使い方</h4></div></div></div><p>PostGISとMapServerとを併用するには、MapServerの設定方法を知る必要がありますが、本文書の範囲外です。本節では、PostGIS独特の問題と設定詳細について説明します。</p><p>PostGISをMapServerで使うには、次のものが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>PostGIS 0.6以上</p></li><li class="listitem"><p>MapServer 3.5以上</p></li></ul></div><p>MapServerは、他のPostgreSQLクライアントと同じくPostGIS/PostgreSQLデータにアクセスします。アクセスには<code class="filename">libpq</code>インタフェースを使います。つまり、MapServerは、PostGISサーバにアクセスするあらゆるネットワークに繋がっている計算機にインストールすることができ、PostGISをデータソースとして利用できます。システム間の接続が速いほど良くなります。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>"--with-postgis"と好きなconfigureオプションを付けてMpaServerのコンパイルとインストールを行います。</p></li><li class="listitem"><p>Mapserverのmapファイルの中に、PostGISレイヤを追加します。たとえば次のようになります。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "widehighways"
  # リモートの空間データベースに接続します
  CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  # 'roads'テーブルの'geom'カラムからラインを取得します
  DATA "geom from roads using srid=4326 using unique gid"
  STATUS ON
  TYPE LINE
  # 範囲内のラインである広い高速道路のみ描画します
  FILTER "type = 'highway' and numlanes &gt;= 4"
  CLASS
    # 非常に広い高速道路はより明るい色かつ2ピクセル幅にします
    EXPRESSION ([numlanes] &gt;= 6)
    STYLE
      COLOR 255 22 22
      WIDTH 2
    END
  END
  CLASS
     # 残りは、暗い色かつ1ピクセル幅です
    EXPRESSION ([numlanes] &lt; 6)
    STYLE
      COLOR 205 92 82
    END
  END
END</pre><p>上の例におけるPostGIS特有のディレクティブは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CONNECTIONTYPE</span></dt><dd><p>PostGISレイヤでは常に"postgis"とします。</p></dd><dt><span class="term">CONNECTION</span></dt><dd><p>データベース接続は「接続文字列」によって制御されます。接続文字列は、次に示すような標準的なキーと値からなります(&lt;&gt;内はデフォルト値)。</p><p>user=&lt;ユーザ名&gt; password=&lt;パスワード&gt; dbname=&lt;ユーザ名&gt; hostname=&lt;サーバ&gt; port=&lt;5432&gt;</p><p>空の接続文字列も妥当とされますし、あらゆるキーと値のペアは省略できます。接続するためには一般的にはdbnameとusernameとが最少で与えるものとなります。</p></dd><dt><span class="term">DATA</span></dt><dd><p>このパラメータの形式は "&lt;カラム名&gt; from &lt;テーブル名&gt; using srid=&lt;SRID&gt; using unique &lt;主キー&gt;"となります。ここで、カラム名は地図に描画したい空間カラムを指し、SRIDはそのカラムで使われるSRIDで、主キーはそのテーブルの主キー (またはインデックスを伴う一意の値を持つカラム)です。</p><p>"using srid"と"using unique"節は省略できます。MapServerは可能なら自動的に正しい値を判断しますが、地図を描画するサーバ上で余分なクエリを若干実行するコストがかかります。</p></dd><dt><span class="term">PROCESSING</span></dt><dd><p>接続を閉じずに複数のレイヤで再利用する場合にCLOSE_CONNECTION=DEFERとします。速度が改善します。詳細な説明については<a class="ulink" href="http://blog.cleverelephant.ca/2008/10/mapserverpostgis-performance-tips.html" target="_top">MapServer PostGIS Performance Tips</a>を参照して下さい。 </p></dd><dt><span class="term">FILTER</span></dt><dd><p>フィルタは、妥当なSQL文字列でなければなりません。この文字列は、通常はSQLクエリにおける"WHERE"に続く論理式に対応します。たとえば、6レーン以上の道路だけを描画する場合には、"num_lanes &gt;= 6"というフィルタを使います。</p></dd></dl></div></li><li class="listitem"><p>空間データベースにおいては、空間 (GiST)インデックスを、マップに描かれるレイヤ全てに構築していることを保証して下さい。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム] );</pre></li><li class="listitem"><p>MapServerを使用するレイヤのクエリを実行する場合には、"using unique"節もDATAステートメントに追加しなければなりません。</p><p>MapServerでは、クエリ実行の際には、それぞれの空間レコードを識別するための一意な識別子が必要です。MapServerのPostGISモジュールは、一意な識別子を提供するために、ユーザ指定の一意な値を使います。テーブルの主キーを使うのが最も良い方法です。</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54182904"></a>4.4.1.2. よくある質問</h4></div></div></div><div class="qandaset"><a name="idp54183544"></a><dl><dt>4.4.1.2.1. <a href="postgis_usage.html#idp54183800">EXPRESSIONをマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</a></dt><dt>4.4.1.2.2. <a href="postgis_usage.html#idp54186872">シェープファイルに使用している FILTER が、同じデータを持つPostGISテーブルでは動作しません。</a></dt><dt>4.4.1.2.3. <a href="postgis_usage.html#idp54193400">PostGISレイヤは、シェープファイルレイヤよりもはるかに遅く描画しますが、これは正常ですか?</a></dt><dt>4.4.1.2.4. <a href="postgis_usage.html#idp54196216">PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</a></dt><dt>4.4.1.2.5. <a href="postgis_usage.html#idp54199672">ジオグラフィカラム (PostGIS 1.5で機能追加)をMapServerのレイヤのソースとして使用できますか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idp54183800"></a><a name="idp54184056"></a><p><b>4.4.1.2.1.</b></p></td><td align="left" valign="top"><p><code class="varname">EXPRESSION</code>をマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>EXPRESIONで使うフィールド名は、シェープファイルと違ってPostGISの場合<span class="emphasis"><em>小文字</em></span>になります。</p><pre class="programlisting">EXPRESSION ([numlanes] &gt;= 6)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54186872"></a><a name="idp54187128"></a><p><b>4.4.1.2.2.</b></p></td><td align="left" valign="top"><p>シェープファイルに使用している FILTER が、同じデータを持つPostGISテーブルでは動作しません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>シェープファイルと違い、PostGISレイヤのフィルタはSQL構文を使います (PostGISコネクタがMapServerでレイヤを描画するために生成するSQLステートメントに追加されます)。</p><pre class="programlisting">FILTER "type = 'highway' and numlanes &gt;= 4"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54193400"></a><a name="idp54193656"></a><p><b>4.4.1.2.3.</b></p></td><td align="left" valign="top"><p>PostGISレイヤは、シェープファイルレイヤよりもはるかに遅く描画しますが、これは正常ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一般に、与えられた地図に描画する地物が多いほど、PostGISはシェープファイルより遅くなる可能性が高くなります。相対的に地物が少ない (100個台)地図では、PostGISの方が速くなることがしばしばあります。地物が少多い (1000個台)地図では、PostGISは常に遅くなります。 </p><p>重大な描画性能の問題があるようでしたら、テーブルにある空間インデックスを構築していないというのがありそうです。</p><pre class="programlisting">postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn );
postgis# VACUUM ANALYZE;</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54196216"></a><a name="idp54196472"></a><p><b>4.4.1.2.4.</b></p></td><td align="left" valign="top"><p>PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>クエリを早くするには、空間テーブルに一意なキーを持たせ、そのキーにインデックスを持たせなければなりません。</p><p><code class="varname">DATA</code>行の<code class="varname">USING UNIQUE</code>節で、MapServerで使用する一意なキーをどれにするか指定することができます。</p><pre class="programlisting">DATA "geom FROM geotable USING UNIQUE gid"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54199672"></a><a name="idp54199928"></a><p><b>4.4.1.2.5.</b></p></td><td align="left" valign="top"><p>ジオグラフィカラム (PostGIS 1.5で機能追加)をMapServerのレイヤのソースとして使用できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>できます!MapServerはジオグラフィカラムをジオメトリカラムと同じに認識します。しかし、常にSRIDを4326とします。"using srid=4326"節を<code class="varname">DATA</code>ステートメントに入れて下さい。他の部分はジオメトリの場合と同じです。</p><pre class="programlisting">DATA "geog FROM geogtable USING SRID=4326 USING UNIQUE gid"</pre></td></tr></tbody></table></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54202872"></a>4.4.1.3. 踏み込んだ使用法</h4></div></div></div><p><code class="varname">USING</code>疑似SQL節を使ってMapServerがより複雑なクエリの結果を理解できるようにするための情報を追加します。より詳しく言うと、ビューまたは副問い合わせが元テーブル (<code class="varname">DATA</code>定義で"FROM"の右にあるもの)として使われる時、MapServerが自動的に一意な識別子がそれぞれの行にあるか、また、SRIDがテーブルにあるかを判別するのは困難です。<code class="varname">USING</code>節によって、MapServerがこれらの情報を得ることができます。例を次に挙げます。</p><pre class="programlisting">DATA "geom FROM (
  SELECT
    table1.geom AS geom,
    table1.gid AS gid,
    table2.data AS data
  FROM table1
  LEFT JOIN table2
  ON table1.id = table2.id
) AS new_table USING UNIQUE gid USING SRID=4326"</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">USING UNIQUE &lt;uniqueid&gt;</span></dt><dd><p>MapServerは、マップクエリを実行する際、行識別のために、それぞれの行に一意な識別子を求めます。通常ならシステムテーブルから主キーを識別しますが、ビューや副問い合わせでは、一意性のあるカラムを自動的に知ることができません。MapServerのクエリ機能を使いたいなら、一意性のあるカラムをビューまたは副問い合わせに追加する必要があり、<code class="varname">USING UNIQUE</code>宣言を付ける必要があります。たとえば、この目的のための主キー値のテーブルでのカラム名や、結果セットで一意性が保障されたカラムを明示的にSELECTに入れることができます。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>「マップクエリ」はマップ上でクリックして、その場所におけるフィーチャーに関する情報を問い合わせる動作です。「マップクエリ」と<code class="varname">DATA</code>定義におけるSQLクエリと混同しないで下さい。</p></td></tr></table></div></dd><dt><span class="term">USING SRID=&lt;srid&gt;</span></dt><dd><p>PostGISは、MapServerに正しいデータを返すために、ジオメトリがどの空間参照系を使っているかを知る必要があります。通常は、この情報はPostGISデータベースの"geometry_columns"テーブルから得ることができます。しかし、副問い合わせやビューのような一時テーブルでは、この方法は不可能です。そこで、 <code class="varname">USING SRID=</code>オプションを使って、正しいSRIDが<code class="varname">DATA</code>定義で使われるように指定します。</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54211320"></a>4.4.1.4. 例</h4></div></div></div><p>簡単な例から始めて、ステップアップしていきましょう。次のMapServerレイヤ定義を考えて下さい。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "roads"
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  DATA "geom from roads"
  STATUS ON
  TYPE LINE
  CLASS
    STYLE
      COLOR 0 0 0
    END
  END
END</pre><p>このレイヤは"roads"テーブルにある道路ジオメトリの全部を黒線で表示するものです。</p><p>では、少なくとも1:100000にズームするまでは高速道路だけを表示したい、としましょう。次の二つのレイヤで、その効果が実現できます。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  DATA "geom from roads"
  MINSCALE 100000
  STATUS ON
  TYPE LINE
  FILTER "road_type = 'highway'"
  CLASS
    COLOR 0 0 0
  END
END
LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  DATA "geom from roads"
  MAXSCALE 100000
  STATUS ON
  TYPE LINE
  CLASSITEM road_type
  CLASS
    EXPRESSION "highway"
    STYLE
      WIDTH 2
      COLOR 255 0 0
    END
  END
  CLASS
    STYLE
      COLOR 0 0 0
    END
  END
END</pre><p>一つ目のレイヤはスケールが1:100000以上であるときに使われ、道路タイプが"highway"である道路のみ黒線で表示されます。<code class="varname">FILTER</code>オプションによって、道路タイプが"highway"の場合のみ表示することになります。</p><p>二つ目のレイヤはスケールが1:100000未満である時に使われ、"highway"は赤い二重細線で表示され、他の道路は黒線で表示されます。</p><p>さて、MapServerの機能を使うだけで、二つのおもしろいことを実行しました。しかし、<code class="varname">DATA</code>のSQLステートメントは、単純なままです。道路名が (どういう理由かは知りませんが)他のテーブルに収められていて、それのデータを取得するためにテーブルを連結して、道路のラベルを取る必要がある、とします。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  DATA "geom FROM (SELECT roads.gid AS gid, roads.geom AS geom,
        road_names.name as name FROM roads LEFT JOIN road_names ON
        roads.road_name_id = road_names.road_name_id)
        AS named_roads USING UNIQUE gid USING SRID=4326"
  MAXSCALE 20000
  STATUS ON
  TYPE ANNOTATION
  LABELITEM name
  CLASS
    LABEL
      ANGLE auto
      SIZE 8
      COLOR 0 192 0
      TYPE truetype
      FONT arial
    END
  END
END</pre><p>このANNOTAIONレイヤでは、縮尺が1:20000以下のときに、全ての道路に緑色のラベルを表示します。また、この例は、 <code class="varname">DATA</code>定義で、SQLのJOINを使用する方法も示しています。</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54217848"></a>4.4.2. Javaクライアント (JDBC)</h3></div></div></div><p>Javaクライアントは、直接的にテキスト表現として、またはPostGISに同梱されているJDBC拡張オブジェクトを使用して、PostgreSQLデータベース内にある、PostGISの"geometry"オブジェクトにアクセスできます。JDBC拡張オブジェクトを使うためには、"postgis.jar"ファイルを、JDBCドライバパッケージの"postgresql.jar"とともに、 CLASSPATHに置く必要があります。</p><pre class="programlisting">import java.sql.*;
import java.util.*;
import java.lang.*;
import org.postgis.*;

public class JavaGIS {

public static void main(String[] args) {

  java.sql.Connection conn;

  try {
    /*
    * JDBCドライバをロードして接続を確立します。
    */
    Class.forName("org.postgresql.Driver");
    String url = "jdbc:postgresql://localhost:5432/database";
    conn = DriverManager.getConnection(url, "postgres", "");
    /*
    * ジオメトリ型を接続に追加します。
    * ご注意 : addDateType()を呼ぶ前に
    *   接続をpgsql特有の接続実装にキャストしなければなりません。
    */
    ((org.postgresql.PGConnection)conn).addDataType("geometry",Class.forName("org.postgis.PGgeometry"));
    ((org.postgresql.PGConnection)conn).addDataType("box3d",Class.forName("org.postgis.PGbox3d"));
    /*
    * ステートメントの生成とSELECTクエリの実行を行います。
    */
    Statement s = conn.createStatement();
    ResultSet r = s.executeQuery("select geom,id from geomtable");
    while( r.next() ) {
      /*
      * ジオメトリをオブジェクトとして検索してジオメトリ型にキャストします。
      * オブジェクトを印字します
      */
      PGgeometry geom = (PGgeometry)r.getObject(1);
      int id = r.getInt(2);
      System.out.println("Row " + id + ":");
      System.out.println(geom.toString());
    }
    s.close();
    conn.close();
  }
catch( Exception e ) {
  e.printStackTrace();
  }
}
}</pre><p>"PGeometry"オブジェクトは、Point、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygonの各型に依存する、特定のトポロジカルジオメトリオブジェクト ("Geometory"抽象クラスの子クラス)を持つラッパオブジェクトです。</p><pre class="programlisting">PGgeometry geom = (PGgeometry)r.getObject(1);
if( geom.getType() == Geometry.POLYGON ) {
  Polygon pl = (Polygon)geom.getGeometry();
  for( int r = 0; r &lt; pl.numRings(); r++) {
    LinearRing rng = pl.getRing(r);
    System.out.println("Ring: " + r);
    for( int p = 0; p &lt; rng.numPoints(); p++ ) {
      Point pt = rng.getPoint(p);
      System.out.println("Point: " + p);
      System.out.println(pt.toString());
    }
  }
}</pre><p>幾何オブジェクトのさまざまなデータアクセサ関数に関する参照情報については、拡張オブジェクトのJavaDocをご覧下さい。</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54220792"></a>4.4.3. Cクライアント (libpq)</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#idp54221816">4.4.3.1. テキストカーソル</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#idp54222968">4.4.3.2. バイナリカーソル</a></span></dt></dl></div><p>...</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54221816"></a>4.4.3.1. テキストカーソル</h4></div></div></div><p>...</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idp54222968"></a>4.4.3.2. バイナリカーソル</h4></div></div></div><p>...</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using_raster_dataman"></a>4.5. ラスタデータの管理、クエリ、アプリケーション</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#RT_Loading_Rasters">4.5.1. ラスタのロードと生成</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#RT_Raster_Catalog">4.5.2. ラスタカタログ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#RT_Raster_Applications">4.5.3. PostGISラスタを使ったカスタムアプリケーションの構築</a></span></dt></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="RT_Loading_Rasters"></a>4.5.1. ラスタのロードと生成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#RT_Raster_Loader">4.5.1.1. raster2pgsqlを使ってラスタをロードする</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RT_Creating_Rasters">4.5.1.2. PostGISラスタ関数を用いたラスタの生成</a></span></dt></dl></div><p><code class="varname">raster2pgsql</code>ラスタローダを使ってPostGISラスタを既存のラスタファイルからロードするのは、最もよく行われます。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Raster_Loader"></a>4.5.1.1. raster2pgsqlを使ってラスタをロードする</h4></div></div></div><p><code class="varname">raster2pgsql</code>は、GDALがサポートするラスタ書式をPostGISラスタテーブルにロードするのに適切なSQLにするバイナリファイルです。ラスタのオーバビューの生成だけでなく、ラスタファイルのフォルダのロードも可能です。 </p><p>raster2pgsqlは、ほとんどの場合、PostGISの一部としてコンパイルされます (GDALライブラリをコンパイルしている場合)が、バイナリファイルによってサポートされるラスタタイプは、GDALでコンパイルされたのと同じです。raster2pgsqlがサポートするラスタタイプの一覧を得るには、<code class="varname">-G</code>スイッチを使います。この一覧は、インストールした PostGIS が提供する<a class="xref" href="RT_ST_GDALDrivers.html" title="ST_GDALDrivers">ST_GDALDrivers</a>と同じになるはずです。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>このツールの古い版では、Pythonスクリプトでした。実行ファイルに置き換えられています。Pythonスクリプトが必要な場合は、 <a class="ulink" href="http://trac.osgeo.org/gdal/wiki/frmts_wtkraster.html" target="_top">GDAL PostGIS Raster Driver Usage</a>に、Pythonの例があります。raster2pgsqlのPythonスクリプトは、今後のPostGIS rasterでは動作しないかも知れませんし、サポートされませんので、ご注意ください。 </p></td></tr></table></div><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>同じアラインメントを持つラスタの集合から特定の要素のオーバビューを生成する時、オーバビューが同じアラインメントを持たないことがあります。オーバビューが同じアラインメントを持たない例については<a class="ulink" href="http://trac.osgeo.org/postgis/ticket/1764" target="_top">http://trac.osgeo.org/postgis/ticket/1764</a>をご覧下さい。</p></td></tr></table></div><p>使用例: </p><pre class="programlisting">raster2pgsql <code class="varname">raster_options_go_here</code> <code class="varname">raster_file</code> <code class="varname">someschema</code>.<code class="varname">sometable</code> &gt; out.sql</pre><p>
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-?</span></dt><dd><p>ヘルプを表示します。引数を全く指定しない場合にも表示されます。 </p></dd><dt><span class="term">-G</span></dt><dd><p>サポートされているラスタ書式を印字します。 </p></dd><dt><span class="term">(c|a|d|p) 相互に排他的なオプションです</span></dt><dd><p>
              </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-c</span></dt><dd><p>新しいテーブルを生成し、ラスタを入れます。<span class="emphasis"><em>これがデフォルトモードです</em></span>。 </p></dd><dt><span class="term">-a</span></dt><dd><p>既存のテーブルにラスタを追加します。  </p></dd><dt><span class="term">-d</span></dt><dd><p>テーブルを削除し、新しいテーブルを生成し、ラスタを入れます。 </p></dd><dt><span class="term">-p</span></dt><dd><p>準備モード、テーブルを作るだけです。 </p></dd></dl></div><p>
            </p></dd><dt><span class="term">ラスタ処理: ラスタカタログに適切に登録するための制約の適用</span></dt><dd><p>
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-C </span></dt><dd><p>SRIDやピクセルサイズ等のラスタ制約を適用して、<code class="varname">raster_columns</code>ビューで適切な登録ができるようにします。 </p></dd><dt><span class="term">-x </span></dt><dd><p>制約の最大範囲を無効にします。-Cフラグが使われている場合のみ適用されます。 </p></dd><dt><span class="term">-r </span></dt><dd><p>正規ブロック制約 (空間的に一意で網羅タイル)を適用します。-Cフラグが使用されている場合のみ適用されます。 </p></dd></dl></div><p>
				</p></dd><dt><span class="term">ラスタ処理: 入力ラスタデータセットの操作に使われる追加的なパラメータ</span></dt><dd><p>
            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-s &lt;SRID&gt;</span></dt><dd><p>出力ラスタを指定されたSRIDにします。 指定しないか0を指定した場合、ラスタのメタデータに対して、適切なSRIDを決定するためのチェックを行います。 </p></dd><dt><span class="term">-b BAND</span></dt><dd><p>ラスタから抽出するバンドのインデクス (1始まり)。1より多いバンドを抽出するには、コンマ(,)で区切ります。指定しない場合、全てのバンドが抽出されます。 </p></dd><dt><span class="term">-t TILE_SIZE</span></dt><dd><p>行毎に挿入するラスタを切断します。<code class="varname">TILE_SIZE</code>は、「幅x高さ」で表現しますが、"auto"を指定すると、最初のラスタを使って適切なタイルサイズが計算され、全てのラスタに適用されます。 </p></dd><dt><span class="term">-P</span></dt><dd><p>全てのタイルが同じ幅と高さを持つことを保証するために、右端、下端のタイルに詰め物を施します。 </p></dd><dt><span class="term">-R, --register</span></dt><dd><p>ファイルシステム (データベース外)ラスタとして、ラスタを登録します。</p><p>データベースには、ラスタのメタデータとラスタのファイルパスのみ格納されます (ピクセルは格納されません)。</p></dd><dt><span class="term">-l <code class="varname">OVERVIEW_FACTOR</code></span></dt><dd><p>ラスタのオーバビューを生成します。一つより多い係数を用いる場合は、コンマ (,) で区切ります。オーバビューのテーブル名はo_<code class="varname">overview factor</code>_<code class="varname">table</code>となります。<code class="varname">overview factor</code>にはオーバビュー係数が入り、<code class="varname">table</code>には基底テーブル名が入ります。生成されるオーバビューはデータベースに格納され、-Rは無視されます。生成されたSQLファイルは元データのテーブルとオーバビューテーブルの両方を含むことに注意して下さい。</p></dd><dt><span class="term">-N <code class="varname">NODATA</code></span></dt><dd><p>NODATA値を持たないバンドで使用するNODATA値を設定します。 </p></dd></dl></div><p>
            </p></dd><dt><span class="term">テータベースオブジェクトの操作に使われる追加的なパラメータ</span></dt><dd><p>
              </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-f COLUMN</span></dt><dd><p>出力先ラスタカラムの名前を指定します。デフォルトは'rast'です。 </p></dd><dt><span class="term">-F</span></dt><dd><p>ファイル名でカラムを追加します。</p></dd><dt><span class="term">-n COLUMN</span></dt><dd><p>ファイル名カラムの名前を指定します。-Fを暗に含みます。</p></dd><dt><span class="term">-q</span></dt><dd><p>PostgreSQL識別子に引用符を付けます。</p></dd><dt><span class="term">-I</span></dt><dd><p>ラスタカラムにGiSTインデクスを生成します。 </p></dd><dt><span class="term">-M</span></dt><dd><p>ラスタテーブルにvacuum analyzeを行います。 </p></dd><dt><span class="term">-k</span></dt><dd><p>バンドごとのNODATA値のチェックを省略します。 </p></dd><dt><span class="term">-T <code class="varname">tablespace</code></span></dt><dd><p>生成されるテーブルのテーブルスペースを指定します。-Xフラグを併用しない場合には、インデクス (主キーを含む)はデフォルトのテーブルスペースを使用することにご注意ください。 </p></dd><dt><span class="term">-X <code class="varname">tablespace</code></span></dt><dd><p>テーブルの新しいインデクスに使うテーブル空間を指定します。主キーに適用され、-Iフラグがある場合においては空間インデクスにも適用されます。 </p></dd><dt><span class="term">-Y</span></dt><dd><p>INSERTステートメントでなくCOPYステートメントを使います。</p></dd></dl></div><p>
            </p></dd><dt><span class="term">-e</span></dt><dd><p>ステートメント毎に実行して、トランザクションを使用しないようにします。</p></dd><dt><span class="term">-E ENDIAN</span></dt><dd><p>生成されるラスタのバイナリ出力のエンディアンを制御します。XDR (訳注: ビッグエンディアン)の場合は0を、NDR (訳注:リトルエンディアン)の場合は1を、それぞれ指定します。デフォルトは1です。現時点ではNDR出力のみサポートします。</p></dd><dt><span class="term">-V <code class="varname">version</code></span></dt><dd><p>出力書式の版を指定します。デフォルトは0です。現時点では0のみサポートします。</p></dd></dl></div><p>ローダを用いて入力ファイルを100x100のタイルで生成して、データベースにアップロードする例は、次の通りです。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="varname">public.demelevation</code>でなく<code class="varname">demelevation</code> というようにスキーマ名を外すことができます。この場合、ラスタテーブルはデータベースまたユーザの指定するデフォルトのスキーマに生成されます。</p></td></tr></table></div><pre class="programlisting">raster2pgsql -s 4326 -I -C -M *.tif -F -t 100x100 public.demelevation 
&gt; elev.sql
psql -d gisdb -f elev.sql</pre><p>変換とアップロードはUNIXのパイプを使うと一回で実行できます。</p><pre class="programlisting">raster2pgsql -s 4326 -I -C -M *.tif -F -t 100x100 public.demelevation | psql -d gisdb</pre><p>マサチューセッツ州平面のメートル単位の空中写真タイルを<code class="varname">aerial</code>という名前のスキーマにロードします。 元の画像と2, 4レベルのオーバビューのテーブルとを生成します。 データ格納にCOPYを使用し (データベースに仲介ファイルなくまっすぐ入ります)、-eでトランザクションを指定しないようにします (待たずにテーブルのデータを見たい場合には良いです)。ラスタを128x128ピクセルのタイルに分解してラスタ制約を適用します。INSERTモードでなくCOPYモードを使用します。-Fで、カラム名をタイル切り出し元ファイルのファイル名にします。</p><pre class="programlisting">raster2pgsql -I -C -e -Y -F -s 26986 -t 128x128  -l 2,4 bostonaerials2008/*.jpg aerials.boston | psql -U postgres -d gisdb -h localhost -p 5432</pre><pre class="programlisting">-- サポートされているラスタタイプの一覧:
raster2pgsql -G</pre><p>-Gコマンドの出力は次のようになります。 </p><pre class="screen">Available GDAL raster formats:
  Virtual Raster
  GeoTIFF
  National Imagery Transmission Format
  Raster Product Format TOC format
  ECRG TOC format
  Erdas Imagine Images (.img)
  CEOS SAR Image
  CEOS Image
  JAXA PALSAR Product Reader (Level 1.1/1.5)
  Ground-based SAR Applications Testbed File Format (.gff)
  ELAS
  Arc/Info Binary Grid
  Arc/Info ASCII Grid
  GRASS ASCII Grid
  SDTS Raster
  DTED Elevation Raster
  Portable Network Graphics
  JPEG JFIF
  In Memory Raster
  Japanese DEM (.mem)
  Graphics Interchange Format (.gif)
  Graphics Interchange Format (.gif)
  Envisat Image Format
  Maptech BSB Nautical Charts
  X11 PixMap Format
  MS Windows Device Independent Bitmap
  SPOT DIMAP
  AirSAR Polarimetric Image
  RadarSat 2 XML Product
  PCIDSK Database File
  PCRaster Raster File
  ILWIS Raster Map
  SGI Image File Format 1.0
  SRTMHGT File Format
  Leveller heightfield
  Terragen heightfield
  USGS Astrogeology ISIS cube (Version 3)
  USGS Astrogeology ISIS cube (Version 2)
  NASA Planetary Data System
  EarthWatch .TIL
  ERMapper .ers Labelled
  NOAA Polar Orbiter Level 1b Data Set
  FIT Image
  GRIdded Binary (.grb)
  Raster Matrix Format
  EUMETSAT Archive native (.nat)
  Idrisi Raster A.1
  Intergraph Raster
  Golden Software ASCII Grid (.grd)
  Golden Software Binary Grid (.grd)
  Golden Software 7 Binary Grid (.grd)
  COSAR Annotated Binary Matrix (TerraSAR-X)
  TerraSAR-X Product
  DRDC COASP SAR Processor Raster
  R Object Data Store
  Portable Pixmap Format (netpbm)
  USGS DOQ (Old Style)
  USGS DOQ (New Style)
  ENVI .hdr Labelled
  ESRI .hdr Labelled
  Generic Binary (.hdr Labelled)
  PCI .aux Labelled
  Vexcel MFF Raster
  Vexcel MFF2 (HKV) Raster
  Fuji BAS Scanner Image
  GSC Geogrid
  EOSAT FAST Format
  VTP .bt (Binary Terrain) 1.3 Format
  Erdas .LAN/.GIS
  Convair PolGASP
  Image Data and Analysis
  NLAPS Data Format
  Erdas Imagine Raw
  DIPEx
  FARSITE v.4 Landscape File (.lcp)
  NOAA Vertical Datum .GTX
  NADCON .los/.las Datum Grid Shift
  NTv2 Datum Grid Shift
  ACE2
  Snow Data Assimilation System
  Swedish Grid RIK (.rik)
  USGS Optional ASCII DEM (and CDED)
  GeoSoft Grid Exchange Format
  Northwood Numeric Grid Format .grd/.tab
  Northwood Classified Grid Format .grc/.tab
  ARC Digitized Raster Graphics
  Standard Raster Product (ASRP/USRP)
  Magellan topo (.blx)
  SAGA GIS Binary Grid (.sdat)
  Kml Super Overlay
  ASCII Gridded XYZ
  HF2/HFZ heightfield raster
  OziExplorer Image File
  USGS LULC Composite Theme Grid
  Arc/Info Export E00 GRID
  ZMap Plus Grid
  NOAA NGS Geoid Height Grids</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Creating_Rasters"></a>4.5.1.2. PostGISラスタ関数を用いたラスタの生成</h4></div></div></div><p>データベース内でラスタやラスタテーブルを生成したい場合が多くあります。これを行うための関数が多数あります。一般的な手順は次の通りです。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>新しいラスタ行を保持するためのラスタカラムを持つテーブルを生成します。次を実行します。</p><pre class="programlisting">CREATE TABLE myrasters(rid serial primary key, rast raster);</pre></li><li class="listitem"><p>この目標で助けとなる関数は多数あります。他のラスタの派生でないラスタを生成する場合、<a class="xref" href="RT_ST_MakeEmptyRaster.html" title="ST_MakeEmptyRaster">ST_MakeEmptyRaster</a>と<a class="xref" href="RT_ST_AddBand.html" title="ST_AddBand">ST_AddBand</a>を順次実行して作業を開始します。</p><p>ジオメトリからラスタを生成することもできます。<a class="xref" href="RT_ST_AsRaster.html" title="ST_AsRaster">ST_AsRaster</a>を使います。<a class="xref" href="RT_ST_Union.html" title="ST_Union">ST_Union</a>や<a class="xref" href="RT_ST_MapAlgebraFct2.html" title="ST_MapAlgebraFct">ST_MapAlgebraFct</a>や、地図解析関数群等といった、他の関数を組み合わせる場合もあります。</p><p>既存テーブルから新しいラスタテーブルを生成するための多数の選択肢があります。たとえば、<a class="xref" href="RT_ST_Transform.html" title="ST_Transform">ST_Transform</a>を使って、既存テーブルから異なる投影法のラスタテーブルを生成します。 </p></li><li class="listitem"><p>はじめにテーブルにデータを入れたら、ラスタカラムに空間インデクスを生成したくなるでしょう。次のようにします。</p><pre class="programlisting">CREATE INDEX myrasters_rast_st_convexhull_idx ON myrasters USING gist( ST_ConvexHull(rast) );</pre><p><a class="xref" href="RT_ST_ConvexHull.html" title="ST_ConvexHull">ST_ConvexHull</a>を使用していることに注意して下さい。多くのラスタ演算子はラスタの凸包を元にしています。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>2.0より前の PostGIS ラスタは、エンベロープを基本にして、凸包ではありませんでした。空間インデクスを適切に働かせるには、エンベロープを基本にしたインデクスを削除して、凸包を元にしたインデクスに置き換えます。</p></td></tr></table></div></li><li class="listitem"><p><a class="xref" href="RT_AddRasterConstraints.html" title="AddRasterConstraints">AddRasterConstraints</a>を用いてラスタ制約を適用します。</p></li></ol></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="RT_Raster_Catalog"></a>4.5.2. ラスタカタログ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#RT_Raster_Columns">4.5.2.1. ラスタカラムカタログ</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RT_Raster_Overviews">4.5.2.2. ラスタオーバビュー</a></span></dt></dl></div><p>PostGISが生成する、二つのラスタカタログのビューがあります。両方ともラスタテーブルの制約の中に埋め込まれる情報を用いています。結果として、カタログビューは、テーブル内のラスタデータに制約が働くため、常にラスタデータとの矛盾がありません。 </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="varname">raster_columns</code> ラスタタイプのデータベースにおける全てのラスタテーブルカラムのカタログです。</p></li><li class="listitem"><p><code class="varname">raster_overviews</code> データベース内の、より詳細なテーブルのためのオーバビューを提供するラスタテーブルのカラム全てのカタログです。この種のテーブルは、ロード時に<code class="varname">-l</code>を指定した時に生成されます。</p></li></ol></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Raster_Columns"></a>4.5.2.1. ラスタカラムカタログ</h4></div></div></div><p><code class="varname">raster_columns</code>は、ラスタタイプのデータベースにおける全てのラスタテーブルカラムのカタログです。テーブルの制約を使ったビューなので、他のデータベースのバックアップからラスタテーブルをリストアしたとしても、情報は常に矛盾がありません。<code class="varname">raster_columns</code>カタログには次のカラムがあります。</p><p>ローダを使わずにテーブルを生成したり、ロード時に<code class="varname">-C</code> フラグを忘れたりした場合には、事後に<a class="xref" href="RT_AddRasterConstraints.html" title="AddRasterConstraints">AddRasterConstraints</a>で制約を強制でき、<code class="varname">raster_columns</code>カタログは、ラスタタイルの共通の情報を登録します。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">r_table_catalog</code> テーブルが存在するデータベースです。これは常に現在のデータベースを読みます。</p></li><li class="listitem"><p><code class="varname">r_table_schema</code> ラスタテーブルが属するデータベーススキーマです。</p></li><li class="listitem"><p><code class="varname">r_table_name</code> ラスタテーブルです。</p></li><li class="listitem"><p><code class="varname">r_raster_column</code> ラスタタイプである<code class="varname">r_table_name</code>テーブルのカラムです。PostGISには、一つのテーブルに複数のラスタカラムを持つことを妨げません。異なるラスタカラムを持つラスタテーブルが、ラスタカラム毎に複数回出現するテーブルを持つことができます。</p></li><li class="listitem"><p><code class="varname">srid</code> ラスタの空間参照系識別番号です。<a class="xref" href="postgis_usage.html#spatial_ref_sys" title="4.1.3.1. SPATIAL_REF_SYSテーブルと空間参照系">「SPATIAL_REF_SYSテーブルと空間参照系」</a>にあるエントリであるべきです。</p></li><li class="listitem"><p><code class="varname">scale_x</code> 地理空間座標とピクセルの間の拡大縮小係数です。これは、ラスタカラムのすべてのタイルが同じ<code class="varname">scale_x</code>を持ち、制約が適用されている場合のみ出現します。詳細情報については<a class="xref" href="RT_ST_ScaleX.html" title="ST_ScaleX">ST_ScaleX</a>を参照してください。</p></li><li class="listitem"><p><code class="varname">scale_y</code> 地理空間座標とピクセルの間の拡大縮小係数です。これは、ラスタカラムのすべてのタイルが同じ<code class="varname">scale_y</code>を持ち、制約が適用されている場合のみ出現します。詳細情報については<a class="xref" href="RT_ST_ScaleY.html" title="ST_ScaleY">ST_ScaleY</a>を参照してください。</p></li><li class="listitem"><p><code class="varname">blocksize_x</code> ラスタタイルごとの幅 (横方向のピクセル数)です。詳細情報については<a class="xref" href="RT_ST_Width.html" title="ST_Width">ST_Width</a>を参照してください。</p></li><li class="listitem"><p><code class="varname">blocksize_y</code> ラスタタイルごとの高さ (縦方向のピクセル数)です。詳細情報については<a class="xref" href="RT_ST_Height.html" title="ST_Height">ST_Height</a>を参照してください。</p></li><li class="listitem"><p><code class="varname">same_alignment</code> 全てのラスタタイルが同じアラインメントを持っているかを示す真偽値です。詳細情報については<a class="xref" href="RT_ST_SameAlignment.html" title="ST_SameAlignment">ST_SameAlignment</a>を参照してください。</p></li><li class="listitem"><p><code class="varname">regular_blocking</code> ラスタカラムが空間的に一意かつカバレッジタイルの制約を持つなら、TRUEとなります。その他の場合はFALSEになります。。</p></li><li class="listitem"><p><code class="varname">num_bands</code> ラスタ集合のタイルごとのバンド数。 <a class="xref" href="RT_ST_NumBands.html" title="ST_NumBands">ST_NumBands</a></p></li><li class="listitem"><p><code class="varname">pixel_types</code> バンドごとのピクセルタイプを定義する配列です。この配列の要素数はバンド数と同じです。pixel_typesは、<a class="xref" href="RT_ST_BandPixelType.html" title="ST_BandPixelType">ST_BandPixelType</a>で定義されるピクセルタイプの一つを取ります。</p></li><li class="listitem"><p><code class="varname">nodata_values</code> バンド毎の<code class="varname">nodata_value</code>を示す倍精度浮動小数点数の配列です。バンド数と同じ配列数となります。これらの値は、バンド毎のほとんどの処理で無視されるべきピクセル値の定義です。これは<a class="xref" href="RT_ST_BandNoDataValue.html" title="ST_BandNoDataValue">ST_BandNoDataValue</a>で得られる情報と似ています。</p></li><li class="listitem"><p><code class="varname">out_db</code> ラスタバンドデータがデータベース外で維持されているかを示す真偽値の配列です。この配列の添え字はバンド番号と同じです。</p></li><li class="listitem"><p><code class="varname">extent</code> ラスタ集合における全てのラスタ行の範囲です。集合の範囲を変更するデータを別途ロードする予定である場合、ロード前に<a class="xref" href="RT_DropRasterConstraints.html" title="DropRasterConstraints">DropRasterConstraints</a>関数を実行して、ロード後に<a class="xref" href="RT_AddRasterConstraints.html" title="AddRasterConstraints">AddRasterConstraints</a>で制約を再適用します。 </p></li><li class="listitem"><p><code class="varname">spatial_index</code> 空間インデクスを持っているかどうかを示す真偽値です。</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Raster_Overviews"></a>4.5.2.2. ラスタオーバビュー</h4></div></div></div><p><code class="varname">raster_overviews</code>は、オーバビューで使われるラスタテーブルカラムに関する情報のカタログで、オーバビューを用いる際に知っておくと便利な情報も持ちます。オーバビューテーブルは<code class="varname">raster_columns</code>と<code class="varname">raster_overviews</code>の両方のカタログに入れられます。オーバビューもラスタの一つであるのは確かですが、より高い解像度テーブルの解像度を落としたカリカチュアになるという特殊な目的を満たすためでもあるからです。ラスタをロードする際に<code class="varname">-l</code>スイッチを使うと、オーバビューが主ラスタテーブルと一緒に生成されます。もしくは、<a class="xref" href="RT_AddOverviewConstraints.html" title="AddOverviewConstraints">AddOverviewConstraints</a>を使うと手動で生成できます。</p><p>オーバビューテーブルには、他のラスタテーブルと同じ制約と、オーバビュー特有の制約となる追加情報があります。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p><code class="varname">raster_overviews</code>の情報は<code class="varname">raster_columns</code>とは重複しません。<code class="varname">raster_columns</code>にあるオーバビューテーブルに関する情報が必要な場合は、<code class="varname">raster_overviews</code>と<code class="varname">raster_columns</code>とを結合すると、必要な情報の集合を完全に取得することができます。</p></td></tr></table></div><p>オーバビューの主たる理由は次の二つです。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ズームアウトした際の地図表示を早くするために、元のテーブルの低解像度表現が一般的に使われます。</p></li><li class="listitem"><p>レコード数が少なく、ピクセル毎の適用範囲が広いため、高解像度の元テーブルより計算が一般的に早くなります。計算は高解像度テーブルより精度は落ちますが、大まかな計算には十分でありえます。</p></li></ol></div><p><code class="varname">raster_overviews</code>カタログには、次の情報のカラムがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">o_table_catalog</code> オーバビューテーブルが存在するデータベースです。常に現在のデータベースを読みます。</p></li><li class="listitem"><p><code class="varname">o_table_schema</code> オーバビューラスタテーブルが属するデータベーススキーマです。</p></li><li class="listitem"><p><code class="varname">o_table_name</code> ラスタオーバビューテーブル名です。</p></li><li class="listitem"><p><code class="varname">o_raster_column</code> オーバビューテーブル内のラスタカラムです。</p></li><li class="listitem"><p><code class="varname">r_table_catalog</code> このオーバビューの元となるラスタテーブルのデータベースです。常に現在のデータベースを読みます。</p></li><li class="listitem"><p><code class="varname">r_table_schema</code> このオーバビューの元となるラスタテーブルが属するデータベーススキーマです。</p></li><li class="listitem"><p><code class="varname">r_table_name</code> このオーバビューの元となるラスタテーブルです。</p></li><li class="listitem"><p><code class="varname">r_raster_column</code> このオーバビューの元となるラスタカラムです。</p></li><li class="listitem"><p><code class="varname">overview_factor</code> - オーバビューテーブルのピラミッドレベルです。高い数字ほど解像度が低くなります。raster2pgsqlは、画像のフォルダを渡された場合は、分割して、イメージファイルのオーバビューの計算とロードを行います。レベル1は元ファイルと同じです。レベル2は、元ファイルの4分の1になります。たとえば、5000x5000ピクセルの画像ファイルのフォルダがあるとして、125x125に分ける場合、画像ファイルごとに(5000*5000)/(125*125) = 1600行のレコードを持ち、<code class="varname">o_2</code>テーブル (レベル2)はceiling(1600/Power(2,2)) = 400行、<code class="varname">o_3</code>(レベル3)ではceiling(1600/Power(2,3) ) = 200行のレコードを持ちます。ピクセルがタイルサイズで割り切れない場合、スクラップタイル (完全には値が入っていない)が得られます。raster2pgsqlによって生成される個々のオーバビュータイルは、元となるラスタと同じピクセル数を持ち、個々のピクセルの表現範囲 (オリジナルの Power(2,overview_factor)ピクセル分)が低い解像度になっている点に注意して下さい。</p></li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="RT_Raster_Applications"></a>4.5.3. PostGISラスタを使ったカスタムアプリケーションの構築</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect3"><a href="postgis_usage.html#RT_PHP_Output">4.5.3.1. ST_AsPNG を他の関数とあわせて使った PHP 出力例</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RT_Net_Output_CS">4.5.3.2. ST_AsPNGを他の関数とあわせて使ったASP.NET C#出力例</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RT_Java_Console_App">4.5.3.3. rasterクエリを画像ファイルで出力するJavaコンソールアプリケーション</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RT_PLPython">4.5.3.4. PLPython を使って SQL を介して画像をダンプする</a></span></dt><dt><span class="sect3"><a href="postgis_usage.html#RasterOutput_PSQL">4.5.3.5. PSQLでラスタを出力する</a></span></dt></dl></div><p>PostGISラスタには、対応イメージ書式のラスタをレンダリングするSQL関数があり、レンダリングを行うための多数の選択肢があります。たとえば、<a class="ulink" href="http://www.postgresonline.com/journal/archives/244-Rendering-PostGIS-Raster-graphics-with-LibreOffice-Base-Reports.html" target="_top">Rendering PostGIS Raster graphics with LibreOffice Base Reports</a>で例を挙げている通り、OpenOffice/LibreOfficeを使うことができます。さらに、ここで示すように、幅広い言語で使うことができます。</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_PHP_Output"></a>4.5.3.1. ST_AsPNG を他の関数とあわせて使った PHP 出力例</h4></div></div></div><p>本節では、PHPのPostgreSQLドライバと<a class="xref" href="RT_ST_AsGDALRaster.html" title="ST_AsGDALRaster">ST_AsGDALRaster</a>等の関数を使って、HTML imgタグに埋め込むことができるPHPリクエストストリームにラスタの1、2、3バンドを出力する方法を示します。</p><p>サンプルクエリでは、 指定したWGS84バウンディングボックスにインタセクトするタイルを取って、 <a class="xref" href="RT_ST_Union.html" title="ST_Union">ST_Union</a>でインタセクトしたタイルを結合して全てのバンドを返し、<a class="xref" href="RT_ST_Transform.html" title="ST_Transform">ST_Transform</a>でユーザ指定投影法に変換し、<a class="xref" href="RT_ST_AsPNG.html" title="ST_AsPNG">ST_AsPNG</a>を使ってPNGで結果を出力するためのラスタ関数群全体をまとめる方法を示します。</p><p>次で示すスクリプトは、</p><pre class="programlisting">http://mywebserver/test_raster.php?srid=2249</pre><p>で、マサチューセッツ州平面 (フィート単位)のラスタ画像を取得するものです。</p><pre class="programlisting">&lt;?php
/** test_raster.phpのコンテンツ **/
$conn_str ='dbname=mydb host=localhost port=5432 user=myuser password=mypwd';
$dbconn = pg_connect($conn_str);
header('Content-Type: image/png');
/** 特定の投影法が要求された場合にはそれを使い、それ以外ではメートル単位マサチューセッツ州平面を使います **/
if (!empty( $_REQUEST['srid'] ) &amp;&amp; is_numeric( $_REQUEST['srid']) ){
                $input_srid = intval($_REQUEST['srid']);
}
else { $input_srid = 26986; }
/** set bytea_outputは、PostgreSQL 9.0以上で必要になるかも知れませんが、8.4では不要です **/
$sql = "set bytea_output='escape';
SELECT ST_AsPNG(ST_Transform(
                        ST_AddBand(ST_Union(rast,1), ARRAY[ST_Union(rast,2),ST_Union(rast,3)])
                                ,$input_srid) ) As new_rast
 FROM aerials.boston
        WHERE
         ST_Intersects(rast, ST_Transform(ST_MakeEnvelope(-71.1217, 42.227, -71.1210, 42.218,4326),26986) )";
$result = pg_query($sql);
$row = pg_fetch_row($result);
pg_free_result($result);
if ($row === false) return;
echo pg_unescape_bytea($row[0]);
?&gt;</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Net_Output_CS"></a>4.5.3.2. ST_AsPNGを他の関数とあわせて使ったASP.NET C#出力例</h4></div></div></div><p>本節では、Npgsql PostgreSQL .NETドライバと<a class="xref" href="RT_ST_AsGDALRaster.html" title="ST_AsGDALRaster">ST_AsGDALRaster</a>等の関数を使って、HTML imgタグに埋め込むことができるように、ラスタの1、2、3バンドを出力する方法を示します。</p><p>この例ではNpgsql .NET PostgreSQLドライバが必要です。最新版は<a class="ulink" href="http://npgsql.projects.postgresql.org/" target="_top">http://npgsql.projects.postgresql.org/</a>にあります。最新版をダウンロードして、ASP.NET の binフォルダに入れるだけでうまくいきます。</p><p>サンプルクエリでは、 指定したWGS84バウンディングボックスにインタセクトするタイルを取って、 <a class="xref" href="RT_ST_Union.html" title="ST_Union">ST_Union</a>でインタセクトしたタイルを結合して全てのバンドを返し、<a class="xref" href="RT_ST_Transform.html" title="ST_Transform">ST_Transform</a>でユーザ指定投影法に変換し、<a class="xref" href="RT_ST_AsPNG.html" title="ST_AsPNG">ST_AsPNG</a>を使ってPNGで結果を出力するためのラスタ関数群全体をまとめる方法を示します。</p><p>この例はC#で実装している点を除いては<a class="xref" href="postgis_usage.html#RT_PHP_Output" title="4.5.3.1. ST_AsPNG を他の関数とあわせて使った PHP 出力例">「ST_AsPNG を他の関数とあわせて使った PHP 出力例」</a>と同じです。</p><p>次で示すスクリプトは、</p><pre class="programlisting">http://mywebserver/TestRaster.ashx?srid=2249</pre><p>で、マサチューセッツ州平面 (フィート単位)のラスタ画像を取得します。</p><pre class="programlisting">-- web.config 接続文字列部 --
&lt;connectionStrings&gt;
    &lt;add name="DSN"
        connectionString="server=localhost;database=mydb;Port=5432;User Id=myuser;password=mypwd"/&gt;
&lt;/connectionStrings
&gt;</pre><pre class="programlisting">// TestRaster.ashxのコード
&lt;%@ WebHandler Language="C#" Class="TestRaster" %&gt;
using System;
using System.Data;
using System.Web;
using Npgsql;

public class TestRaster : IHttpHandler
{
        public void ProcessRequest(HttpContext context)
        {

                context.Response.ContentType = "image/png";
                context.Response.BinaryWrite(GetResults(context));

        }

        public bool IsReusable {
                get { return false; }
        }

        public byte[] GetResults(HttpContext context)
        {
                byte[] result = null;
                NpgsqlCommand command;
                string sql = null;
                int input_srid = 26986;
        try {
                    using (NpgsqlConnection conn = new NpgsqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["DSN"].ConnectionString)) {
                            conn.Open();

                if (context.Request["srid"] != null)
                {
                    input_srid = Convert.ToInt32(context.Request["srid"]);
                }
                sql = @"SELECT ST_AsPNG(
                            ST_Transform(
                                        ST_AddBand(
                                ST_Union(rast,1), ARRAY[ST_Union(rast,2),ST_Union(rast,3)])
                                                    ,:input_srid) ) As new_rast
                        FROM aerials.boston
                                WHERE
                                    ST_Intersects(rast,
                                    ST_Transform(ST_MakeEnvelope(-71.1217, 42.227, -71.1210, 42.218,4326),26986) )";
                            command = new NpgsqlCommand(sql, conn);
                command.Parameters.Add(new NpgsqlParameter("input_srid", input_srid));


                            result = (byte[]) command.ExecuteScalar();
                conn.Close();
                        }

                }
        catch (Exception ex)
        {
            result = null;
            context.Response.Write(ex.Message.Trim());
        }
                return result;
        }
}</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_Java_Console_App"></a>4.5.3.3. rasterクエリを画像ファイルで出力するJavaコンソールアプリケーション</h4></div></div></div><p>これは、一つの画像を返すクエリを取り、指定したファイルに出力する、簡単なJavaコンソールアプリケーションです。</p><p>最新のPostgreSQL JDBCドライバは<a class="ulink" href="http://jdbc.postgresql.org/download.html" target="_top">http://jdbc.postgresql.org/download.html</a>からダウンロードできます。 </p><p>あとで示すコードをコンパイルします。コマンドは次の通りです。</p><pre class="programlisting">set env CLASSPATH .:..\postgresql-9.0-801.jdbc4.jar
javac SaveQueryImage.java
jar cfm SaveQueryImage.jar Manifest.txt *.class</pre><p>次のようにコマンドラインから呼び出します。</p><pre class="programlisting">java -jar SaveQueryImage.jar "SELECT ST_AsPNG(ST_AsRaster(ST_Buffer(ST_Point(1,5),10, 'quad_segs=2'),150, 150, '8BUI',100));" "test.png" </pre><pre class="programlisting">-- Manifest.txt --
Class-Path: postgresql-9.0-801.jdbc4.jar
Main-Class: SaveQueryImage</pre><pre class="programlisting">// SaveQueryImage.javaのコード
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.io.*;

public class SaveQueryImage {
  public static void main(String[] argv) {
      System.out.println("Checking if Driver is registered with DriverManager.");

      try {
        //java.sql.DriverManager.registerDriver (new org.postgresql.Driver());
        Class.forName("org.postgresql.Driver");
      }
      catch (ClassNotFoundException cnfe) {
        System.out.println("Couldn't find the driver!");
        cnfe.printStackTrace();
        System.exit(1);
      }

      Connection conn = null;

      try {
        conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/mydb","myuser", "mypwd");
        conn.setAutoCommit(false);

        PreparedStatement sGetImg = conn.prepareStatement(argv[0]);

        ResultSet rs = sGetImg.executeQuery();

                FileOutputStream fout;
                try
                {
                        rs.next();
                        /** Output to file name requested by user **/
                        fout = new FileOutputStream(new File(argv[1]) );
                        fout.write(rs.getBytes(1));
                        fout.close();
                }
                catch(Exception e)
                {
                        System.out.println("Can't create file");
                        e.printStackTrace();
                }

        rs.close();
                sGetImg.close();
        conn.close();
      }
      catch (SQLException se) {
        System.out.println("Couldn't connect: print out a stack trace and exit.");
        se.printStackTrace();
        System.exit(1);
      }
  }
}</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RT_PLPython"></a>4.5.3.4. PLPython を使って SQL を介して画像をダンプする</h4></div></div></div><p>これは、サーバディレクトリ内でレコードごとにファイルを生成するPythonストアド関数です。plpythonが必要です。plpythonuとplpython3uの両方が正しく動作します。</p><pre class="programlisting">CREATE OR REPLACE FUNCTION write_file (param_bytes bytea, param_filepath text)
RETURNS text
AS $$
f = open(param_filepath, 'wb+')
f.write(param_bytes)
return param_filepath
$$ LANGUAGE plpythonu;</pre><pre class="programlisting">-- 5つの画像をPostgreSQLサーバに可変サイズで描きます。
-- PostgreSQLデーモンのアカウントにフォルダへの書き込み権限が必要ですので
-- ご注意ください。
-- 生成されたファイル名をエコーバックします。
 SELECT write_file(ST_AsPNG(
        ST_AsRaster(ST_Buffer(ST_Point(1,5),j*5, 'quad_segs=2'),150*j, 150*j, '8BUI',100)),
         'C:/temp/slices'|| j || '.png')
         FROM generate_series(1,5) As j;

     write_file
---------------------
 C:/temp/slices1.png
 C:/temp/slices2.png
 C:/temp/slices3.png
 C:/temp/slices4.png
 C:/temp/slices5.png
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="RasterOutput_PSQL"></a>4.5.3.5. PSQLでラスタを出力する</h4></div></div></div><p>PSQLから組み込み機能を用いてバイナリを出力するのは簡単ではありません。ここで紹介する方法は、レガシーなラージオブジェクトをサポートするPostgreSQL上に乗っかる、ちょっとしたハックです。まずは、psqlを起動して、データベースに接続します。 </p><p>この方法はPythonの場合と違い、ローカル機にファイルが生成されます</p><pre class="screen">SELECT oid, lowrite(lo_open(oid, 131072), png) As num_bytes
 FROM
 ( VALUES (lo_create(0),
   ST_AsPNG( (SELECT rast FROM aerials.boston WHERE rid=1) )
  ) ) As v(oid,png);
-- 次のような出力が得られます --
   oid   | num_bytes
---------+-----------
 2630819 |     74860

-- 続いて、oidを書き留めて、'C:/temp/aerial_smap.png'を
-- ローカルのコンピュータ上のファイルパスに置き換えたうえで、
-- 次を実行します。
 \lo_export 2630819 'C:/temp/aerial_samp.png'

-- db上のラージオブジェクトストレージからファイルを削除します
SELECT lo_unlink(2630819);
                        </pre></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Topology"></a>4.6. トポロジ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#Topology_Types">4.6.1. トポロジ型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Domains">4.6.2. トポロジドメイン</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_ManagementFunctions">4.6.3. トポロジ管理とTopoGeometry管理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_StatsManagement">4.6.4. トポロジ統計管理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Constructors">4.6.5. トポロジコンストラクタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Editing">4.6.6. トポロジエディタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Accessors">4.6.7. トポロジアクセサ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Processing">4.6.8. トポロジ処理</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Constructors">4.6.9. TopoGeometryコンストラクタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Editors">4.6.10. TopoGeometryエディタ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeom_Accessors">4.6.11. TopoGeometryアクセサ</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#TopoGeometry_Outputs">4.6.12. TopoGeometry出力</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Topology_Relationships">4.6.13. トポロジ空間関係関数</a></span></dt></dl></div><p>PostGISトポロジ型と関数は、フェイス、エッジ、ノード等のトロポジオブジェクトを管理するために使います。 </p><p>PostGIS Day Paris 2011におけるSandro Santilliさんの講演が、PostGISトポロジの概略説明として良いです。<a class="ulink" href="http://strk.keybit.net/projects/postgis/Paris2011_TopologyWithPostGIS_2_0.pdf" target="_top">Topology with PostGIS 2.0 slide deck</a>にあります。</p><p>Vincent Picavetさんはトポロジとは何か、どのように使われるか、および、対応するFOSS4Gツールに関する良い概略説明を<a class="ulink" href="https://github.com/Oslandia/presentations/blob/master/pgconf_eu_2012/pgconfeu2012_vincent_picavet_postgis_topology.pdf?raw=true" target="_top">PostGIS Topology PGConf EU 2012</a>で出しています。</p><p>トポロジベースのGISデータベースの例として<a class="ulink" href="https://www.census.gov/geo/maps-data/data/tiger.html" target="_top">US Census Topologically Integrated Geographic Encoding and Referencing System (TIGER)</a>があります。PostGISトポロジの試験がしたくて、何らかのデータが必要なら<a class="xref" href="Topology_Load_Tiger.html" title="Topology_Load_Tiger">Topology_Load_Tiger</a>をご覧下さい</p><p>PostGISトポロジモジュールは前の版にもありましたが、正式なPostGIS文書の中には入れていませんでした。PostGIS 2.0.0 では、全ての非推奨関数を無くし、知られていた使いやすさの問題を解決し、機能と関数の文書をより良くし、新しい関数を追加し、SQL-MM標準により準拠させるために、大整理を行っています。</p><p>このプロジェクトの詳細情報は<a class="ulink" href="http://trac.osgeo.org/postgis/wiki/UsersWikiPostgisTopology" target="_top">PostGIS Topology Wiki</a>にあります。</p><p>このモジュールに関する全ての関数とテーブルは、<code class="varname">topology</code>スキーマにインストールされます。</p><p>SQL/MM標準で定義される関数はST_プリフィクスを持ち、PostGIS特有の関数はこのプリフィクスを持ちません。</p><p>PostGIS 2.0以降では、トポロジ機能はデフォルトでビルドされます。<a class="xref" href="postgis_installation.html" title="第2章 PostGISインストール">2章<i>PostGISインストール</i></a>で説明されている通り、ビルド時のコンフィギュアオプション --without-topology を指定することで、無効にできます。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Types"></a>4.6.1. トポロジ型</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、PostGISトポロジでインストールされるPostgreSQLデータ型の一覧を挙げます。独自に関数をデザインする際に特に重要となる、キャストでの挙動を記述していることにご注意ください。 </p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="getfaceedges_returntype.html">getfaceedges_returntype</a></span><span class="refpurpose"> — 順列番号とエッジ番号の複合型です。<code class="varname">ST_GetFaceEdges</code>が返す型です。</span></dt><dt><span class="refentrytitle"><a href="topogeometry.html">TopoGeometry</a></span><span class="refpurpose"> — トポロジとして定義されたジオメトリを表現する型です。</span></dt><dt><span class="refentrytitle"><a href="validatetopology_returntype.html">validatetopology_returntype</a></span><span class="refpurpose"> — エラーメッセージとエラーの場所を示すid1とid2からなる複合型です。これは<code class="varname">ValidateTopology</code>が返す型です。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Domains"></a>4.6.2. トポロジドメイン</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、PostGISトポロジでインストールされるPostgreSQLドメインの一覧を挙げます。ドメインは、オブジェクト型のように扱え、関数やテーブルカラムのオブジェクトを返します。ドメインは存在するチェック制約を持つ既存の型である点で、型とは違います。 </p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="topoelement.html">TopoElement</a></span><span class="refpurpose"> — 二つの整数の配列で、通常TopoGeometry要素を識別するために使われます。</span></dt><dt><span class="refentrytitle"><a href="topoelementarray.html">TopoElementArray</a></span><span class="refpurpose"> — TopoElementオブジェクトの配列</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_ManagementFunctions"></a>4.6.3. トポロジ管理とTopoGeometry管理</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、新しいトポロジスキーマの構築、トポロジの評価、TopoGeometryカラムの管理のためのトポロジ関数の一覧を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="AddTopoGeometryColumn.html">AddTopoGeometryColumn</a></span><span class="refpurpose"> — 既存のテーブルにTopoGeometryカラムを追加し、topology.layer内に新しいレイヤとして新しいカラムを登録して、新しい layer_id を返します。</span></dt><dt><span class="refentrytitle"><a href="DropTopology.html">DropTopology</a></span><span class="refpurpose"> — 使用上の注意: この関数によって、トポロジスキーマが削除され、topology.topologyテーブルからの参照が削除され、geometry_columnsテーブルから削除対象スキーマ内のテーブルへの参照が削除されます。</span></dt><dt><span class="refentrytitle"><a href="DropTopoGeometryColumn.html">DropTopoGeometryColumn</a></span><span class="refpurpose"> — <code class="varname">schema_name</code>で指定されたスキーマ内にある<code class="varname">table_name</code>で指定されたテーブルからTopoGeometryカラムを削除し、topology.layerテーブルにある登録を解除します。</span></dt><dt><span class="refentrytitle"><a href="Populate_Topology_Layer.html">Populate_Topology_Layer</a></span><span class="refpurpose"> — テーブルからメタデータを読み、topology.layerテーブルに不足しているものを追加します。</span></dt><dt><span class="refentrytitle"><a href="TopologySummary.html">TopologySummary</a></span><span class="refpurpose"> — トポロジ名を取り、トポロジ内のオブジェクトの型に関する概要の全体を提供します。</span></dt><dt><span class="refentrytitle"><a href="ValidateTopology.html">ValidateTopology</a></span><span class="refpurpose"> — トポロジの問題についての詳細を示すvalidatetopology_returntypeの集合を返します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_StatsManagement"></a>4.6.4. トポロジ統計管理</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、トポロジ構築時のデータベース統計の管理について説明します。 </p></div></div></div></div><p>トポロジに要素を追加すると、そのトリガとして、分割されることになる既存のエッジを探索し、ノードを追加し、新しいラインでノードを作成するエッジを更新するために多数のデータベースクエリが発生します。このため、トポロジテーブル内のデータに関する統計情報が最新の状態になっているなら、統計情報を使うと便利です。 </p><p>PostGISトポロジーの追加や編集の関数は、自動的に統計情報を更新することはありません。トポロジにおいて逐次変更していては、統計情報の更新が過剰になるためです。処理は呼び出し元の義務となっています。 </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>自動VACUUMによる統計情報更新では、自動VACUUM完了前に開始されたトランザクションからは*見えません*。長時間実行されるトランザクションが更新された統計情報を使うには、自身に対してANALYZEを実行する必要があります。 </p></td></tr></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Constructors"></a>4.6.5. トポロジコンストラクタ</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、新しいトポロジを生成するトポロジ関数を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="CreateTopology.html">CreateTopology</a></span><span class="refpurpose"> — 新しいトポロジスキーマを生成し、新しいスキーマをtopology.topologyテーブルに登録します。</span></dt><dt><span class="refentrytitle"><a href="CopyTopology.html">CopyTopology</a></span><span class="refpurpose"> — トポロジ構造 (ノード、エッジ、フェイス、レイヤ、TopoGeometry)を複写します。</span></dt><dt><span class="refentrytitle"><a href="ST_InitTopoGeo.html">ST_InitTopoGeo</a></span><span class="refpurpose"> — 新しいトポロジスキーマを生成し、topology.topologyテーブルに新しいスキーマを登録し、処理の概要を表示します。</span></dt><dt><span class="refentrytitle"><a href="ST_CreateTopoGeo.html">ST_CreateTopoGeo</a></span><span class="refpurpose"> — 空のトポロジにジオメトリのコレクションを追加し、成否を示すメッセージを返します。  </span></dt><dt><span class="refentrytitle"><a href="TopoGeo_AddPoint.html">TopoGeo_AddPoint</a></span><span class="refpurpose"> — 許容差を使って既存のトポロジにポイントを追加し、可能ならエッジを分割します。  </span></dt><dt><span class="refentrytitle"><a href="TopoGeo_AddLineString.html">TopoGeo_AddLineString</a></span><span class="refpurpose"> — 許容差を使って既存のトポロジにラインストリングを追加し、可能ならエッジ/フェイスを分割します。エッジ識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="TopoGeo_AddPolygon.html">TopoGeo_AddPolygon</a></span><span class="refpurpose"> — 許容差を使って既存のトポロジにラインストリングを追加し、可能ならエッジ/フェイスを分割します。エッジ識別番号を返します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Editing"></a>4.6.6. トポロジエディタ</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、エッジ、フェイス、ノードの追加、移動、削除、分割に関する関数を挙げます。本節の関数はすべてISO SQL/MMで定義されています。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="ST_AddIsoNode.html">ST_AddIsoNode</a></span><span class="refpurpose"> — フェイスに孤立ノードを追加し、新しいノードの識別番号を返します。フェイスがNULLの場合でもノードは生成されます。</span></dt><dt><span class="refentrytitle"><a href="ST_AddIsoEdge.html">ST_AddIsoEdge</a></span><span class="refpurpose"> — <code class="varname">anode</code>と<code class="varname">anothernode</code>で指定される二つの既存孤立ノードを接続するトポロジに、ジオメトリ<code class="varname">alinestring</code>で定義される孤立エッジを追加し、新しいエッジの識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="ST_AddEdgeNewFaces.html">ST_AddEdgeNewFaces</a></span><span class="refpurpose"> — 新しいエッジを追加します。新しいエッジがフェイスを分割する場合には、もとのフェイスを削除して、分割した二つのフェイスに置き換えます。</span></dt><dt><span class="refentrytitle"><a href="ST_AddEdgeModFace.html">ST_AddEdgeModFace</a></span><span class="refpurpose"> — 新しいエッジを追加します。新しいエッジがフェイスを分割する場合には、もとのフェイスを編集し、一つのフェイスを追加します。</span></dt><dt><span class="refentrytitle"><a href="ST_RemEdgeNewFace.html">ST_RemEdgeNewFace</a></span><span class="refpurpose"> — エッジを削除し、消去対象エッジでフェイスが二つに分割されているなら元の二つのフェイスを削除し、一つの新しいフェイスに置き換えます。 </span></dt><dt><span class="refentrytitle"><a href="ST_RemEdgeModFace.html">ST_RemEdgeModFace</a></span><span class="refpurpose"> — エッジを削除し、削除対象エッジでフェイスが二つに分割されているなら、両方の空間をとるため、一つを削除して、もう一つを編集します。 </span></dt><dt><span class="refentrytitle"><a href="ST_ChangeEdgeGeom.html">ST_ChangeEdgeGeom</a></span><span class="refpurpose"> — トポロジ構造に影響を与えることなくエッジの形状を変更します。 </span></dt><dt><span class="refentrytitle"><a href="ST_ModEdgeSplit.html">ST_ModEdgeSplit</a></span><span class="refpurpose"> — 既存のエッジに沿って新しいノードを生成してエッジを分割します。もとのエッジは変更され、新しいエッジが一つ追加されます。</span></dt><dt><span class="refentrytitle"><a href="ST_ModEdgeHeal.html">ST_ModEdgeHeal</a></span><span class="refpurpose"> — 二つのエッジについて、接続しているノードを削除して修復します。1番目のエッジを編集して、2番目のエッジを削除します。削除されたノードの識別番号を返します。 </span></dt><dt><span class="refentrytitle"><a href="ST_NewEdgeHeal.html">ST_NewEdgeHeal</a></span><span class="refpurpose"> — 二つのエッジについて、接続しているノードを削除して修復します。両方のエッジを削除し、1番目のエッジと同じ方向のエッジに置き換えます。 </span></dt><dt><span class="refentrytitle"><a href="ST_MoveIsoNode.html">ST_MoveIsoNode</a></span><span class="refpurpose"> — トポロジ内の孤立ノードを別の位置に移動させます。新しい<code class="varname">apoint</code>ジオメトリがノードとして存在しているなら、エラーが投げられます。移動に関する説明を返します。</span></dt><dt><span class="refentrytitle"><a href="ST_NewEdgesSplit.html">ST_NewEdgesSplit</a></span><span class="refpurpose"> — 新しいノードを既存のエッジに沿って作成して、エッジを分割します。もとのエッジは削除され、二つのエッジに置き換えられます。二つの新しいエッジに接続する新しいノードの識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="ST_RemoveIsoNode.html">ST_RemoveIsoNode</a></span><span class="refpurpose"> — 孤立ノードを削除し、実行結果が返されます。ノードが孤立していない (エッジの始端または終端である)場合には、例外が投げられます。</span></dt><dt><span class="refentrytitle"><a href="ST_RemoveIsoEdge.html">ST_RemoveIsoEdge</a></span><span class="refpurpose"> — 孤立エッジを削除し、実行結果の記述を返します。エッジが孤立していない場合には、例外が投げられます。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Accessors"></a>4.6.7. トポロジアクセサ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="GetEdgeByPoint.html">GetEdgeByPoint</a></span><span class="refpurpose"> — 与えられたポイントにインタセクトするエッジの識別番号を探索します。</span></dt><dt><span class="refentrytitle"><a href="GetFaceByPoint.html">GetFaceByPoint</a></span><span class="refpurpose"> — 与えられたポイントにインタセクトするフェイスの識別番号を探索します。</span></dt><dt><span class="refentrytitle"><a href="GetNodeByPoint.html">GetNodeByPoint</a></span><span class="refpurpose"> — ポイント位置にあるノードの識別番号を探索します。</span></dt><dt><span class="refentrytitle"><a href="GetTopologyID.html">GetTopologyID</a></span><span class="refpurpose"> — トポロジ名からtopology.topologyテーブル内にあるトポロジの識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="GetTopologySRID.html">GetTopologySRID</a></span><span class="refpurpose"> — トポロジ名からtopology.topologyテーブル内にあるトポロジのSRIDを返します。</span></dt><dt><span class="refentrytitle"><a href="GetTopologyName.html">GetTopologyName</a></span><span class="refpurpose"> — 識別番号からトポロジ (スキーマ)の名前を返します。</span></dt><dt><span class="refentrytitle"><a href="ST_GetFaceEdges.html">ST_GetFaceEdges</a></span><span class="refpurpose"> — 順序番号を含む、<code class="varname">aface</code>の境界となる、整列したエッジの集合を返します。</span></dt><dt><span class="refentrytitle"><a href="ST_GetFaceGeometry.html">ST_GetFaceGeometry</a></span><span class="refpurpose"> — 指定されたトポロジの中の、フェイス識別番号で指定されたポリゴンを返します。</span></dt><dt><span class="refentrytitle"><a href="GetRingEdges.html">GetRingEdges</a></span><span class="refpurpose"> — 与えられた側を歩いて得られた、正負符号付きエッジ識別番号の集合を、順序通りに返します。 </span></dt><dt><span class="refentrytitle"><a href="GetNodeEdges.html">GetNodeEdges</a></span><span class="refpurpose"> — 与えられたノードに付随するエッジの集合を整列して返します。 </span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Processing"></a>4.6.8. トポロジ処理</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、非標準の手法でのトポロジ処理の関数を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="TopologyPolygonize.html">Polygonize</a></span><span class="refpurpose"> — トポロジエッジで定義される全てのフェイスを探索し、追加します。</span></dt><dt><span class="refentrytitle"><a href="AddNode.html">AddNode</a></span><span class="refpurpose"> — 指定したトポロジスキーマのノードテーブルにポイントノードを追加し、新しいノードの識別番号を返します。指定したポイントに既にノードがある場合は既存のノード識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="AddEdge.html">AddEdge</a></span><span class="refpurpose"> — 指定したラインストリングジオメトリを使って、ラインストリングエッジをエッジテーブルに追加し、指定したトポロジスキーマの始点終点をポイントノードテーブルに追加し、新しい (または既存の)エッジの識別番号を返します。</span></dt><dt><span class="refentrytitle"><a href="AddFace.html">AddFace</a></span><span class="refpurpose"> — フェイスプリミティブをトポロジに登録し、その識別番号を得ます。 </span></dt><dt><span class="refentrytitle"><a href="TP_ST_Simplify.html">ST_Simplify</a></span><span class="refpurpose"> — 与えたTopoGeometryを「シンプル化した」ジオメトリを返します。ダグラス-ポーカーのアルゴリズムを使います。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="TopoGeometry_Constructors"></a>4.6.9. TopoGeometryコンストラクタ</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、新しいTopoGeometryを生成するトポロジ関数を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="CreateTopoGeom.html">CreateTopoGeom</a></span><span class="refpurpose"> — 新しいTopoGeometryオブジェクトをtopoエレメント配列から生成します - tg_type: 1:[multi]point, 2:[multi]line, 3:[multi]poly, 4:collection</span></dt><dt><span class="refentrytitle"><a href="toTopoGeom.html">toTopoGeom</a></span><span class="refpurpose"> — 単純なジオメトリからTopoGeometryを生成します。</span></dt><dt><span class="refentrytitle"><a href="TopoElementArray_Agg.html">TopoElementArray_Agg</a></span><span class="refpurpose"> — element_idとタイプの配列 (topoelements)からなる<code class="varname">topoelementarray</code>を返します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="TopoGeometry_Editors"></a>4.6.10. TopoGeometryエディタ</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、既存のTopoGeometryを編集する関数を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="clearTopoGeom.html">clearTopoGeom</a></span><span class="refpurpose"> — TopoGeometryの中身を消去します。</span></dt><dt><span class="refentrytitle"><a href="TopoGeom_addElement.html">TopoGeom_addElement</a></span><span class="refpurpose"> — TopoGeometryの定義に要素を追加します。</span></dt><dt><span class="refentrytitle"><a href="TopoGeom_remElement.html">TopoGeom_remElement</a></span><span class="refpurpose"> — TopoGeometryの定義から要素を削除します。</span></dt><dt><span class="refentrytitle"><a href="toTopoGeom_editor_proxy.html">toTopoGeom</a></span><span class="refpurpose"> — ジオメトリの形状を既存のTopoGeometryに追加します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="TopoGeom_Accessors"></a>4.6.11. TopoGeometryアクセサ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="GetTopoGeomElementArray.html">GetTopoGeomElementArray</a></span><span class="refpurpose"> — 与えられたTopoGeometry (プリミティブ要素)のトポロジ要素とタイプを含む<code class="varname">topoelementarray</code> (topoelementの配列)を返します。</span></dt><dt><span class="refentrytitle"><a href="GetTopoGeomElements.html">GetTopoGeomElements</a></span><span class="refpurpose"> — 与えられたTopoGeometry (プリミティブ要素)の、トポロジのelement_idとelement_typeを含む<code class="varname">topoelement</code>オブジェクトの集合を返します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="TopoGeometry_Outputs"></a>4.6.12. TopoGeometry出力</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="AsGML.html">AsGML</a></span><span class="refpurpose"> — TopoGeometryのGML表現を返します。</span></dt><dt><span class="refentrytitle"><a href="AsTopoJSON.html">AsTopoJSON</a></span><span class="refpurpose"> — opoGeometryのTopoJSON表現を返します。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Topology_Relationships"></a>4.6.13. トポロジ空間関係関数</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、TopoGeometryとトポロジプリミティブとの間の関係を見るトポロジ関数の一覧を挙げます。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="TG_Equals.html">Equals</a></span><span class="refpurpose"> — 二つのTopoGeometryが同じトポロジプリミティブで成っている場合にtrueを返します。</span></dt><dt><span class="refentrytitle"><a href="TG_Intersects.html">Intersects</a></span><span class="refpurpose"> — 二つのTopoGeometryからのプリミティブの組がインタセクトする場合にtrueを返します。</span></dt></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Address_Standardizer"></a>4.7. 住所標準化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Basics">4.7.1. パーサの動作</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Types">4.7.2. 住所標準化の型</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Tables">4.7.3. 住所標準化テーブル</a></span></dt><dt><span class="sect2"><a href="postgis_usage.html#Address_Standardizer_Functions">4.7.4. 住所標準化関数</a></span></dt></dl></div><p>これは、<a class="ulink" href="http://www.pagcgeo.org/docs/html/pagc-11.html" target="_top">PAGC standardizer</a>から分かれたものです (オリジナルのコードは<a class="ulink" href="http://sourceforge.net/p/pagc/code/360/tree/branches/sew-refactor/postgresql" target="_top">PAGC PostgreSQL Address Standardizer</a>にあります)。 </p><p>住所標準化は単一行の住所のパーサで、入力に住所を取り、テーブルに保存された規則と、補助テーブルlex (lexicon, 語彙)およびgaz (gazetteer, 地名集)とを基に正規化します。</p><p>コードは、<code class="code">address_standardizer</code>という名前の、1つのPostgreSQLエクステンションとしてビルドされます。<code class="code">CREATE EXTENSION address_standardizer;</code>でインストールできます。address_standardizerエクステンションとともに、<code class="code">address_standardizer_data_us</code>というサンプルデータのエクステンションがビルドされます。これには、アメリカのgaz, lexとrulesテーブルデータがあります。このエクステンションは<code class="code">CREATE EXTENSION address_standardizer_data_us;</code>でインストールできます。</p><p>このエクステンションのコードはPostGISの<code class="filename">extensions/address_standardizer</code>内にあり、現在は自己充足しています。</p><p>インストール手順については、<a class="xref" href="postgis_installation.html#installing_pagc_address_standardizer" title="2.3. PAGC住所標準化ツールのインストールと使用">「PAGC住所標準化ツールのインストールと使用」</a>を参照してください。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Address_Standardizer_Basics"></a>4.7.1. パーサの動作</h3></div></div></div><p>パーサは右から左に見ます。最初に郵便番号、州/県、市のMACRO (訳注: マクロ)要素を見ます。その後、番地または交差点もしくはランドマークを扱う場合には、MICRO (訳注: マイクロ)要素を見ます。現在は、国別コードや国名を見ませんが、将来的には導入できると思います。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">国別コード</span></dt><dd><p>USまたはCAを仮定します。郵便番号か州/県で米国かカナダを分けますが、判別できない場合は米国とします。</p></dd><dt><span class="term">郵便番号</span></dt><dd><p>Perl互換の正規表現を使用して認識します。正規表現は現在はparseaddress-api.cにあり、必要な際の変更は比較的簡単です。</p></dd><dt><span class="term">州/県</span></dt><dd><p>Perl互換の正規表現を使用して認識します。正規表現は現在はparseaddress-api.cにありますが、将来的には、メンテナンスを簡単にするためにインクルードファイルに移動するかも知れません。</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Address_Standardizer_Types"></a>4.7.2. 住所標準化の型</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では住所標準化でインストールされたPostgreSQLデータ型の一覧を挙げます。独自関数をデザインする時に特に重要となるキャストの振る舞いを記述しています。 </p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="stdaddr.html">stdaddr</a></span><span class="refpurpose"> — 住所の要素からなる複合型です。<code class="varname">standardize_address</code>関数が返す型です。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Address_Standardizer_Tables"></a>4.7.3. 住所標準化テーブル</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>本節では、住所標準化が住所の正規化に使うPostgreSQLテーブルの書式を挙げます。これらのテーブルはここで参照している名前と同じである必要はありません。例または独自ジオコーダのために、国ごとに異なるlex (lexicon, 語彙)、gaz (gazetteer, 地名集)およびrulesテーブルを持つことができます。これらのテーブルの名前は、住所標準化関数に渡されます。 </p><p>同梱されている<code class="varname">address_standardizer_data_us</code>エクステンションには、米国の住所標準化のためのデータがあります。</p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="rulestab.html">規則テーブル</a></span><span class="refpurpose"> — 規則テーブルには、住所入力順列トークンから標準化した出力順列への対応付けに関する規則の集合が入ります。それぞれの規則は、入力トークン、-1 (終端)、出力トークン、-1、規則の種類を示す数字、規則の階級、からなります。</span></dt><dt><span class="refentrytitle"><a href="lextab.html">lexテーブル</a></span><span class="refpurpose"> — lexテーブルは英数字の入力をクラス分けして (a) 入力トークン (「入力トークン」 参照)と (b)  標準化表現 とに関連付けます。</span></dt><dt><span class="refentrytitle"><a href="gaztab.html">gaz table</a></span><span class="refpurpose"> — gazテーブルは、地名を標準化し、入力と、(a)入力トークン (「入力トークン」を参照して下さい)および (b) 標準化された表現とを関連付けるために使われます。</span></dt></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Address_Standardizer_Functions"></a>4.7.4. 住所標準化関数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="parse_address.html">parse_address</a></span><span class="refpurpose"> — 1行の住所を取り、分割します。</span></dt><dt><span class="refentrytitle"><a href="standardize_address.html">standardize_address</a></span><span class="refpurpose"> — lexテーブル、gazテーブルおよび規則テーブルを使って、入力住所をstdaddr形式で返します。</span></dt></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Extras"></a>4.8. PostGIS追加機能</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgis_usage.html#Tiger_Geocoder">4.8.1. Tigerジオコーダ</a></span></dt></dl></div><p>本章では、PostGISのソースアーカイブとソースレポジトリのextrasフォルダにある機能を記述します。 これらは必ずPostGISバイナリ版に同梱されているものではありませんが、通常は実行可能なplpgsqlベースのものまたは標準的なシェルスクリプトです。</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="Tiger_Geocoder"></a>4.8.1. Tigerジオコーダ</h3></div><div><div class="abstract"><div class="abstract-title">概要</div><p>米国国勢調査局が公開している<a class="ulink" href="http://www.census.gov/geo/www/tiger/" target="_top">TIGER (Topologically Integrated Geographic Encoding and Referencing system ) / Line and Master Address database export</a>で動作するよう書かれた、PL/pgSQLベースのジオコーダです。 </p><p>データローダ機能、住所正規化、住所ジオコーダおよび逆ジオコーダ、の四つの要素があります。 </p><p>米国のための設計ですが、概念および機能の多くは適用可能で、他国の住所と道路ネットワークで動作するように適合させることができます (訳注: 日本の地名については未知です)。</p><p>Tiger関連の関数、道路型前置辞・道路型後置辞・州といった再利用可能な参照データ、データロード管理のための様々な制御テーブル、全てのロードされたテーブルが継承するスケルトンテーブル、を収容するための<code class="varname">tiger</code>というスキーマが、スクリプトによって作成されます。</p><p><code class="varname">tiger_data</code>という、もう一つのスキーマが作られます。ここに、ローダが米国国勢調査サイトからダウンロードしてデータベースにロードした州ごとの全ての国勢調査データが収容されます。現在のモデルでは、州ごとのテーブルは、<code class="varname">ma_addr</code>や<code class="varname">ma_edges</code>といったように名前の先頭に州コードを付けていて、州データのみに強制する制約が付いています。これらのテーブルは<code class="varname">tiger schema</code>にある<code class="varname">addr</code>, <code class="varname">faces</code>, <code class="varname">edges</code>等から継承されています。 </p><p>全てのジオコード関数は基底テーブルを参照するだけです。そのため、<code class="varname">tiger_data</code>データスキーマやそのデータを他のスキーマに分割できないという条件はありません。例えば、州ごとに異なるスキーマにしても、<code class="varname">tiger</code>内のテーブルから継承されているなら使用可能です。</p><p>お手持ちのデータベース内のエクステンションを有効にし、使用するデータをロードする方法については、<a class="xref" href="postgis_installation.html#install_tiger_geocoder_extension" title="2.4.1. TigerジオコーダをPostGISデータベースで有効にする: エクステンションを使用">「TigerジオコーダをPostGISデータベースで有効にする: エクステンションを使用」</a>を参照して下さい。</p><p> </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Tigerジオコーダ (tiger_2010)を使っている場合には、extras/tiger内にあるupgrade_geocoder.bat / .sh を使ってアップグレードすることができます。<code class="varname">tiger_2010</code>と<code class="varname">tiger_2011以上</code>での大きな変更点は、<code class="varname">county</code>テーブルと<code class="varname">state</code>テーブルが、stateごとに出現することがなくなっています。tiger_2010からのデータを持っていて、tiger_2015に置き換えたい場合には、<a class="xref" href="postgis_installation.html#upgrade_tiger_geocoder" title="2.4.5. Tigerジオコーダのアップグレード">「Tigerジオコーダのアップグレード」</a>を参照して下さい。 </p></td></tr></table></div><p>

              </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>PostGIS 2.2.0での新規機能は、Tiger 2015データに対応したことと、住所標準化がPostGISの一部に取り入れられたことです。</p><p>PostGIS 2.1.0での新規機能は、PostgreSQL 9.1以上では、TigerジオコーダをPostgreSQLエクステンションモデルでインストールすることができるようになったことです。詳細については<a class="xref" href="postgis_installation.html#install_tiger_geocoder_extension" title="2.4.1. TigerジオコーダをPostGISデータベースで有効にする: エクステンションを使用">「TigerジオコーダをPostGISデータベースで有効にする: エクステンションを使用」</a>を参照して下さい。</p></td></tr></table></div><p>
              </p><p>PostGISが用意している<a class="xref" href="Normalize_Address.html" title="Normalize_Address">Normalize_Address</a>の代替として<a class="xref" href="Pagc_Normalize_Address.html" title="Pagc_Normalize_Address文字列のストリート住所を与えると、道路後置辞、前置辞、標準タイプ、番地、ストリート名等を複数フィールドに分解して持つnorm_addy複合型を返します。この関数は、tiger_geocoder同梱のルックアップテーブルだけを使います (Tigerデータは不要です)。住所標準化エクステンションが必要です。">Pagc_Normalize_Address文字列のストリート住所を与えると、道路後置辞、前置辞、標準タイプ、番地、ストリート名等を複数フィールドに分解して持つ<code class="varname">norm_addy</code>複合型を返します。この関数は、tiger_geocoder同梱のルックアップテーブルだけを使います (Tigerデータは不要です)。住所標準化エクステンションが必要です。</a>関数があります。コンパイルとインストールの方法については、<a class="xref" href="postgis_installation.html#installing_pagc_address_standardizer" title="2.3. PAGC住所標準化ツールのインストールと使用">「PAGC住所標準化ツールのインストールと使用」</a>を参照して下さい。</p><p>設計:</p><p>このプロジェクトの目標は、任意の米国住所文字列を処理し、正規化したTiger国勢調査データを使ってポイントジオメトリを生成し、与えられた住所の位置や、位置のもっともらしさを反映した評価値を算出する、十分に実用的なジオコーダを構築することです。なお、評価値は高いほど悪い結果とします。</p><p>PostGIS 2.0.0で導入された<code class="varname">reverse_geocode</code>は、GPS位置のストリート住所と交差点を得るのに便利です。</p><p>ジオコーダは、PostGISに慣れている方ならだれでもインストールと使用が容易な程度に単純であるべきで、PostGISがサポートする全てのプラットフォームで簡便にインストール、使用ができるべきです。</p><p>書式や綴りの誤りがあっても確実に機能するための十分なロバスト性があるべきです。</p><p>将来のデータ更新が使えるか、最小のプログラムの変更で他のデータが使えるための十分な拡張性もあるべきです。</p><p>
                </p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>関数が確実に動作するために、<code class="varname">tiger</code>スキーマは、データベース検索パスに追加されていなければなりません。</p></td></tr></table></div><p>
            </p></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="Drop_Indexes_Generate_Script.html">Drop_Indexes_Generate_Script</a></span><span class="refpurpose"> — tigerスキーマとユーザが指定したスキーマ上の、全ての主キーでなく、かつユニークでないインデックスを削除します。スキーマを指定しない場合のデフォルトスキーマは、<code class="varname">tiger_data</code>です。</span></dt><dt><span class="refentrytitle"><a href="Drop_Nation_Tables_Generate_Script.html">Drop_Nation_Tables_Generate_Script</a></span><span class="refpurpose"> — 指定したスキーマ内のテーブルのうち、<code class="varname">county_all</code>, <code class="varname">state_all</code>または、<code class="varname">county</code> or <code class="varname">state</code>を削除するスクリプトを生成します。</span></dt><dt><span class="refentrytitle"><a href="Drop_State_Tables_Generate_Script.html">Drop_State_Tables_Generate_Script</a></span><span class="refpurpose"> — 指定したスキーマ内の、名前が州コードから始まるテーブルを全て削除するスクリプトを生成します。スキーマが指定されていない場合のデフォルトスキーマは<code class="varname">tiger_data</code>です。</span></dt><dt><span class="refentrytitle"><a href="Geocode.html">Geocode</a></span><span class="refpurpose"> — 住所を文字列 (もしくは他の正規化された住所)として取り、可能性のある位置の集合を返します。返される集合の要素は、NAD 83経度緯度のポイントジオメトリ、正規化された住所と評価値を持ちます。評価値は低いほど可能性が高いことを示しています。結果は評価値の低い順に並べ替えられます。オプションにmax_result (最大結果数、デフォルトは10)とrestrict_region (制限領域、デフォルトはNULL)を渡すことができます。</span></dt><dt><span class="refentrytitle"><a href="Geocode_Intersection.html">Geocode_Intersection</a></span><span class="refpurpose"> — インタセクトする二つのストリート、州コード、市名、郵便番号を引数に取り、最初の交差点の可能性のある位置の集合を出力します。geomoutにNAD83経度緯度のポイント、<code class="varname">normalized_address</code>にそれぞれの位置、ratingに評価値がそれぞれ入ります。評価値が低いほど合致度が高くなります。結果は評価値の低い順にソートされます。最大結果数を渡すことができ、デフォルトは10です。Tigerデータ (エッジ、フェイス、住所)と、PostgreSQLあいまい文字列合致 (soundex, levenshtein)を使います。</span></dt><dt><span class="refentrytitle"><a href="Get_Geocode_Setting.html">Get_Geocode_Setting</a></span><span class="refpurpose"> — tiger.geocode_settingsテーブルに格納されている設定のうち指定したものの値を返します。</span></dt><dt><span class="refentrytitle"><a href="Get_Tract.html">Get_Tract</a></span><span class="refpurpose"> — ジオメトリで指定した位置の米国国勢調査統計区またはtractテーブルのフィールドを返します。デフォルトでは、統計区の短縮名を返します。</span></dt><dt><span class="refentrytitle"><a href="Install_Missing_Indexes.html">Install_Missing_Indexes</a></span><span class="refpurpose"> — ジオコーダで結合や検索条件に使われ、インデックスが付いていなキーカラムを持つ全てのテーブルを探し、インデックスを追加します。</span></dt><dt><span class="refentrytitle"><a href="Loader_Generate_Census_Script.html">Loader_Generate_Census_Script</a></span><span class="refpurpose"> — 指定した州について、tract (統計区)、bg (block group, 細分区グループ)、tabblock (ブロック)をダウンロードし、<code class="varname">tiger_data</code>に格納するための、指定したプラットフォーム用のシェルスクリプトを生成します。行ごとに州ごとのスクリプトが返されます。</span></dt><dt><span class="refentrytitle"><a href="Loader_Generate_Script.html">Loader_Generate_Script</a></span><span class="refpurpose"> — 指定したプラットフォーム用の、指定した州のTigerデータをダウンロードし、格納準備を行い、<code class="varname">tiger_data</code>スキーマに格納するシェルスクリプトを生成します。行ごとに州ごとのスクリプトが返ります。最新版ではTiger 2010のデータ構造変更に対応していて、国勢統計区、細分区グループ、細分区 (tabblocks)テーブルをダウンロードすることができます。</span></dt><dt><span class="refentrytitle"><a href="Loader_Generate_Nation_Script.html">Loader_Generate_Nation_Script</a></span><span class="refpurpose"> — 指定したプラットフォーム用の、国と州のルックアップテーブルをロードするシェルスクリプトを生成します。</span></dt><dt><span class="refentrytitle"><a href="Missing_Indexes_Generate_Script.html">Missing_Indexes_Generate_Script</a></span><span class="refpurpose"> — ジオコーダで結合に使われるキーカラムを持ち、インデックスが付いていないキーカラムを持つすべてのテーブルを検索し、インデックスを追加するSQLデータ定義言語を出力します。</span></dt><dt><span class="refentrytitle"><a href="Normalize_Address.html">Normalize_Address</a></span><span class="refpurpose"> — 文字列で住所が与えられると、道路後置辞、前置辞、正規化された種別、番地、ストリート名等をフィールドに分けて持つ<code class="varname">norm_addy</code>複合型を返します。tiger_geocoderに同梱されているルックアップデータで動作します (Tigerデータ自体は不要です)。</span></dt><dt><span class="refentrytitle"><a href="Pagc_Normalize_Address.html">Pagc_Normalize_Address文字列のストリート住所を与えると、道路後置辞、前置辞、標準タイプ、番地、ストリート名等を複数フィールドに分解して持つ<code class="varname">norm_addy</code>複合型を返します。この関数は、tiger_geocoder同梱のルックアップテーブルだけを使います (Tigerデータは不要です)。住所標準化エクステンションが必要です。</a></span><span class="refpurpose"> — 文字列のストリート住所を与えると、道路後置辞、前置辞、標準タイプ、番地、ストリート名等を複数フィールドに分解して持つ<code class="varname">norm_addy</code>複合型を返します。この関数は、tiger_geocoder同梱のルックアップテーブルだけを使います (Tigerデータは不要です)。住所標準化エクステンションが必要です。</span></dt><dt><span class="refentrytitle"><a href="Pprint_Addy.html">Pprint_Addy</a></span><span class="refpurpose"> — <code class="varname">norm_addy</code>複合型オブジェクトを与えると、印刷表現を返します。通常はnormalize_addressと併用します。</span></dt><dt><span class="refentrytitle"><a href="Reverse_Geocode.html">Reverse_Geocode</a></span><span class="refpurpose"> — 登録されている空間参照系に基づくポイントジオメトリを引数に取り、理論的に可能性のある住所の配列と交差するストリートの配列を一つのレコードで返します。include_strnum_range = trueの場合には、交差するストリートに番地範囲を追加します。</span></dt><dt><span class="refentrytitle"><a href="Topology_Load_Tiger.html">Topology_Load_Tiger</a></span><span class="refpurpose"> — Tigerデータの定義領域をPostGISトポロジにロードして、Tigerデータをトポロジの空間参照系に投影変換し、トポロジの許容精度にスナップします。</span></dt><dt><span class="refentrytitle"><a href="Set_Geocode_Setting.html">Set_Geocode_Setting</a></span><span class="refpurpose"> — ジオコーダ関数の振る舞いに影響を与える設定を行います。</span></dt></dl></div><p>PostGIS用の二つのオープンソースジオコーダがあります。これらはTigerジオコーダと違い、他国のジオコーディングに対応している利点があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://wiki.openstreetmap.org/wiki/Nominatim" target="_top">Nominatim</a>は、OpenStreetMapの地名集データを使います。データのロードにはosm2pgsqlが必要です。PostgreSQL 8.4以上とPostGIS 1.5以上が必要です。Webサービスのインタフェースとして作られていて、Webサービスと呼ばれるような設計に見えます。Tigerジオコーダと同じように、ジオコーダと逆ジオコーダの要素を持ちます。文書からでは、Tigerジオコーダのような純粋なSQLインタフェースを持っているのか、多くの処理がWebインタフェースに実装されているのか、は明確ではありません。</p></li><li class="listitem"><p><a class="ulink" href="http://www.gisgraphy.com/" target="_top">GIS Graphy</a>も、PostGISを使用したもので、NominatimのようにOpenStreetMap (OSM)データを使用します。OSMデータのロードを行うローダとNominatimのように米国だけでなくジオコーディングを行う能力があります。Nominatimとよく似ていて、Webサービスとして動作し、Java 1.5、サーブレットアプリケーション、Apache Solrに依存しています。GisGraphyは、複数プラットフォームで動作し、他の機能の中には逆ジオコーダがあります。</p></li></ul></div></div></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="postgis_administration.html">戻る</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="getfaceedges_returntype.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第3章 PostGIS管理 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> getfaceedges_returntype</td></tr></table></div></body></html>
