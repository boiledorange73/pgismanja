<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>PostGISマニュアル</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><meta name="description" content="PostGISは、オブジェクトRDBであるPostgreSQLの拡張で、GIS (地理情報システム)オブジェクトを格納することができます。PostGISは、GiSTベースのR木空間インデックスをサポートし、GISオブジェクトの解析および処理を行う機能を持ちます。"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="ja" class="book" title="PostGISマニュアル"><div class="titlepage"><div><div><h1 class="title"><a name="idp61158984"></a>PostGISマニュアル</h1></div><div><div class="abstract" title="概要"><p class="title"><b>概要</b></p><p>PostGISは、オブジェクトRDBであるPostgreSQLの拡張で、GIS (地理情報システム)オブジェクトを格納することができます。PostGISは、GiSTベースのR木空間インデックスをサポートし、GISオブジェクトの解析および処理を行う機能を持ちます。</p></div></div></div><hr></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="chapter"><a href="#idp57954120">1. 導入</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp57955144">1.1. 貢献者</a></span></dt><dt><span class="sect1"><a href="#idp57965640">1.2. 追加情報 </a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp57976392">2. インストール</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp57977032">2.1. 必要なもの</a></span></dt><dt><span class="sect1"><a href="#PGInstall">2.2. PostGIS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#upgrading">2.2.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp61986376">2.2.2. 共通の問題</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62062408">2.3. JDBC</a></span></dt><dt><span class="sect1"><a href="#idp62069064">2.4. ローダ/ダンパ </a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp62072392">3. よくある質問</a></span></dt><dt><span class="chapter"><a href="#idp62120520">4. PostGISを使う</a></span></dt><dd><dl><dt><span class="sect1"><a href="#RefObject">4.1. GISオブジェクト</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62122696">4.1.1. OpenGIS WKBとWKT</a></span></dt><dt><span class="sect2"><a href="#idp62132168">4.1.2. PostGIS EWKB, EWKTと標準形式</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62145608">4.2. OpenGIS標準を使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62152264">4.2.1. SPATIAL_REF_SYSテーブル</a></span></dt><dt><span class="sect2"><a href="#idp62169416">4.2.2. GEOMETRY_COLUMNSテーブル</a></span></dt><dt><span class="sect2"><a href="#idp62181448">4.2.3. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="#idp62194376">4.2.4. ジオメトリのOpenGIS準拠を確実にする</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62199752">4.3. GISデータのロード</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62204872">4.3.1. SQLを使う</a></span></dt><dt><span class="sect2"><a href="#idp62208328">4.3.2. ローダを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62226888">4.4. GISデータを検索する</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62227912">4.4.1. SQLを使う</a></span></dt><dt><span class="sect2"><a href="#idp62251464">4.4.2. ダンパを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62269128">4.5. インデックスを構築する</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp61085000">4.5.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="#idp61088968">4.5.2. インデックスを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp61097672">4.6. 複雑なクエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp61099080">4.6.1. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="#idp62303688">4.6.2. 空間SQLの例</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62374088">4.7. MapServerを使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62382664">4.7.1. 基本的な使い方</a></span></dt><dt><span class="sect2"><a href="#idp62402120">4.7.2. よくある質問</a></span></dt><dt><span class="sect2"><a href="#idp62428744">4.7.3. 踏み込んだ使用法</a></span></dt><dt><span class="sect2"><a href="#idp62448456">4.7.4. 例</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62459080">4.8. Javaクライアント (JDBC)</a></span></dt><dt><span class="sect1"><a href="#idp62462024">4.9. Cクライアント (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62463048">4.9.1. テキストカーソル</a></span></dt><dt><span class="sect2"><a href="#idp62464200">4.9.2. バイナリカーソル</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#idp62465608">5. 性能向上に関する技法</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp62466248">5.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62479176">5.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="#idp62481352">5.1.2. 応急処置</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62485064">5.2. ジオメトリインデックスでCLUSTERを実行する</a></span></dt><dt><span class="sect1"><a href="#idp62488392">5.3. 次元変換の回避</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idp62490824">6. PostGISリファレンス</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp62491848">6.1. OpenGIS関数</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62492488">6.1.1. 管理関数</a></span></dt><dt><span class="sect2"><a href="#idp62498376">6.1.2. 空間関係関数</a></span></dt><dt><span class="sect2"><a href="#idp62587080">6.1.3. ジオメトリ処理関数</a></span></dt><dt><span class="sect2"><a href="#idp62619208">6.1.4. ジオメトリアクセサ</a></span></dt><dt><span class="sect2"><a href="#idp62659912">6.1.5. ジオメトリ コンストラクタ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62713288">6.2. PostGIS独自拡張</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62713928">6.2.1. 管理関数</a></span></dt><dt><span class="sect2"><a href="#idp62735432">6.2.2. 演算子</a></span></dt><dt><span class="sect2"><a href="#idp62767304">6.2.3. 計測関数</a></span></dt><dt><span class="sect2"><a href="#idp62811720">6.2.4. ジオメトリ出力</a></span></dt><dt><span class="sect2"><a href="#idp62820680">6.2.5. ジオメトリ コンストラクタ</a></span></dt><dt><span class="sect2"><a href="#idp62848072">6.2.6. ジオメトリエディタ</a></span></dt><dt><span class="sect2"><a href="#idp62879816">6.2.7. その他の関数</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#idp62934856">A. リリースノート</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp62935496">A.1. リリース 1.0.0</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62936904">A.1.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62939336">A.1.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62941256">A.1.3. 他の変更追加</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62944840">A.2. リリース 1.0.0RC6</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62946248">A.2.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62948040">A.2.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62949576">A.2.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62950728">A.2.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62952392">A.3. リリース 1.0.0RC5</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62953800">A.3.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62956232">A.3.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62957768">A.3.3. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62959432">A.4. リリース 1.0.0RC4</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62960840">A.4.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62962632">A.4.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62966088">A.4.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62967752">A.4.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62971848">A.5. リリース 1.0.0RC3</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62973256">A.5.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp56482888">A.5.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp56486728">A.5.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp56489032">A.5.4. JDBC変更</a></span></dt><dt><span class="sect2"><a href="#idp56493128">A.5.5. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp56496328">A.6. リリース 1.0.0RC2</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp56497736">A.6.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp56499528">A.6.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62974664">A.6.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62976328">A.6.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62977992">A.7. リリース 1.0.0RC1</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62979400">A.7.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62981192">A.7.2. 変更</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" title="第1章 導入"><div class="titlepage"><div><div><h2 class="title"><a name="idp57954120"></a>第1章 導入</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#idp57955144">1.1. 貢献者</a></span></dt><dt><span class="sect1"><a href="#idp57965640">1.2. 追加情報 </a></span></dt></dl></div><p>PostGISはRefractions Research Incが空間データベース技術研究プロジェクトとして開発しました。Refractionsはカナダ・ブリティッシュコロンビア州・ビクトリアにある、データインテグレーションとカスタムソフトウェア開発に特化した、GISとデータベースのコンサルティング会社です。私たちは完全なOpenGISサポート、高度なトポロジ構成 (カバレッジ、サーフェス、ネットワーク)、GISデータの表示と編集をするためのデスクトップユーザインタフェースツール、ウェブベースのアクセスツールを持つ、 重要なGIS機能性の範囲をサポートするPostGISを、サポートおよび開発する予定です。</p><div class="sect1" title="1.1. 貢献者"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp57955144"></a>1.1. 貢献者</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Sandro Santilli &lt;strk@refractions.net&gt;</span></dt><dd><p>全ての誤り訂正と保守、新しいGEOS機能の統合、新関数の機能強化。</p></dd><dt><span class="term">Chris Hodgson &lt;chodgson@refractions.net&gt;</span></dt><dd><p>新関数の保守と7.2のインデックスバインディング。</p></dd><dt><span class="term">Paul Ramsey &lt;pramsey@refractions.net&gt;</span></dt><dd><p>JDBCオブジェクトの保守と文書とパッケージの更新記録。</p></dd><dt><span class="term">Jeff Lounsbury &lt;jeffloun@refractions.net&gt;</span></dt><dd><p>シェープファイルのローダ/ダンパのオリジナル開発者</p></dd><dt><span class="term">Dave Blasby &lt;dblasby@gmail.com&gt;</span></dt><dd><p>PostGISのオリジナル開発者。サーバサイドオブジェクト、インデックスバインディング、 サーバサイドの解析関数を書きました。</p></dd><dt><span class="term">他の貢献者</span></dt><dd><p>ABC順で: Alex Bodnaru, Bernhard Reiter, Bruno Wolff III, Carl Anderson, David Skea, David Techer, IIDA Tetsushi, Geographic Data BC, Gerald Fenoy, Gino Lucrezi, Klaus Foerster, Kris Jurka, Mark Cave-Ayland, Mark Sondheim, Markus Schaber, Norman Vine, Olivier Courtin, Ralph Mason, Steffen Macke. </p></dd></dl></div></div><div class="sect1" title="1.2. 追加情報"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp57965640"></a>1.2. 追加情報 </h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>最新のソフトウェア、ドキュメントおよびニュースについてはPostGISウェブサイト<a class="ulink" href="http://postgis.refractions.net" target="_top">http://postgis.refractions.net</a>をご覧下さい。</p></li><li class="listitem"><p>ジオメトリ操作ライブラリGEOSに関する詳細情報は<a class="ulink" href="http://geos.refractions.net" target="_top">http://geos.refractions.net</a>をご覧下さい。</p></li><li class="listitem"><p>投影変換ライブラリProj4に関する詳細情報は<a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>をご覧下さい。</p></li><li class="listitem"><p>データベースサーバPostgreSQLに関する詳細情報は、PostgreSQLメインサイト<a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>をご覧下さい。</p></li><li class="listitem"><p>GiSTインデックスに関する詳細情報は、PostgreSQL GiST開発サイト<a class="ulink" href="http://www.sai.msu.su/~megera/postgres/gist" target="_top">http://www.sai.msu.su/~megera/postgres/gist</a>をご覧下さい。</p></li><li class="listitem"><p>インターネット地図サーバ MapServer に関する詳細情報は<a class="ulink" href="http://mapserver.gis.umn.edu/" target="_top">http://mapserver.gis.umn.edu</a>をご覧下さい (訳注:http://mapserver.org/に移動しています)。</p></li><li class="listitem"><p>"<a class="ulink" href="http://www.opengis.org/techno/specs/99-049.pdf" target="_top">Simple Features for Specification for SQL</a>"は、OpenGISコンソーシアムウェブサイト<a class="ulink" href="http://www.opengis.org" target="_top">http://www.opengis.org</a>にあります。</p></li></ul></div></div></div><div class="chapter" title="第2章 インストール"><div class="titlepage"><div><div><h2 class="title"><a name="idp57976392"></a>第2章 インストール</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#idp57977032">2.1. 必要なもの</a></span></dt><dt><span class="sect1"><a href="#PGInstall">2.2. PostGIS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#upgrading">2.2.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp61986376">2.2.2. 共通の問題</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62062408">2.3. JDBC</a></span></dt><dt><span class="sect1"><a href="#idp62069064">2.4. ローダ/ダンパ </a></span></dt></dl></div><div class="sect1" title="2.1. 必要なもの"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp57977032"></a>2.1. 必要なもの</h2></div></div></div><p>PostGISのビルドと利用のために、次のものが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>PostgreSQLの完全なコンフィギュアとビルドが行われたコードツリー。PostGISは、ビルドを行った特定のプラットフォームに合わせるために、PostgreSQLのコンフィギュア/ビルド処理で作られた定義を使います。PostgreSQLは<a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>にあります。</p></li><li class="listitem"><p>GNU Cコンパイラ (<code class="filename">gcc</code>)。ANSI Cコンパイラの中には、PostGISをコンパイルできるものもありますが、<code class="filename">gcc</code>でコンパイルするのが最も問題が少ないと見ています。</p></li><li class="listitem"><p>GNU Make (<code class="filename">gmake</code>または<code class="filename">make</code>)。多くのシステムで、GNU makeがデフォルトのmakeになっています。<code class="filename">make -v</code>を実行して版を確認して下さい。他版の<code class="filename">make</code>では、PostGISの<code class="filename">Makefile</code>を完全に処理しきれないかもしれません。</p></li><li class="listitem"><p>(推奨) 投影変換ライブラリ Proj4。Proj4ライブラリはPostGISで座標投影変換をサポートするために使われます。Proj4は<a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>からダウンロードできます。</p></li><li class="listitem"><p>(推奨) ジオメトリライブラリ GEOS。GEOSライブラリは、PostGISでジオメトリのチェック (Touches(), Contains(), Intersects())および操作(Buffer(), GeomUnion(), Difference()) を提供するために使用します。 GEOSは<a class="ulink" href="http://geos.refractions.net" target="_top">http://geos.refractions.net</a>からダウンロードできます。</p></li></ul></div></div><div class="sect1" title="2.2. PostGIS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PGInstall"></a>2.2. PostGIS</h2></div></div></div><p>PostGISモジュールは、PostgreSQLバックエンドサーバの拡張です。PostGIS 1.0.0をコンパイルするためにPostgreSQLサーバのヘッダの完全なアクセスが<span class="emphasis"><em>必要です</em></span>。PostgreSQLのソースコードは<a class="ulink" href="http://www.postgresql.org" target="_top">http://www.postgresql.org</a>にあります。</p><p>PostGIS 1.0.0は、PostgreSQL 7.2.0から7.4.0で構築できます。それ以前のPostgreSQLには<span class="emphasis"><em>対応しません</em></span>。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>PostGISサーバモジュールをコンパイルする前に、PostgreSQLをコンパイル、インストールする必要があります。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>GEOS機能の使用を予定しているなら、PostgreSQLを標準C++ライブラリに、明示的にリンクする必要があることもあります。</p><pre class="programlisting">LDFLAGS=-lstdc++ ./configure [コンフィギュアオプション]</pre><p>これは、古い開発ツールとインチキC++例外との対話のための応急処置です。怪しい問題 (望んでいないのにバックエンドが閉じたりそれに近い挙動を起こす)を経験したなら、このトリックを試してみて下さい。もちろん、これを行うにはPostgreSQLをはじめからコンパイルし直す必要があります。</p></div></li><li class="listitem"><p>PostGISソースコードのアーカイブを<a class="ulink" href="http://postgis.refractions.net/postgis-1.0.0.tar.gz" target="_top">http://postgis.refractions.net/postgis-1.0.0.tar.gz</a>から取得します。PostgreSQLソースツリーの "contrib"ディレクトリ内で、このアーカイブを解凍します。</p><pre class="programlisting"># cd [PostgreSQLソースツリー]/contrib 
# gzip -d -c postgis-1.0.0.tar.gz | tar xvf -</pre></li><li class="listitem"><p>PostgreSQLのインストールが更新されたら、"postgis"ディレクトリに入り、<code class="filename">Makefile.config</code>ファイルを編集します。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>座標再投影に対応したいならProj4ライブラリをインストールし、<code class="varname">USE_PROJ</code>変数に<span class="emphasis"><em>1</em></span>を入れ、<code class="varname">PROJ_DIR</code>変数をProj4をインストールしたディレクトリに合わせます。</p></li><li class="listitem"><p>GEOS機能を使いたいならGEOSライブラリをインストールし、<code class="varname">USE_GEOS</code>変数に<span class="emphasis"><em>1</em></span>を入れ、<code class="varname">GEOS_DIR</code>変数をGEOSをインストールしたディレクトリに合わせます。</p></li></ul></div></li><li class="listitem"><p>コンパイルとインストールのコマンドを実行します。</p><pre class="programlisting"># make 
# make install</pre><p>全てのファイルが<code class="filename">[prefix]</code> (PostgreSQLのインストールディレクトリ)からの相対位置にインストールされます。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>ライブラリは<code class="filename">[prefix]/lib/contrib</code>にインストールされます。</p></li><li class="listitem"><p><code class="filename">lwpostgis.sql</code>といったサポートファイルは<code class="filename">[prefix]/share/contrib</code>にインストールされます。</p></li><li class="listitem"><p>ローダとダンパのバイナリは<code class="filename">[prefix]/bin</code>にインストールされます。</p></li></ul></div></li><li class="listitem"><p>PostGISにはPL/pgSQL手続き型言語の拡張が必要です。<code class="filename">lwpostgis.sql</code>ファイルをロードする前に、まずPL/pgSQLを有効にする必要があります。<code class="filename">createlang</code>コマンドを使うべきです。なんらかの理由で手動で行いたい場合にはPostgreSQLプログラマガイドに詳細があります。</p><pre class="programlisting"># createlang plpgsql [データベース名]</pre></li><li class="listitem"><p>そして、<code class="filename">lwpostgis.sql</code>定義ファイルをロードして、PostGISオブジェクトと関数定義をデータベースにロードします。</p><pre class="programlisting">psql -d [データベース名] -f rtpostgis.sql</pre><p>PostGISサーバ拡張はこれでロードされて、使えるようになります。</p></li><li class="listitem"><p>完全なEPSG座標系定義IDのセットについては、<code class="filename">spatial_ref_sys.sql</code>定義ファイルをロードして、<code class="varname">SPATIAL_REF_SYS</code>を生成して下さい。</p><pre class="programlisting">psql -d [データベース名] -f spatial_ref_sys.sql</pre></li></ol></div><div class="sect2" title="2.2.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="upgrading"></a>2.2.1. アップグレード</h3></div></div></div><p>オブジェクト型とジオメトリにに対応するためのCライブラリが版ごとに異なるため、PostGISのアップグレードは扱いにくくなっています。 </p><p>この目的のために、PostGISは、pg_dump -Fcコマンドによるダンプを格納するためのユーティリティスクリプトを提供しています。これは試験的なもので、出力をファイルにリダイレクトすることで問題がある場合の解決の助けになります。手続きは次の通りです。 </p><pre class="programlisting"># Create a "custom-format" dump of the database you want
        # to upgrade (let's call it "olddb")
        $ pg_dump -Fc olddb olddb.dump

        # Restore the dump contextually upgrading postgis into
        # a new database. The new database doesn't have to exist.
        # Let's call it "newdb"
        $ sh utils/postgis_restore.pl lwpostgis.sql newdb olddb.dump &gt; restore.log

        # Check that all restored dump objects really had to be restored from dump
        # and do not conflict with the ones defined in lwpostgis.sql
        $ grep ^KEEPING restore.log | less

        # If upgrading from PostgreSQL &lt; 7.5 to &gt;= 7.5 you might want to 
        # drop the attrelid, varattnum and stats columns in the geometry_columns
        # table, which are no-more needed. Keeping them won't hurt.
        # !!! DROPPING THEM WHEN REALLY NEEDED WILL DO HURT !!!!
        $ psql newdb -c "ALTER TABLE geometry_columns DROP attrelid"
        $ psql newdb -c "ALTER TABLE geometry_columns DROP varattnum"
        $ psql newdb -c "ALTER TABLE geometry_columns DROP stats"

        # spatial_ref_sys table is restore from the dump, to ensure your custom
        # additions are kept, but the distributed one might contain modification
        # so you should backup your entries, drop the table and source the new one.
        # If you did make additions we assume you know how to backup them before
        # upgrading the table. Replace of it with the new one is done like this:
        $ psql newdb
        newdb=&gt; drop table spatial_ref_sys;
        DROP
        newdb=&gt; \i spatial_ref_sys.sql
        </pre><p>「古い」手続きの記述を次に示します。可能なら*避けるべき*です。データベース内に意図しない関数が多数入り込むためです。この文書内で残されているのは、postgis_restore.plが動作しない場合の「バックアップ」のためです。 </p><pre class="programlisting">pg_dump -t "*" -f dumpfile.sql yourdatabase
        dropdb yourdatabase
        createdb yourdatabase
        createlang plpgsql yourdatabase
        psql -f lwpostgis.sql -d yourdatabase
        psql -f dumpfile.sql -d yourdatabase
        vacuumdb -z yourdatabase
        </pre></div><div class="sect2" title="2.2.2. 共通の問題"><div class="titlepage"><div><div><h3 class="title"><a name="idp61986376"></a>2.2.2. 共通の問題</h3></div></div></div><p>インストールやアップグレードが思うようにいかない時にチェックすることがいくつかあります。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>PostGISディストリビューションをPostgreSQLソースツリーの下のcontribディレクトリに解凍するのが最も簡単です。 しかし、これが何らかの理由で展開できないなら、環境変数<code class="varname">PGSQL_SRC</code>にPostgreSQLソースディレクトリのパスを指定します。これで、PostGISのコンパイルができますが、<span class="command"><strong>make install</strong></span>はできないので、PostGISライブラリと実行ファイルを適切な位置に自前で複写することになります。</p></li><li class="listitem"><p>PostgreSQL 7.2以降をインストールしているか、実行中のPostgreSQLと同じ版のPostgreSQLソースを使ってコンパイルしているか、をチェックします。(Linuxの)ディストリビューションによって既にPostgreSQLがインストールされている時や、PostgreSQLを以前にインストールして忘れた場合に、混乱が発生することがあります。PostGISは、PostgreSQL 7.2以上でのみ動作し、 それより前の版を使うと、おかしな、予想外のエラーメッセージが表示されます。 実行中のPostgreSQLの版をチェックするには、psqlを使ってデータベースを接続して、次のクエリを実行します。</p><pre class="programlisting">SELECT version();</pre><p>RPMベースのディストリビューションを実行している場合、プリインストールされたパッケージが存在するかのチェックは、<span class="command"><strong>rpm</strong></span>コマンドを使います。<span class="command"><strong>rpm -qa | grep postgresql</strong></span>でチェックできます。</p></li></ol></div><p>また、Makefile.configの先頭に行った必要な変更を全てチェックして下さい。このチェックは次の通りです。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>投影変換をできるようにしたいなら、Proj4ライブラリをインストールして、Makefile.config内の、<code class="varname">USE_PROJ</code>の値を1に設定し、<code class="varname">PROJ_DIR</code>をインストール先プリフィクスにします。</p></li><li class="listitem"><p>GEOS関数を使いたい場合は、 GEOSライブラリをインストールし、Makefile.config内の、<code class="varname">USE_GEOS</code>を1に設定し、<code class="varname">GEOS_DIR</code>をインストール先プリフィクスにします。</p></li></ol></div></div></div><div class="sect1" title="2.3. JDBC"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62062408"></a>2.3. JDBC</h2></div></div></div><p>JDBC拡張によって、JavaオブジェクトがPostGISの内部型に対応できるようになります。このオブジェクトを使って、PostGISデータベースに問い合わせを出して、PostGISにあるGISデータの描画や計算を行うJavaクライアントを作成することができます。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>PostGISディストリビューションの<code class="filename">jdbc</code>サブディレクトリに移動します。</p></li><li class="listitem"><p><code class="filename">Makefile</code>を編集して、Javaコンパイラ (<code class="varname">JAVAC</code>)とインタプリタ (<code class="varname">JAVA</code>)を正しいパスにします。</p></li><li class="listitem"><p><code class="filename">make</code>コマンドを実行します。<code class="filename">postgis.jar</code>ファイルをJavaライブラリを保存しているところに複製します。</p></li></ol></div></div><div class="sect1" title="2.4. ローダ/ダンパ"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62069064"></a>2.4. ローダ/ダンパ </h2></div></div></div><p>データのローダとダンパは、PostGISのビルドの一部として、自動的にビルド、インストールされます。手動でビルド、インストールするには、次を実行します。</p><pre class="programlisting"># cd postgis-1.0.0/loader 
# make
# make install</pre><p>ローダは<code class="filename">shp2pgsql</code>と呼ばれ、ESRIシェープファイルをPostGIS/PostgreSQLにロードするのに適したSQLに変換します。ダンパは<code class="filename">pgsql2shp</code>と呼ばれ、PostGISのテーブル (またはクエリ)からESRIシェープファイルに変換します。</p></div></div><div class="chapter" title="第3章 よくある質問"><div class="titlepage"><div><div><h2 class="title"><a name="idp62072392"></a>第3章 よくある質問</h2></div></div></div><div class="qandaset" title="よくある質問"><a name="idp62073032"></a><dl><dt>3.1. <a href="#idp62073288">どの種類のジオメトリオブジェクトを格納できますか?</a></dt><dt>3.2. <a href="#idp62075208">GISオブジェクトをデータベースに挿入するにはどうしますか?</a></dt><dt>3.3. <a href="#idp62095176">空間クエリを作成するにはどうするのですか?</a></dt><dt>3.4. <a href="#idp62099400">大きなテーブルでの空間クエリの速度向上はどうするのですか?</a></dt><dt>3.5. <a href="#idp62106184">なぜPostgreSQLのR木インデックス機能を持たないのですか?</a></dt><dt>3.6. <a href="#idp62110408">なぜ AddGeometryColumn()関数と他のOpsnGIS関数を使うべきなのですか?</a></dt><dt>3.7. <a href="#idp62114376">半径内にあるオブジェクトを全て検索する最善の方法は何ですか?</a></dt><dt>3.8. <a href="#idp62117832">クエリの一部として投影変換を実現するにはどうしますか?</a></dt></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="question" title="3.1."><td align="left" valign="top"><a name="idp62073288"></a><a name="idp62073544"></a><p><b>3.1.</b></p></td><td align="left" valign="top"><p>どの種類のジオメトリオブジェクトを格納できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>ポイント、ライン、ポリゴン、マルチポイント、マルチライン、マルチポリゴン、ジオメトリコレクションを格納できます。これらは Open GIS Well Known Text Formatで規定されています (XYZ,XYM,XYZM拡張付き)。</p></td></tr><tr class="question" title="3.2."><td align="left" valign="top"><a name="idp62075208"></a><a name="idp62075464"></a><p><b>3.2.</b></p></td><td align="left" valign="top"><p>GISオブジェクトをデータベースに挿入するにはどうしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>まず、GISデータを保持するためにジオメトリ型のカラムをテーブルに作成する必要があります。<code class="filename">psql</code>でデータベースに接続して、次のSQLを実行します。</p><pre class="programlisting">CREATE TABLE gtest ( ID int4, NAME varchar(20) );
SELECT AddGeometryColumn('', 'gtest','geom',-1,'LINESTRING',2);</pre><p>ジオメトリカラムの追加に失敗したなら、PostGIS関数とオブジェクトをそのデータベースにロードしていない可能性があります。<a class="link" href="#PGInstall" title="2.2. PostGIS">インストール方法</a>をご覧ください。</p><p>これで、SQLのINSERTステートメントを使って、ジオメトリをテーブルに挿入することができます。GISオブジェクト自体は、OpenGISコンソーシアムの"well-known text"形式を使っています。</p><pre class="programlisting">INSERT INTO gtest (ID, NAME, GEOM) VALUES (1, 'First Geometry', GeomFromText('LINESTRING(2 3,4 5,6 5,7 8)', -1));</pre><p>GISオブジェクトの詳細については、<a class="link" href="#RefObject" title="4.1. GISオブジェクト">オブジェクトリファレンス</a>をご覧下さい。</p><p>テーブルの中にあるGISデータを閲覧するには、次のようにします。</p><pre class="programlisting">SELECT id, name, AsText(geom) AS geom FROM gtest;</pre><p>返り値は次のようなかんじになります。</p><pre class="programlisting">id | name           | geom
----+----------------+-----------------------------
  1 | First Geometry | LINESTRING(2 3,4 5,6 5,7 8) 
(1 row)</pre></td></tr><tr class="question" title="3.3."><td align="left" valign="top"><a name="idp62095176"></a><a name="idp62095432"></a><p><b>3.3.</b></p></td><td align="left" valign="top"><p>空間クエリを作成するにはどうするのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>他のデータベースクエリを作るのと同じで、返り値、関数、テストのSQLの組み合わせです。</p><p>空間クエリでは、クエリを作成する際に心を平静に保つための重要な二つの問題があります。 一つは、使用することができる空間インデックスがあるか、です。もう一つは、多数のジオメトリを相手に計算量の多い計算を行っているか、です。</p><p>一般的に、フィーチャーのバウンディングボックスがインタセクト (交差)しているかをテストするインタセクト演算子 (&amp;&amp;)を使います。&amp;&amp;演算子が便利な理由は、速度向上のために空間インデックスが付けられているなら、&amp;&amp;演算子は空間インデックスを使うからです。これによって、クエリの速度はとてもとても速くなります。</p><p>検索結果の数を限定するために、Distance(), Intersects(), Contains(), Within()といった空間関数を使用することでしょう。ほとんどの空間クエリはインデックス検索と空間関数検索を行います。インデックス検索によって検索結果のタプルを、対象条件に適合する<span class="emphasis"><em>かもしれない</em></span>ものに制限させます。そして、空間関数は確実に条件にあうかどうかをチェックします。</p><pre class="programlisting">SELECT id, the_geom FROM thetable
WHERE
  the_geom &amp;&amp; 'POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))'
AND
  Contains(the_geom,'POLYGON((0 0, 0 10, 10 10, 10 0, 0 0))';</pre></td></tr><tr class="question" title="3.4."><td align="left" valign="top"><a name="idp62099400"></a><a name="idp62099656"></a><p><b>3.4.</b></p></td><td align="left" valign="top"><p>大きなテーブルでの空間クエリの速度向上はどうするのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>大きなテーブルの速いクエリは、空間データベースの<span class="emphasis"><em>レゾンデートル</em></span> (トランザクションサポートもそうですが)で、良いインデックスは重要です。</p><p><code class="varname">geometry</code>カラムを持つテーブルでの空間インデックスの構築は、"CREATE INDEX"を使って、次のようにします。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] 
USING GIST ( [ジオメトリカラム] );</pre><p>"USING GIST"オプションによって、サーバにGiST (Generalized Search Tree)インデックスを作るよう指示が渡ります。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>GiSTインデックスは、不可逆であると仮定します。不可逆インデックスの構築には、代理オブジェクト (空間インデックスの場合はバウンディングボックス)を使います。</p></div><p>PostgreSQLのクエリプランナがインデックスを作るべきかについて合理的な決定を行うよう、十分な情報を確実に持てるようにすべきです。そのために、ジオメトリテーブル上で"gather statistics"を実行しなければなりません。</p><p>PostgreSQL 8.0.x以上では、<span class="command"><strong>VACUUM ANALYZE</strong></span>コマンドを実行するだけです。</p><p>PostgreSQL 7.4.x以下では、<span class="command"><strong>SELECT UPDATE_GEOMETRY_STATS()</strong></span>を実行します。</p></td></tr><tr class="question" title="3.5."><td align="left" valign="top"><a name="idp62106184"></a><a name="idp62106440"></a><p><b>3.5.</b></p></td><td align="left" valign="top"><p>なぜPostgreSQLのR木インデックス機能を持たないのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>PostGISの、かつての版では、PostgreSQLのR木インデックスを使っていましたが、0.6版でPostgreSQLのR木は完全に捨てて、R-Tree-over-GiSTスキームによる空間インデックスを提供しています。</p><p>私たちの試験では、R木とGiSTの検索速度は同程度であることが示されています。PostgreSQLのR木には、GISフィーチャーで使うためには好ましくない二つの制限があります (これらの制限は現在のPostgreSQLネイティブのR木実装についてであって、R木一般の話ではありません)。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>PostgreSQLのR木インデックスは、8K以上のサイズのフィーチャーは扱えません。GiSTインデックスはフィーチャー自体の代わりにバウンディングボックスを用いる「不可逆」トリックを使っているので扱うことができます。</p></li><li class="listitem"><p>PostgreSQLのR木インデックスは「NULLセーフ」ではなく、NULLジオメトリを含むジオメトリカラムではインデックス作成に失敗します。</p></li></ul></div></td></tr><tr class="question" title="3.6."><td align="left" valign="top"><a name="idp62110408"></a><a name="idp62110664"></a><p><b>3.6.</b></p></td><td align="left" valign="top"><p>なぜ <code class="varname">AddGeometryColumn()</code>関数と他のOpsnGIS関数を使うべきなのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>OpenGIS関数を使いたくないのでしたら、使う必要はありません。単純にジオメトリカラムをCREATEステートメントで定義する古いやり方で作成して下さい。全てのジオメトリはSRIDが-1になり、OpenGISメタデータテーブルは適切に<span class="emphasis"><em>書き込まれません</em></span>。これによって、ほとんどのPostGISベースのアプリケーションでは失敗します。一般的には<code class="varname">AddGeometryColumn()</code>を用いることをお勧めします。</p><p>MapServerは<code class="varname">geometry_columns</code>メタデータを使うアプリケーションのひとつです。踏み込んでいえば、MpaServerはジオメトリカラムのSRIDを使って、正しい地図投影へのフィーチャーの自動投影変換を行います。</p></td></tr><tr class="question" title="3.7."><td align="left" valign="top"><a name="idp62114376"></a><a name="idp62114632"></a><p><b>3.7.</b></p></td><td align="left" valign="top"><p>半径内にあるオブジェクトを全て検索する最善の方法は何ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>データベースを最も効果的に使うには、半径検索とバウンディングボックス検索を組み合わせた半径検索を行うのが最も良いです。バウンディングボックス検索で空間インデックスを使用するので、半径検索が適用されるサブセットへのアクセスが早くなります。</p><p><code class="varname">Expand()</code>関数は、検索対象領域のインデックス検索を可能にするためにバウンディングボックスを拡大させる手軽な方法です。速いインデックスへのアクセスの句と遅い高精度距離テストとの組み合わせで、このクエリにおける、速さと精度の最も良い組み合わせが得られます。</p><p>たとえば、POINT(1000 1000)から100メートル内の全てのオブジェクトを見つけるためには、次のクエリで動作します。</p><pre class="programlisting">SELECT * 
FROM GEOTABLE 
WHERE 
  GEOCOLUMN &amp;&amp; Expand(GeomFromText('POINT(1000 1000)',-1),100)
AND
  Distance(GeomFromText('POINT(1000 1000)',-1),GEOCOLUMN) &lt; 100;</pre></td></tr><tr class="question" title="3.8."><td align="left" valign="top"><a name="idp62117832"></a><a name="idp62118088"></a><p><b>3.8.</b></p></td><td align="left" valign="top"><p>クエリの一部として投影変換を実現するにはどうしますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>投影変換を行うには、変換元と変換先双方の座標系がSPATIAL_REF_SYSテーブルに定義されていて、かつ投影変換されるジオメトリがそのSRIDを持っている必要があります。これが行われていると、投影変換は求める変換先SRIDを参照するのと同じぐらい簡単です。</p><pre class="programlisting">SELECT Transform(GEOM,4269) FROM GEOTABLE;</pre></td></tr></tbody></table></div></div><div class="chapter" title="第4章 PostGISを使う"><div class="titlepage"><div><div><h2 class="title"><a name="idp62120520"></a>第4章 PostGISを使う</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#RefObject">4.1. GISオブジェクト</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62122696">4.1.1. OpenGIS WKBとWKT</a></span></dt><dt><span class="sect2"><a href="#idp62132168">4.1.2. PostGIS EWKB, EWKTと標準形式</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62145608">4.2. OpenGIS標準を使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62152264">4.2.1. SPATIAL_REF_SYSテーブル</a></span></dt><dt><span class="sect2"><a href="#idp62169416">4.2.2. GEOMETRY_COLUMNSテーブル</a></span></dt><dt><span class="sect2"><a href="#idp62181448">4.2.3. 空間テーブルを作る</a></span></dt><dt><span class="sect2"><a href="#idp62194376">4.2.4. ジオメトリのOpenGIS準拠を確実にする</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62199752">4.3. GISデータのロード</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62204872">4.3.1. SQLを使う</a></span></dt><dt><span class="sect2"><a href="#idp62208328">4.3.2. ローダを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62226888">4.4. GISデータを検索する</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62227912">4.4.1. SQLを使う</a></span></dt><dt><span class="sect2"><a href="#idp62251464">4.4.2. ダンパを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62269128">4.5. インデックスを構築する</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp61085000">4.5.1. GiSTインデックス</a></span></dt><dt><span class="sect2"><a href="#idp61088968">4.5.2. インデックスを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp61097672">4.6. 複雑なクエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp61099080">4.6.1. インデックスの利点を使う</a></span></dt><dt><span class="sect2"><a href="#idp62303688">4.6.2. 空間SQLの例</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62374088">4.7. MapServerを使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62382664">4.7.1. 基本的な使い方</a></span></dt><dt><span class="sect2"><a href="#idp62402120">4.7.2. よくある質問</a></span></dt><dt><span class="sect2"><a href="#idp62428744">4.7.3. 踏み込んだ使用法</a></span></dt><dt><span class="sect2"><a href="#idp62448456">4.7.4. 例</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62459080">4.8. Javaクライアント (JDBC)</a></span></dt><dt><span class="sect1"><a href="#idp62462024">4.9. Cクライアント (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62463048">4.9.1. テキストカーソル</a></span></dt><dt><span class="sect2"><a href="#idp62464200">4.9.2. バイナリカーソル</a></span></dt></dl></dd></dl></div><div class="sect1" title="4.1. GISオブジェクト"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RefObject"></a>4.1. GISオブジェクト</h2></div></div></div><p>PostGISでサポートされるGISオブジェクトは、OpenGIS Consortium (OGC)が定義する"Simple Features" のスーパーセットです。 PostGIS 0.9版からOGCの"Simple Features for SQL"仕様で定められた全てのオブジェクトと関数をサポートしています。</p><p>PostGISは標準から拡張して 3DZ, 3DM, 4D 座標 (訳注: それぞれXYZ, XYM, XYZM)をサポートしています。</p><div class="sect2" title="4.1.1. OpenGIS WKBとWKT"><div class="titlepage"><div><div><h3 class="title"><a name="idp62122696"></a>4.1.1. OpenGIS WKBとWKT</h3></div></div></div><p>OpenGIS仕様は空間オブジェクトの表現について二つの標準を定義しています。Well-Knownテキスト (WKT)形式とWell-Knownバイナリ (WKB)形式です。WKTもWKBも、オブジェクトの型とオブジェクトを形成する座標に関する情報を持っています。</p><p>フィーチャーの空間オブジェクトのテキスト表現 (WKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POINT(0 0)</p></li><li class="listitem"><p>LINESTRING(0 0,1 1,1 2)</p></li><li class="listitem"><p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p></li><li class="listitem"><p>MULTIPOINT(0 0,1 2)</p></li><li class="listitem"><p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING((2 3,3 4)))</p></li></ul></div><p>OpenGIS仕様では、空間オブジェクトの内部保存書式は空間参照系識別子 (Spatial Referencing System IDentifier, SRID)を含むことも求められます。SRIDはデータベースへの挿入のために空間オブジェクトが生成される時に求められます。</p><p>これらの書式の入出力は次のインタフェースを用いて実現できます。 </p><pre class="programlisting">bytea WKB = asBinary(geometry);
        text WKT = asText(geometry);
        geometry = GeomFromWKB(bytea WKB, SRID); 
        geometry = GeometryFromText(text WKT, SRID);
        </pre><p>たとえば、OGC空間オブジェクトを生成して挿入する妥当なINSERTステートメントは次の通りです。</p><pre class="programlisting">INSERT INTO SPATIALTABLE ( 
                  THE_GEOM, 
                  THE_NAME 
        ) 
        VALUES ( 
                  GeomFromText('POINT(-126.4 45.32)', 312), 
                  'A Place' 
        )</pre></div><div class="sect2" title="4.1.2. PostGIS EWKB, EWKTと標準形式"><div class="titlepage"><div><div><h3 class="title"><a name="idp62132168"></a>4.1.2. PostGIS EWKB, EWKTと標準形式</h3></div></div></div><p>OGC書式は2次元ジオメトリしかサポートされておらず、また、入出力の表現においてSRIDは*決して*埋め込まれません。 </p><p>PostGIS拡張書式は現在のところOGC書式のスーパーセットとなっています (全ての妥当なWKB/WKTは妥当なEWKB/EWKTです)。しかし、特にもしOGCがPostGIS拡張と矛盾する新しい書式を出すことがあるなら、これは将来変更されるかも知れません。ゆえにこの機能に頼るべきではありません。 </p><p>PostGIS EWKB/EWKT では 3dm, 3dz, 4d の座標サポートが追加され、SRID情報が埋め込まれます。 </p><p>拡張された空間オブジェクトのテキスト表現 (EWKT)の例は、次の通りです。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POINT(0 0 0) -- XYZ</p></li><li class="listitem"><p>SRID=32632;POINT(0 0) -- XY with SRID</p></li><li class="listitem"><p>POINTM(0 0 0) -- XYM</p></li><li class="listitem"><p>POINT(0 0 0 0) -- XYZM</p></li><li class="listitem"><p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID付きXYM</p></li><li class="listitem"><p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))</p></li><li class="listitem"><p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</p></li><li class="listitem"><p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p></li><li class="listitem"><p>GEOMETRYCOLLECTIONM(POINTM(2 3 9),LINESTRINGM((2 3 4,3 4 5)))</p></li></ul></div><p>これらの書式の入出力は次のインタフェースを用いて実現できます。 </p><pre class="programlisting">bytea EWKB = asEWKB(geometry);
        text EWKT = asEWKT(geometry);
        geometry = GeomFromEWKB(bytea EWKB);
        geometry = GeomFromEWKT(text EWKT);
        </pre><p>たとえば、PostGISの空間オブジェクトを作成し挿入する妥当なINSERTステートメントは次の通りです。 </p><pre class="programlisting">INSERT INTO SPATIALTABLE ( 
                  THE_GEOM, 
                  THE_NAME 
        ) 
        VALUES ( 
                  GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 
                  'A Place' 
        )</pre><p>The "canonical forms" of a PostgreSQL type are the representations you get with a simple query (without any function call) and the one which is guaranteed to be accepted with a simple insert, update or copy. For the postgis 'geometry' type these are: </p><pre class="programlisting">- Output -
        binary: EWKB
         ascii: HEXEWKB (EWKB in hex form)

        - Input -
        binary: EWKB
         ascii: HEXEWKB|EWKT
        </pre><p>
</p><p>たとえば、次のステートメントは、標準的なASCII文字列による入出力の処理でEWKTを読み、HEXEWKBを返すものです。 </p><pre class="programlisting">=# SELECT 'SRID=4;POINT(0 0)'::geometry;
                              geometry
        ----------------------------------------------------
         01010000200400000000000000000000000000000000000000
        (1 row)
        </pre></div></div><div class="sect1" title="4.2. OpenGIS標準を使う"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62145608"></a>4.2. OpenGIS標準を使う</h2></div></div></div><p>OpenGISの「SQL用シンプルフィーチャー仕様」では、標準GISオブジェクト型とこれらを操作するために必要な関数、メタデータテーブルのセットが定義されています。メタデータが一貫性を維持していることを保証するために、空間カラムの生成、消去といった操作はOpenGISで定義されている空間プロシージャを通して実行されます。</p><p>OpenGISメタデータテーブルには<code class="varname">SPATIAL_REF_SYS</code>と<code class="varname">GEOMETRY_COLUMNS</code>の二つがあります。<code class="varname">SPATIAL_REF_SYS</code>テーブルは空間データベースで用いられる座標系の、数字によるIDと文字による説明を持っています。</p><div class="sect2" title="4.2.1. SPATIAL_REF_SYSテーブル"><div class="titlepage"><div><div><h3 class="title"><a name="idp62152264"></a>4.2.1. SPATIAL_REF_SYSテーブル</h3></div></div></div><p><code class="varname">SPATIAL_REF_SYS</code>テーブル定義は次の通りです。</p><pre class="programlisting">CREATE TABLE SPATIAL_REF_SYS ( 
  SRID INTEGER NOT NULL PRIMARY KEY, 
  AUTH_NAME VARCHAR(256), 
  AUTH_SRID INTEGER, 
  SRTEXT VARCHAR(2048), 
  PROJ4TEXT VARCHAR(2048)
)</pre><p><code class="varname">SPATIAL_REF_SYS</code>のカラムは次の通りです。</p><div class="variablelist"><dl><dt><span class="term">SRID</span></dt><dd><p>一意に定められた整数値で、データベースで空間参照系 (SRS)を識別するものです。</p></dd><dt><span class="term">AUTH_NAME</span></dt><dd><p>その参照系の引用元である標準の名前です。たとえば「EPSG」は妥当な<code class="varname">AUTH_NAME</code>です。</p></dd><dt><span class="term">AUTH_SRID</span></dt><dd><p><code class="varname">AUTH_NAME</code>で引用される団体によって定義された空間参照系のIDです。EPSGの場合、EPSG投影コードが入ります。</p></dd><dt><span class="term">SRTEXT</span></dt><dd><p>空間参照系のWell-Knownテキスト表現です。たとえば、WKT SRSの表現は、次のようになります。</p><pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N", 
  GEOGCS["NAD83",
    DATUM["North_American_Datum_1983", 
      SPHEROID["GRS 1980",6378137,298.257222101]
    ], 
    PRIMEM["Greenwich",0], 
    UNIT["degree",0.0174532925199433] 
  ],
  PROJECTION["Transverse_Mercator"], 
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123], 
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000], 
  PARAMETER["false_northing",0],
  UNIT["metre",1] 
]</pre><p>EPSG投影コードと対応するWKT表現の一覧については<a class="ulink" href="http://www.opengis.org/techno/interop/EPSG2WKT.TXT" target="_top">http://www.opengis.org/techno/interop/EPSG2WKT.TXT</a>をご覧下さい。WKTの一般的な議論については、OpenGISの「座標変換サービス実装仕様」<a class="ulink" href="http://www.opengis.org/techno/specs.htm" target="_top">http://www.opengis.org/techno/specs.htm</a>をご覧下さい。欧州石油調査グループ (European Petroleum Survey Group, EPSG)と EPSG空間参照系のデータベースに関する情報は、<a class="ulink" href="http://epsg.org" target="_top">http://epsg.org</a>をご覧下さい。</p></dd><dt><span class="term">PROJ4TEXT</span></dt><dd><p>PostGISは座標変換機能を提供するためにProj4ライブラリを用いています。 <code class="varname">PROJ4TEXT</code>カラムには、特定のSRIDを示すProj4座標定義文字列が入ります。たとえば次のようになります。</p><pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre><p>詳細情報については、Proj4ウェブサイ<a class="ulink" href="http://www.remotesensing.org/proj" target="_top">http://www.remotesensing.org/proj</a>をご覧下さい。<code class="filename">spatial_ref_sys.sql</code>は、全てのEPSG投影のための<code class="varname">SRTEXT</code>と<code class="varname">PROJ4TEXT</code>を持っています。</p></dd></dl></div></div><div class="sect2" title="4.2.2. GEOMETRY_COLUMNSテーブル"><div class="titlepage"><div><div><h3 class="title"><a name="idp62169416"></a>4.2.2. GEOMETRY_COLUMNSテーブル</h3></div></div></div><p><code class="varname">GEOMETRY_COLUMNS</code>テーブルは、次のように定義されています。</p><pre class="programlisting">CREATE TABLE GEOMETRY_COLUMNS ( 
  F_TABLE_CATALOG VARCHAR(256) NOT NULL, 
  F_TABLE_SCHEMA VARCHAR(256) NOT NULL, 
  F_TABLE_NAME VARCHAR(256) NOT NULL, 
  F_GEOMETRY_COLUMN VARCHAR(256) NOT NULL,
  COORD_DIMENSION INTEGER NOT NULL, 
  SRID INTEGER NOT NULL, 
  TYPE VARCHAR(30) NOT NULL 
)</pre><p>カラムは次のとおりです。</p><div class="variablelist"><dl><dt><span class="term">F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME</span></dt><dd><p>ジオメトリカラムを持つフィーチャーテーブルの完全修飾名。"catalog"および"schema"の語はOracle風であることに注意して下さい。"catalog"に類似するものはPostgreSQLになく、このカラムは空白にされます。"schema"についてはPostgreSQLスキーマ名が使われています (<code class="varname">public</code>がデフォルトです)。</p></dd><dt><span class="term">F_GEOMETRY_COLUMN</span></dt><dd><p>フィーチャーテーブル内のジオメトリカラムの名前。</p></dd><dt><span class="term">COORD_DIMENSION</span></dt><dd><p>そのカラムの空間の次元 (2, 3 または 4)。</p></dd><dt><span class="term">SRID</span></dt><dd><p>このテーブルの座標ジオメトリのために使われる空間参照系のID。<code class="varname">SPATIAL_REF_SYS</code>への外部キーになっています。</p></dd><dt><span class="term">TYPE</span></dt><dd><p>空間オブジェクトのタイプ。 空間カラムを単一型に制限するには、 POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION のうちのいずれかを、また、XYMで使う場合には LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM のうちのいずれかを使います。複数の型が混合するコレクションの場合は "GEOMETRY"タイプとすることができます。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>この属性は (おそらく)OpenGIS仕様に入っていませんが、型の同一性を保証するために必要です。</p></div></dd></dl></div></div><div class="sect2" title="4.2.3. 空間テーブルを作る"><div class="titlepage"><div><div><h3 class="title"><a name="idp62181448"></a>4.2.3. 空間テーブルを作る</h3></div></div></div><p>空間データを持つテーブルを生成するには、次の通り二段階で行います。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>通常の非空間テーブルを生成します。</p><p>たとえば、次のようにします。<span class="command"><strong>CREATE TABLE ROADS_GEOM ( ID int4, NAME varchar(25) )</strong></span></p></li><li class="listitem"><p>OpenGISの"AddGeometryColumn"関数によって空間カラムをテーブルに追加します。</p><p>The syntax is: </p><pre class="programlisting">AddGeometryColumn(&lt;schema_name&gt;, &lt;table_name&gt;,
            &lt;column_name&gt;, &lt;srid&gt;, &lt;type&gt;,
            &lt;dimension&gt;)</pre><p> Or, using current schema: </p><pre class="programlisting">AddGeometryColumn(&lt;テーブル名&gt;,
            &lt;カラム名&gt;, &lt;SRID&gt;, &lt;タイプ&gt;,
            &lt;次元&gt;)</pre><p>
	    </p><p>例1: <span class="command"><strong>SELECT AddGeometryColumn('public', 'roads_geom', 'geom', 423, 'LINESTRING', 2)</strong></span></p><p>例2: <span class="command"><strong>SELECT AddGeometryColumn( 'roads_geom', 'geom', 423, 'LINESTRING', 2)</strong></span></p></li></ul></div><p>次はテーブルを作成して空間カラムを作る例です (128というSRIDがあると仮定します)。</p><pre class="programlisting">CREATE TABLE parks ( PARK_ID int4, PARK_NAME varchar(128), PARK_DATE date, PARK_TYPE varchar(2) );
SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );</pre><p>もうひとつ、ジェネリックな「ジオメトリ」型とSRID不明を示す-1を使った例を挙げます。</p><pre class="programlisting">CREATE TABLE roads ( ROAD_ID int4, ROAD_NAME varchar(128) ); 
SELECT AddGeometryColumn( 'roads', 'roads_geom', -1, 'GEOMETRY', 3 );</pre></div><div class="sect2" title="4.2.4. ジオメトリのOpenGIS準拠を確実にする"><div class="titlepage"><div><div><h3 class="title"><a name="idp62194376"></a>4.2.4. ジオメトリのOpenGIS準拠を確実にする</h3></div></div></div><p>GEOSライブラリで実装される関数のほとんどが、ジオメトリがOpenGIS単純フィーチャー仕様の定義から見て妥当であることが仮定されています。ジオメトリの妥当性のチェックには、<a class="link" href="#IsValid">IsValid()</a>関数を使います。例を次に示します。</p><pre class="programlisting">gisdb=# select isvalid('LINESTRING(0 0, 1 1)'), isvalid('LINESTRING(0 0,0 0)');
 isvalid | isvalid
---------+---------
 t       | f</pre><p>デフォルトでは、PostGISはジオメトリ入力に関するこの妥当性チェックを適用しません。複雑なジオメトリの妥当性のチェックはCPU時間を多く必要とするためです。データソースが信用できない場合は、手動でこのチェックを強制するための制約を付けることができます。</p><pre class="programlisting">ALTER TABLE mytable ADD CONSTRAINT geometry_valid_check CHECK (isvalid(the_geom));</pre><p>妥当な入力ジオメトリでPostGIS関数を呼んだのに「GEOS Intersection()がエラーを投げました!」や「JTS Intersection()がエラーを投げました!」というようなメッセージに遭遇したら、それはたぶん、PostGISまたは使用しているライブラリの中のエラーを発見しました。PostGIS開発者に連絡するべきです。PostGIS関数が妥当である入力ジオメトリから妥当でないジオメトリが返る場合も同じです。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>厳格にOGCジオメトリに準拠すると、Z値やM値を持てません。<a class="link" href="#">ST_IsValid()</a>は高次を考慮に入れません。<a class="link" href="#AddGeometryColumn">AddGeometryColumn()</a>を実行するとジオメトリの次元をチェックする制約が加わるので、そこで2を指定すれば十分です。 </p></div></div></div><div class="sect1" title="4.3. GISデータのロード"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62199752"></a>4.3. GISデータのロード</h2></div></div></div><p>空間テーブルを作成したら、これでGISデータをデータベースにアップロードする準備ができたことになります。現在、PostGIS/PostgreSQLデータベースにデータをロードするには、SQLステートメントを使う、またはシェープファイルのローダ/ダンパを使う、二つの方法があります。</p><div class="sect2" title="4.3.1. SQLを使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp62204872"></a>4.3.1. SQLを使う</h3></div></div></div><p>データをテキスト表現に変換できるなら、フォーマットされたSQLを使うのがデータをPostGISに入れる最も簡単な方法です。Oracleや他のSQLデータベースを使うように、SQL端末モニタにSQLの"INSERT"ステートメントで一杯になった大きなテキストファイルをパイプで送ることで、大量のデータをロードできます。</p><p>データアップロードファイル (たとえば<code class="filename">roads.sql</code>)は次のようになるでしょう。</p><pre class="programlisting">BEGIN;
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (1,GeomFromText('LINESTRING(191232 243118,191108 243242)',-1),'Jeff Rd'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (2,GeomFromText('LINESTRING(189141 244158,189265 244817)',-1),'Geordie Rd'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (3,GeomFromText('LINESTRING(192783 228138,192612 229814)',-1),'Paul St'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (4,GeomFromText('LINESTRING(189412 252431,189631 259122)',-1),'Graeme Ave'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (5,GeomFromText('LINESTRING(190131 224148,190871 228134)',-1),'Phil Tce'); 
INSERT INTO ROADS_GEOM (ID,GEOM,NAME ) VALUES (6,GeomFromText('LINESTRING(198231 263418,198213 268322)',-1),'Dave Cres');
COMMIT;</pre><p>データファイルは、次に示す"psql"というSQL端末モニタを使って、簡単にPostgreSQLにパイプで送ることができます。</p><pre class="programlisting">psql -d [データベース名] -f roads.sql</pre></div><div class="sect2" title="4.3.2. ローダを使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp62208328"></a>4.3.2. ローダを使う</h3></div></div></div><p><code class="filename">shp2pgsql</code>データローダは、ESRIシェープファイルをPostGIS/PostgreSQLデータベースに挿入するための適切なSQLに変換します。ローダには、次に示すコマンドラインフラグによって識別される、いくつかの操作モードがあります。</p><div class="variablelist"><dl><dt><span class="term">-d</span></dt><dd><p>シェープファイルにあるデータを持つ新しいテーブルを作成する前にデータベーステーブルを削除します。</p></dd><dt><span class="term">-a</span></dt><dd><p>シェープファイルからデータベーステーブルにデータを追加します。複数のファイルをロードするためにこのオプションを使う場合は、これらのファイルは同じ属性と同じデータ型を持つ必要があります。</p></dd><dt><span class="term">-c</span></dt><dd><p>新しいテーブルの作成とシェープファイルからのデータの読み込みを行います。<span class="emphasis"><em>これがデフォルトモードです</em></span>。</p></dd><dt><span class="term">-p</span></dt><dd><p>テーブル作成のSQLコードを生成するだけで、実際のデータは追加しません。このモードは、テーブル作成とデータロードとを完全に分けたい場合に使用します。</p></dd><dt><span class="term">-D</span></dt><dd><p>出力データにPostgreSQLのダンプ書式を用います。このモードは-a, -c, -dと組み合わせて利用します。デフォルトの"insert"によるSQL書式よりも、大変早くロードできます。大きなデータセットではこちらを使用して下さい。</p></dd><dt><span class="term">-s &lt;SRID&gt;</span></dt><dd><p>指定したSRIDでジオメトリデーブルの作成とデータの読み込みを行います。</p></dd><dt><span class="term">-k</span></dt><dd><p>識別子 (カラム、スキーマおよび属性)の大文字小文字を保持します。シェープファイルの属性は全て大文字であることに注意して下さい。</p></dd><dt><span class="term">-i</span></dt><dd><p>全ての整数を標準の32ビット整数に強制します。DBFヘッダではそれが正当であったとしても、64ビットのbigintを生成しません。</p></dd><dt><span class="term">-w</span></dt><dd><p>古い版 (0.x版)のPostGISのためにWKT書式を出力します。このオプションを使うと、座標変動が発生したり、M値が削除されることに注意して下さい。 </p></dd></dl></div><p>-a, -c, -dおよび-pは互いに排他的であることに注意して下さい。</p><p>ローダを使って入力ファイルを生成してアップロードするセッション例は次の通りです。</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable &gt; roads.sql 
# psql -d roadsdb -f roads.sql</pre><p>変換とアップロードはUNIXのパイプを使うと一回で実行できます。</p><pre class="programlisting"># shp2pgsql shaperoads myschema.roadstable | psql -d roadsdb</pre></div></div><div class="sect1" title="4.4. GISデータを検索する"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62226888"></a>4.4. GISデータを検索する</h2></div></div></div><p>データは、SQLまたはシェープファイルローダ/ダンパを使ってデータベースから抜き出すことができます。SQLに関する節において、空間テーブルでの比較とクエリを行うために用いることができる演算子のいくつかを議論します。</p><div class="sect2" title="4.4.1. SQLを使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp62227912"></a>4.4.1. SQLを使う</h3></div></div></div><p>データベースからデータを引き出す最もストレートな手段は、次のように、SQLのSELECTクエリを使ってカラムを可読なテキストファイルとして出力することです。</p><pre class="programlisting">db=# SELECT id, AsText(geom) AS geom, name FROM ROADS_GEOM; 
id | geom                                    | name 
---+-----------------------------------------+-----------
 1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd  
 2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd 
 3 | LINESTRING(192783 228138,192612 229814) | Paul St 
 4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave 
 5 | LINESTRING(190131 224148,190871 228134) | Phil Tce 
 6 | LINESTRING(198231 263418,198213 268322) | Dave Cres 
 7 | LINESTRING(218421 284121,224123 241231) | Chris Way 
(6 rows)</pre><p>しかし、返ってくる結果の数を削るために、なんらかの制限をかけることが重要となるときがあるでしょう。属性ベースの制限の場合、非空間テーブルで使う通常の文法と同じSQLを使うだけです。空間ベースの制限の場合、次の演算子が使用可能であり、便利です。</p><div class="variablelist"><dl><dt><span class="term">&amp;&amp;</span></dt><dd><p>この演算子で、一つのジオメトリのバウンディングボックスが他のバウンディングボックスとインタセクトするかを問い合わせることができます。</p></dd><dt><span class="term">~=</span></dt><dd><p>この演算子で、二つのジオメトリが幾何的に同一であるかを見ることができます。 たとえば、'POLYGON((0 0,1 1,1 0,0 0))' は 'POLYGON((0 0,1 1,1 0,0 0))' と同じかを見ることができます (これは同じとなります)。</p></dd><dt><span class="term">=</span></dt><dd><p>この演算子は他より若干素朴なもので、二つのジオメトリのバウンディングボックスが同じかを見るだけです。</p></dd></dl></div><p>次に、これらの演算子をクエリで使うことができます。SQLコマンドラインからジオメトリとボックスの特定を行うときは、"GeomFromText()"関数で、明示的に文字列表現をジオメトリに変換しなければならないことに注意して下さい。たとえば、次のようになります。</p><pre class="programlisting">SELECT 
  ID, NAME 
FROM ROADS_GEOM 
WHERE 
  GEOM ~= GeomFromText('LINESTRING(191232 243118,191108 243242)',-1);</pre><p>上のクエリは"ROADS_GEOM"テーブルから、その値と等価である単一のレコードを返します。</p><p>"&amp;&amp;"演算子を使うとき、比較フィーチャーをBOX3DかGEOMETRYかに指定することができます。ただし、GEOMETRYを指定すると、それのバウンディングボックスが比較に使われます。</p><pre class="programlisting">SELECT 
  ID, NAME 
FROM ROADS_GEOM 
WHERE 
  GEOM &amp;&amp; GeomFromText('POLYGON((191232 243117,191232 243119,191234 243117,191232 243117))',-1);</pre><p>上のクエリでは、比較するためにポリゴンのバウンディングボックスを用いています。</p><p>最も一般的な空間クエリは「フレームベース」のクエリでしょう。これは、表示するためのデータの価値のある「マップフレーム」を取得するために、データブラウザやウェブマッパのようなクライアントソフトウェアに使われます。このフレームで"BOX3D"オブジェクトを使う場合は、次のようなクエリになります。</p><pre class="programlisting">SELECT 
  AsText(GEOM) AS GEOM 
FROM ROADS_GEOM 
WHERE 
  GEOM &amp;&amp; GeomFromText('BOX3D(191232 243117,191232 243119)'::box3d,-1);</pre><p>ここで、BOX3Dの投影を指定するためにSRIDを使っていることに注意して下さい。SRIDを-1に設定しているのは、SRIDを指定しないということを示しています。</p></div><div class="sect2" title="4.4.2. ダンパを使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp62251464"></a>4.4.2. ダンパを使う</h3></div></div></div><p><code class="filename">pgsql2shp</code>テーブルダンパは、データベースに直接接続して、テーブル (あるいはクエリによって定義されたもの)をシェープファイルに変換するものです。基本的な文法は次の通りです。</p><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; [&lt;スキーマ&gt;.]&lt;テーブル&gt;</pre><pre class="programlisting">pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; &lt;クエリ&gt;</pre><p>コマンドラインオプションは次の通りです。</p><div class="variablelist"><dl><dt><span class="term">-f &lt;ファイル名&gt;</span></dt><dd><p>特定のファイル名に出力を書きこみます。</p></dd><dt><span class="term">-h &lt;ホスト&gt;</span></dt><dd><p>接続先データベースのホスト名。</p></dd><dt><span class="term">-p &lt;ポート&gt;</span></dt><dd><p>接続先データベースのポート。</p></dd><dt><span class="term">-P &lt;パスワード&gt;</span></dt><dd><p>データベースに接続するためのパスワード。</p></dd><dt><span class="term">-u &lt;ユーザ名&gt;</span></dt><dd><p>データベースに接続する際のユーザ名。</p></dd><dt><span class="term">-g &lt;ジオメトリカラム&gt;</span></dt><dd><p>複数のジオメトリカラムを持つテーブルの場合の、シェープファイルの出力に使用するジオメトリカラム。</p></dd><dt><span class="term">-b</span></dt><dd><p>バイナリカーソルを使います。これは、実行時間を短くしますが、テーブルの非ジオメトリ属性がテキストへのキャストを持っていない場合には、動作しません。</p></dd><dt><span class="term">-r</span></dt><dd><p>Rawモード。<code class="varname">gid</code>フィールドを落としたり、カラム名をエスケープしてはいけません。</p></dd><dt><span class="term">-d</span></dt><dd><p>後方互換: 古い (1.0.0より前)のPostGISデータベースからダンプする際に3次元のシェープファイルを出力します (デフォルトでは2次元になります)。 PostGIS 1.0.0以上では、次元は完全に反映されます。 </p></dd></dl></div></div></div><div class="sect1" title="4.5. インデックスを構築する"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62269128"></a>4.5. インデックスを構築する</h2></div></div></div><p>インデックスは大きなデータセットを持つ空間データベースの利用を可能にするものです。インデックスなしでは、フィーチャーの検索でデータベースの全レコードを「シーケンシャルスキャン」する必要があります。インデックスをつけることで、データを検索木に組織化して、特定のレコードを発見するための検索をより早くすることができます。 PostgreSQLは、B木、R木、GiSTの3種類のインデックスをデフォルトでサポートしています。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>B木は、数字、文字、日付といった、一つの軸に沿ってソートできるデータに使用します。 GISデータは合理的に一つの軸に沿ったソートはできません ((0,0)と(0,1)と(1,0)で大きいのはどれでしょう?)ので、B木インデックスは、ここでは使えません。</p></li><li class="listitem"><p>R木はデータを長方形に分割して、さらにその長方形を小さい長方形に分割していったものです。R木はいくつかの空間データベースでGISデータのインデックスに使われますが、PostgreSQLのR木実装は、GiST実装ほどにロバストではありません。</p></li><li class="listitem"><p>GiST (Generalized Search Trees)インデックスはデータを「一方へのもの」 (訳注: 「左側にあるもの」「上側にあるもの」など)、「オーバラップするもの」、「中にあるもの」に分割して、GISデータを含む幅広いデータ型で使えるようにしたものです。PostGISではGISデータにインデックスを付けるためにGiSTの上でR木インデックス実装を使用しています。</p></li></ul></div><div class="sect2" title="4.5.1. GiSTインデックス"><div class="titlepage"><div><div><h3 class="title"><a name="idp61085000"></a>4.5.1. GiSTインデックス</h3></div></div></div><p>GiSTは「汎用的な検索木 (Generalized Search Tree)」の意味で、インデックスの一般化された形式です。GISインデックスに加えて、GiSTは通常のB木インデックスに従わない全ての種類の不規則なデータ構造 (整数配列, スペクトラルデータ等)の検索速度を向上させるために使います。</p><p>ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデックスを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常のインデックスを属性フィールドに追加します)。</p><p>GiSTインデックスをジオメトリカラムに追加するための文は次の通りです。</p><pre class="programlisting">CREATE INDEX [indexname] ON [tablename] 
  USING GIST ( [geometryfield] GIST_GEOMETRY_OPS ); </pre><p>空間インデックスの構築は、計算量を集中させて行われます。100万行のテーブルで、300MHzのSolaris機ではGiSTインデックスの構築に概ね1時間かかりました。インデックスを構築したあとは、クエリプランの最適化に使うため、次のようにPostgreSQLにテーブル統計情報の収集をさせることが重要です。</p><pre class="programlisting">VACUUM ANALYZE [テーブル名] [カラム名];
-- 次のクエリはPostgreSQL 7.4以前でのみ必要です
SELECT UPDATE_GEOMETRY_STATS( [テーブル名], [カラム名] );</pre><p>GiSTインデックスはPostgreSQLのR木インデックスと比べて二つの利点を持っています。まず、GiSTインデックスは「NULLセーフ」、すなわちNULL値を含むインデックスカラムで利用できることです。次に、GiSTインデックスはGISオブジェクトがPostgreSQLで8Kのページサイズを超えるサイズを扱う際に重要な「不可逆」の概念を持っていることです。不可逆にすることによって、PostgreSQLは、インデックスにおけるオブジェクトの「重要な」部分、GISオブジェクトの場合にはバウンディングボックスになりますが、これのみを納めることができます。 R木インデックスで8Kを超えるGISオブジェクトのインデックスを構築しようとすると、失敗します。</p></div><div class="sect2" title="4.5.2. インデックスを使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp61088968"></a>4.5.2. インデックスを使う</h3></div></div></div><p>通常、インデックスは見えないところでデータアクセスの速度向上を行います。すなわち、ひとたびインデックスが構築されたら、クエリプランナは透過的に、クエリプランの速度を向上させるためにインデックス情報を使うべき時を判断します。残念なことに、PostgreSQLクエリプランナは、GiSTインデックスの使用について十分に最適化できず、時々、検索で空間インデックスを使用すべきなのに、テーブル全体を順に走査することがあります。</p><p>空間インデックスが使用されていない (または属性インデックスがその問題のために使用されていない)場合、次の二つのことができます。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>まず、クエリプランナにインデックス使用まわりの判断に利用するためのより良い情報を提供するために、値の数量と分散に関する統計情報が収集されたかを確認してください。PostgreSQL 7.4以前では、<span class="command"><strong>update_geometry_stats([テーブル名], [カラム名])</strong></span> (分散計算)と<span class="command"><strong>VACUUM ANALYZE [テーブル名] [カラム名]</strong></span> (値の数量の計算)とを実行します。PostgreSQL 8.0については、<span class="command"><strong>VACUUM ANALYZE</strong></span>を実行することで同じ動作になります。常に定期的なデータベースへのvacuumを実行すべきです。多くのPostgreSQLのデータベースエージェントは、閑散時のcronジョブとして定期的に<span class="command"><strong>VACUUM</strong></span>を実行します。</p></li><li class="listitem"><p>vacuumが働かないなら、<span class="command"><strong>SET ENABLE_SEQSCAN=OFF</strong></span>コマンドで、プランナにインデックス情報を強制的に使わせることができます。このコマンドは控え目に実行すべきで、かつ、空間インデックスがあるクエリ上でのみ使うべきです。一般的に言うと、通常のB木インデックスを使うべき時に関してあなたが知っていることよりも、プランナはより良く知っています。クエリを実行したら、<code class="varname">ENABLE_SEQSCAN</code>設定を戻して、他のクエリでは通常通りプランナを使用することを考えるべきです。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>0.6版では、<code class="varname">ENABLE_SEQSCAN</code>でプランナにインデックスを強制的に使わせることは重要ではありません。</p></div></li><li class="listitem"><p>順に走査する際のコストとインデックスを使う際のコストとを比較してプランナが間違っていることに気付いたら、postgresql.confでrandom_page_costの値を減らしてみるか"SET random_page_cost=#"を使ってみてください。このパラメータのデフォルト値は4ですが、1か2にしてみて下さい。値を減らすことでプランナがよりインデックス検索を行う傾向になります。</p></li></ul></div></div></div><div class="sect1" title="4.6. 複雑なクエリ"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp61097672"></a>4.6. 複雑なクエリ</h2></div></div></div><p>空間データベース機能の<span class="emphasis"><em>レゾンデートル</em></span>は、通常はデスクトップGISに求める機能を、データベース内部のクエリで実現することです。PostGISを効果的に使用するには、どの空間機能が有効かを知り、また、良い性能を提供する所に適切にインデックスがあることが保証されていることが求められます。</p><div class="sect2" title="4.6.1. インデックスの利点を使う"><div class="titlepage"><div><div><h3 class="title"><a name="idp61099080"></a>4.6.1. インデックスの利点を使う</h3></div></div></div><p>クエリを作成するとき、 &amp;&amp;のようなバウンディングボックスを基準とした演算子によってのみGiST空間インデックスの利点が出てくることだけは覚えておくことが重要です。<code class="varname">distance()</code>のような関数では演算の最適化を行うためにインデックスを使うことができません。 たとえば、次のクエリでは、大きなテーブルでは本当に遅くなります。</p><pre class="programlisting">SELECT the_geom FROM geom_table
WHERE distance( the_geom, GeomFromText( 'POINT(100000 200000)', -1 ) ) &lt; 100</pre><p>このクエリは、geom_tableにおける (100000, 200000) の点から距離が100単位以内にある全てのジオメトリを選択します。これは、テーブル内にあるそれぞれの点と指定した点との距離を計算する、すなわち、それぞれの行でひとつの<code class="varname">distance()</code>計算を行うため、遅くなるのです。&amp;&amp;演算子を使うと、求められる距離計算の量を減らすことで回避できます。次のようにします。</p><pre class="programlisting">SELECT the_geom FROM geom_table
WHERE the_geom &amp;&amp; 'BOX3D(90900 190900, 100100 200100)'::box3d
  AND distance( the_geom, GeomFromText( 'POINT(100000 200000)', -1 ) ) &lt; 100</pre><p>このクエリは、同じジオメトリを選択しますが、より効果的な方法で行われます。the_geomにGiSTインデックスがあると仮定すると、クエリプランナは、<code class="varname">distance()</code>関数の結果を計算する前に行を減らすためにインデックスを使うことができると認識します。&amp;&amp;演算子で使われている<code class="varname">BOX3D</code>ジオメトリは、指定位置を中心とした一辺200単位の正方形です。これが「クエリボックス」です。&amp;&amp;演算子は 結果セットを「クエリボックス」にオーバラップするバウンディングボックスを持つジオメトリだけに素早く減らすためにインデックスを使います。「クエリボックス」がジオメトリテーブル全体の範囲より十分に小さいと仮定すると、行われなければならない距離計算の量は劇的に減少します。</p></div><div class="sect2" title="4.6.2. 空間SQLの例"><div class="titlepage"><div><div><h3 class="title"><a name="idp62303688"></a>4.6.2. 空間SQLの例</h3></div></div></div><p>本節の例では、線型の道、ポリゴンの自治体境界、の二つのテーブルを使います。テーブルの定義をしまします。<code class="varname">bc_roads</code>については次の通りです。</p><pre class="programlisting">Column    |       Type        |   Description
------------+-------------------+-------------------
 gid        | integer           | Unique ID
 name       | character varying | Road Name
 the_geom   | geometry          | Location Geometry (Linestring)</pre><p><code class="varname">bc_municipality</code>テーブルの定義については次の通りです。</p><pre class="programlisting">Column   |       Type        |   Description
-----------+-------------------+-------------------
 gid       | integer           | Unique ID
 code      | integer           | Unique ID
 name      | character varying | City / Town Name
 the_geom  | geometry          | Location Geometry (Polygon)</pre><div class="qandaset" title="よくある質問"><a name="idp62327240"></a><dl><dt></dt><dd><dl><dt>4.6.2.1.1. <a href="#idp62327752">道路の総延長はkm表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.2. <a href="#idp62330184">プリンスジョージ市の大きさはha表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.3. <a href="#idp62332744">県内で最も大きな面積となる自治体はどこでしょう?</a></dt><dt>4.6.2.1.4. <a href="#idp62335560">各自治体内に含まれる道路の総延長はいくらでしょう?</a></dt><dt>4.6.2.1.5. <a href="#idp62338376">プリンスジョージ市内の全ての道路からなるテーブルを作る</a></dt><dt>4.6.2.1.6. <a href="#idp62340808">ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.7. <a href="#idp62342856">穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</a></dt></dl></dd></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>4.6.2.1.1. <a href="#idp62327752">道路の総延長はkm表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.2. <a href="#idp62330184">プリンスジョージ市の大きさはha表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.3. <a href="#idp62332744">県内で最も大きな面積となる自治体はどこでしょう?</a></dt><dt>4.6.2.1.4. <a href="#idp62335560">各自治体内に含まれる道路の総延長はいくらでしょう?</a></dt><dt>4.6.2.1.5. <a href="#idp62338376">プリンスジョージ市内の全ての道路からなるテーブルを作る</a></dt><dt>4.6.2.1.6. <a href="#idp62340808">ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</a></dt><dt>4.6.2.1.7. <a href="#idp62342856">穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</a></dt></dl></td></tr><tr class="question" title="4.6.2.1.1."><td align="left" valign="top"><a name="idp62327752"></a><a name="idp62328008"></a><p><b>4.6.2.1.1.</b></p></td><td align="left" valign="top"><p>道路の総延長はkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>この問題は、次のようなとても単純なSQLで答を得ることができます。</p><pre class="programlisting">postgis=# SELECT sum(length(the_geom))/1000 AS km_roads FROM bc_roads;
     km_roads
------------------
 70842.1243039643
(1 row)</pre></td></tr><tr class="question" title="4.6.2.1.2."><td align="left" valign="top"><a name="idp62330184"></a><a name="idp62330440"></a><p><b>4.6.2.1.2.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市の大きさはha表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリでは、属性条件 (municipality name, 自治体名)に空間計算 (面積)を併用しています。</p><pre class="programlisting">postgis=# SELECT area(the_geom)/10000 AS hectares FROM bc_municipality 
          WHERE name = 'PRINCE GEORGE';
     hectares
------------------
 32657.9103824927
(1 row) </pre></td></tr><tr class="question" title="4.6.2.1.3."><td align="left" valign="top"><a name="idp62332744"></a><a name="idp62333000"></a><p><b>4.6.2.1.3.</b></p></td><td align="left" valign="top"><p>県内で最も大きな面積となる自治体はどこでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>このクエリは、空間計測をクエリ条件に持ってきています。この問題へのアプローチの方法はいくつかありますが、最も効率的なのは次の通りです。</p><pre class="programlisting">postgis=# SELECT name, area(the_geom)/10000 AS hectares 
          FROM bc_municipality 
          ORDER BY hectares DESC 
          LIMIT 1;
     name      |    hectares
---------------+-----------------
 TUMBLER RIDGE | 155020.02556131
(1 row)</pre><p>このクエリの答を出すためには、全てのポリゴンの面積を求める必要があることに注意して下さい。このクエリを多く実行する場合、性能向上のためにテーブルにareaカラムを追加して、別のインデックスを追加することができるようにするのは、意義のあることです。結果を距離について降順に並べ替え、PostgreSQLの"LIMIT"コマンドを用いることで、max()のような集約関数を使わずに、簡単に最も大きい値を得ることができます。</p></td></tr><tr class="question" title="4.6.2.1.4."><td align="left" valign="top"><a name="idp62335560"></a><a name="idp62335816"></a><p><b>4.6.2.1.4.</b></p></td><td align="left" valign="top"><p>各自治体内に含まれる道路の総延長はいくらでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは、二つのテーブルからデータを持ち込んで (結合して)いるので「空間結合」の例です。しかし、結合の条件として共通キーの上で接続するという普通のリレーションのやり方でなく空間インタラクション条件 (「含む」)を使っています。</p><pre class="programlisting">postgis=# SELECT m.name, sum(length(r.the_geom))/1000 as roads_km 
          FROM bc_roads AS r,bc_municipality AS m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND contains(m.the_geom,r.the_geom) 
          GROUP BY m.name 
          ORDER BY roads_km;

            name            |     roads_km
----------------------------+------------------
 SURREY                     | 1539.47553551242
 VANCOUVER                  | 1450.33093486576
 LANGLEY DISTRICT           | 833.793392535662
 BURNABY                    | 773.769091404338
 PRINCE GEORGE              |  694.37554369147
 ...</pre><p>このクエリは、テーブル内の全ての道路の合計を最終結果 (この例での話ですが約250Kmの道です)にまとめられるので、少し時間がかかります。より小さいオーバレイ (数百の道路で数千のレコード)の場合、応答はもっと早くなりえます。</p></td></tr><tr class="question" title="4.6.2.1.5."><td align="left" valign="top"><a name="idp62338376"></a><a name="idp62338632"></a><p><b>4.6.2.1.5.</b></p></td><td align="left" valign="top"><p>プリンスジョージ市内の全ての道路からなるテーブルを作る</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>これは「オーバレイ」の例です。つまり、二つのテーブルを取得して、空間的に切り取られた結果からなる新しいテーブルを出力します。上で示した「空間結合」と違い、このクエリは実際に新しいジオメトリを生成します。生成されたオーバレイはターボのかかった空間結合みたいなもので、より確かな解析作業に便利です。</p><pre class="programlisting">postgis=# CREATE TABLE pg_roads as
          SELECT intersection(r.the_geom, m.the_geom) AS intersection_geom, 
                 length(r.the_geom) AS rd_orig_length, 
                 r.* 
          FROM bc_roads AS r, bc_municipality AS m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND intersects(r.the_geom, m.the_geom) 
          AND m.name = 'PRINCE GEORGE';</pre></td></tr><tr class="question" title="4.6.2.1.6."><td align="left" valign="top"><a name="idp62340808"></a><a name="idp62341064"></a><p><b>4.6.2.1.6.</b></p></td><td align="left" valign="top"><p>ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">postgis=# SELECT sum(length(r.the_geom))/1000 AS kilometers 
          FROM bc_roads r, bc_municipality m 
          WHERE r.the_geom &amp;&amp; m.the_geom 
          AND r.name = 'Douglas St' 
          AND m.name = 'VICTORIA';
    kilometers
------------------
 4.89151904172838
(1 row)</pre></td></tr><tr class="question" title="4.6.2.1.7."><td align="left" valign="top"><a name="idp62342856"></a><a name="idp62343112"></a><p><b>4.6.2.1.7.</b></p></td><td align="left" valign="top"><p>穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><pre class="programlisting">postgis=# SELECT gid, name, area(the_geom) AS area 
          FROM bc_municipality 
          WHERE nrings(the_geom) &gt; 1 
          ORDER BY area DESC LIMIT 1;
 gid |     name     |       area
-----+--------------+------------------
  12 | SPALLUMCHEEN | 257374619.430216
(1 row)</pre></td></tr></tbody></table></div></div></div><div class="sect1" title="4.7. MapServerを使う"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62374088"></a>4.7. MapServerを使う</h2></div></div></div><p>Minnesota MapServerはOpenGIS Web Mapping Server仕様を満たすウェブマッピングサーバです。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>MapServerのウェブページは<a class="ulink" href="http://mapserver.gis.umn.edu" target="_top">http://mapserver.gis.umn.edu</a>にあります (訳注: 現在は <a class="ulink" href="http://mapserver.org/" target="_top">http://mapserver.org/</a>にあります)。</p></li><li class="listitem"><p>OpenGISウェブマップ仕様は<a class="ulink" href="http://www.opengis.org/techno/specs/01-047r2.pdf" target="_top">http://www.opengis.org/techno/specs/01-047r2.pdf</a>にあります。</p></li></ul></div><div class="sect2" title="4.7.1. 基本的な使い方"><div class="titlepage"><div><div><h3 class="title"><a name="idp62382664"></a>4.7.1. 基本的な使い方</h3></div></div></div><p>MapServerでPostGISを使うには、MapServerのコンフィギュレーション方法についての知識が必要ですが、この文書の範囲外です。この節では、PostGIS特有の問題とコンフィギュレーション詳細について記載します。</p><p>MapServerでPostGISを使うには、次のものが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>PostGIS 0.6以上</p></li><li class="listitem"><p>MapServer 3.5以上</p></li></ul></div><p>MapServerは、他のPostgreSQLクライアントのように、<code class="filename">libpq</code>を使ってPostGIS/PostgreSQLデータにアクセスします。これは、システムがPostgreSQLクライアントライブラリである<code class="filename">libpq</code>を持っている限りは、PostGISサーバへのネットワークアクセスを持つあらゆる機械にMapServerをインストールできるということを示しています。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>"--with-postgis"と好きなconfigureオプションを付けてMpaserverのコンパイルとインストールを行います。</p></li><li class="listitem"><p>MapServerのmapファイルの中に、PostGISレイヤを追加します。たとえば次のようになります。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "widehighways"
  # リモートの空間データベースに接続します
  CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
  # 'roads'テーブルの'geom'カラムからラインを取得します
  DATA "geom from roads"
  STATUS ON
  TYPE LINE
  # 範囲内のラインのうち、広い高速道路のみ描画します
  FILTER "type = 'highway' and numlanes &gt;= 4"
  CLASS
    # 非常に広い高速道路はより明るい色かつ2ピクセル幅にします
    EXPRESSION ([numlanes] &gt;= 6)
    COLOR 255 22 22      
    SYMBOL "solid"
    SIZE 2
  END
  CLASS
    # 残りは、暗い色かつ1ピクセル幅です
    EXPRESSION ([numlanes] &lt; 6)
    COLOR 205 92 82      
  END
END</pre><p>上の例におけるPostGIS特有のディレクティブは次の通りです。</p><div class="variablelist"><dl><dt><span class="term">CONNECTIONTYPE</span></dt><dd><p>PostGISレイヤでは常に"postgis"とします。</p></dd><dt><span class="term">CONNECTION</span></dt><dd><p>データベース接続は「接続文字列」によって制御されます。接続文字列は、次に示すような標準的なキーと値からなります(&lt;&gt;内はデフォルト値)。</p><p>user=&lt;ユーザ名&gt; password=&lt;パスワード&gt; dbname=&lt;ユーザ名&gt; hostname=&lt;サーバ&gt; port=&lt;5432&gt;</p><p>空の接続文字列も妥当とされますし、あらゆるキーと値のペアは省略できます。接続するためには一般的にはdbnameとusernameとが最少で与えるものとなります。</p></dd><dt><span class="term">DATA</span></dt><dd><p>このパラメータの形式は "&lt;カラム名&gt; from &lt;テーブル名&gt;"となります。ここで、カラム名は地図に描画したい空間カラムを指します。</p></dd><dt><span class="term">FILTER</span></dt><dd><p>フィルタは、妥当なSQL文字列でなければなりません。この文字列は、通常はSQLクエリにおける"WHERE"に続く論理式に対応します。たとえば、6レーン以上の道路だけを描画する場合には、"num_lanes &gt;= 6"というフィルタを使います。</p></dd></dl></div></li><li class="listitem"><p>空間データベースにおいては、空間 (GiST)インデックスを、マップに描かれるレイヤ全てに構築していることを保証して下さい。</p><pre class="programlisting">CREATE INDEX [インデックス名]
  ON [テーブル名] 
  USING GIST ( [ジオメトリカラム] GIST_GEOMETRY_OPS );</pre></li><li class="listitem"><p>MapServerを使ってレイヤにクエリを発行する場合は、「oidインデックス」も必要です (訳注: PostgreSQL 8.1以降は、oidはデフォルトでは追加されなくなりました。替わりにSERIAL型フィールドを生成して使うべきです。テーブル生成時に"WITH OID"を付けるとoid付きテーブルが生成されます)。</p><p>MapServerからは、クエリを実行するときに、それぞれの空間レコードを識別する一意な識別子が求められ、MapServerのPostGISモジュールはPostgreSQLの<code class="varname">oid</code>値を一意な識別子に使います。これの副作用はクエリ内のレコードのランダムアクセスを早く行うのに<code class="varname">oid</code>インデックスが必要となることです。</p><p>「oidインデックス」を構築するには、次のようなSQLを実行します。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] ( oid );</pre></li></ol></div></div><div class="sect2" title="4.7.2. よくある質問"><div class="titlepage"><div><div><h3 class="title"><a name="idp62402120"></a>4.7.2. よくある質問</h3></div></div></div><div class="qandaset" title="よくある質問"><a name="idp62402760"></a><dl><dt></dt><dd><dl><dt>4.7.2.1.1. <a href="#idp62403272">EXPRESSIONをマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</a></dt><dt>4.7.2.1.2. <a href="#idp62418632">シェープファイルで使っているFILTERが、同じデータを持つPostGISテーブルでは動作しません。</a></dt><dt>4.7.2.1.3. <a href="#idp62421192">PostGISレイヤの描画がシェープファイルより遅くなりますが、これが普通なのでしょうか?</a></dt><dt>4.7.2.1.4. <a href="#idp62424008">PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</a></dt></dl></dd></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>4.7.2.1.1. <a href="#idp62403272">EXPRESSIONをマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</a></dt><dt>4.7.2.1.2. <a href="#idp62418632">シェープファイルで使っているFILTERが、同じデータを持つPostGISテーブルでは動作しません。</a></dt><dt>4.7.2.1.3. <a href="#idp62421192">PostGISレイヤの描画がシェープファイルより遅くなりますが、これが普通なのでしょうか?</a></dt><dt>4.7.2.1.4. <a href="#idp62424008">PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</a></dt></dl></td></tr><tr class="question" title="4.7.2.1.1."><td align="left" valign="top"><a name="idp62403272"></a><a name="idp62403528"></a><p><b>4.7.2.1.1.</b></p></td><td align="left" valign="top"><p><code class="varname">EXPRESSION</code>をマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>EXPRESIONで使うフィールド名は、シェープファイルと違ってPostGISの場合<span class="emphasis"><em>小文字</em></span>になります。</p><pre class="programlisting">EXPRESSION ([numlanes] &gt;= 6)</pre></td></tr><tr class="question" title="4.7.2.1.2."><td align="left" valign="top"><a name="idp62418632"></a><a name="idp62418888"></a><p><b>4.7.2.1.2.</b></p></td><td align="left" valign="top"><p>シェープファイルで使っているFILTERが、同じデータを持つPostGISテーブルでは動作しません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>シェープファイルと違い、PostGISレイヤのフィルタはSQL構文を使います (PostGISコネクタがMapServerでレイヤを描画するために生成するSQLステートメントに追加されます)。</p><pre class="programlisting">FILTER "type = 'highway' and numlanes &gt;= 4"</pre></td></tr><tr class="question" title="4.7.2.1.3."><td align="left" valign="top"><a name="idp62421192"></a><a name="idp62421448"></a><p><b>4.7.2.1.3.</b></p></td><td align="left" valign="top"><p>PostGISレイヤの描画がシェープファイルより遅くなりますが、これが普通なのでしょうか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一般的に、PostGISレイヤは同等のシェープファイルレイヤより10%遅いと考えて下さい。 データベースとMapServerとの間で発生するデータベース接続、データの変換と転送によってオーバヘッドが増えるためです。</p><p>重大な描画性能の問題があるようでしたら、テーブルにある空間インデックスを構築していないというのがありそうです。</p><pre class="programlisting">postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn );
postgis# SELECT update_geometry_stats();  -- PostgreSQL 8.0より後
postgis# VACUUM ANALYZE;                  -- PostgreSQL 8.0以前</pre></td></tr><tr class="question" title="4.7.2.1.4."><td align="left" valign="top"><a name="idp62424008"></a><a name="idp62424264"></a><p><b>4.7.2.1.4.</b></p></td><td align="left" valign="top"><p>PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>クエリを早くするには、空間テーブルに一意なキーを持たせ、そのキーにインデックスを持たせなければなりません。</p><p><code class="varname">DATA</code>行の<code class="varname">USING UNIQUE</code>節で、MapServerで使用する一意なキーをどれにするか指定することができます。</p><pre class="programlisting">DATA "the_geom FROM geotable USING UNIQUE gid"</pre><p>テーブルに明示的に一意なカラムが無い場合は、PostgreSQLの行"oid"を用いて一意なカラムを「模造する」ことができます。"oid"は、宣言していないなら、デフォルトの一意なカラムです。ですから、クエリ速度を強化するには、空間テーブルのoid値にインデックスを構築することです (訳注: PostgreSQL 8.1以降は、oidはデフォルトでは追加されなくなりました)。</p><pre class="programlisting">postgis# CREATE INDEX geotable_oid_idx ON geotable (oid);</pre></td></tr></tbody></table></div></div><div class="sect2" title="4.7.3. 踏み込んだ使用法"><div class="titlepage"><div><div><h3 class="title"><a name="idp62428744"></a>4.7.3. 踏み込んだ使用法</h3></div></div></div><p><code class="varname">USING</code>疑似SQL節を使ってMapServerがより複雑なクエリの結果を理解できるようにするための情報を追加します。より詳しく言うと、ビューまたは副問い合わせが元テーブル (<code class="varname">DATA</code>定義で"FROM"の右にあるもの)として使われる時、MapServerが自動的に一意な識別子がそれぞれの行にあるか、また、SRIDがテーブルにあるかを判別するのは困難です。<code class="varname">USING</code>節によって、MapServerがこれらの情報を得ることができます。例を次に挙げます。</p><pre class="programlisting">DATA "the_geom FROM (SELECT table1.the_geom AS the_geom, table1.oid AS oid, table2.data AS data
 FROM table1 LEFT JOIN table2 ON table1.id = table2.id) AS new_table USING UNIQUE oid USING SRID=-1"</pre><div class="variablelist"><dl><dt><span class="term">USING UNIQUE &lt;uniqueid&gt;</span></dt><dd><p>MapServerは、マップクエリを実行する際、行識別のために、それぞれの行に一意な識別子を求めます。 通常なら、oidを一意な識別子として使えますが、ビューや副問い合わせでは、自動的にoidを持つことができません。MapServerのクエリ機能を使いたいなら、一意性のあるカラムをビューまたは副問い合わせに追加する必要があり、<code class="varname">USING UNIQUE</code>宣言を付ける必要があります。たとえば、この目的のための主キー値のテーブルでのカラム名や、結果セットで一意性が保障されたカラムを明示的にSELECTに入れることができます。</p><p>マップクエリを実行する場合には、<code class="varname">USING</code>ステートメントは単純な<code class="varname">DATA</code>ステートメントに対しても便利なものになります。マップクエリの速度性能向上のために、クエリ実行可能なレイヤで使われるテーブルのoidカラムにインデックスを追加することを、前に推奨しました。しかしながら、USINGを使うと、MapServerがテーブルのプライマリキーをマップクエリの識別子に使うことができ、インデックスを追加する必要はもうありません。</p><div class="note" title="注記" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>「マップクエリ」はマップ上でクリックして、その場所におけるフィーチャーに関する情報を問い合わせる動作です。「マップクエリ」と<code class="varname">DATA</code>定義におけるSQLクエリと混同しないで下さい。</p></div></dd><dt><span class="term">USING SRID=&lt;srid&gt;</span></dt><dd><p>PostGISは、MapServerに正しいデータを返すために、ジオメトリがどの空間参照系を使っているかを知る必要があります。通常は、この情報はPostGISデータベースの"geometry_columns"テーブルから得ることができます。しかし、副問い合わせやビューのような一時テーブルでは、この方法は不可能です。そこで、<code class="varname">USING SRID=</code>オプションを使って、正しいSRIDが<code class="varname">DATA</code>定義で使われるように指定します。</p></dd></dl></div><div class="warning" title="警告" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">警告</h3><p>MapserverのPostGISレイヤのパーサは、かなり原始的で、大文字小文字を区別するところが2,3あります。全てのSQLキーワードと全ての<code class="varname">USING</code>節が大文字であることを保証し、<code class="varname">USING UNIQUE</code>節が<code class="varname">USING SRID</code>節より前に来るようにして下さい。</p></div></div><div class="sect2" title="4.7.4. 例"><div class="titlepage"><div><div><h3 class="title"><a name="idp62448456"></a>4.7.4. 例</h3></div></div></div><p>簡単な例から始めて、ステップアップしていきましょう。次のMapServerレイヤ定義を考えて下さい。</p><pre class="programlisting">LAYER
 CONNECTIONTYPE postgis
 NAME "roads"
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 STATUS ON
 TYPE LINE
 CLASS
  COLOR 0 0 0
 END
END</pre><p>このレイヤは"roads"テーブルにある道路ジオメトリの全部を黒線で表示するものです。</p><p>では、少なくとも1:100000にズームするまでは高速道路だけを表示したい、としましょう。次の二つのレイヤで、その効果が実現できます。</p><pre class="programlisting">LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 MINSCALE 100000
 STATUS ON
 TYPE LINE
 FILTER "road_type = 'highway'"
 CLASS
  COLOR 0 0 0
 END
END

LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM roads"
 MAXSCALE 100000
 STATUS ON
 TYPE LINE
 CLASSITEM road_type
 CLASS
  EXPRESSION "highway"
  SIZE 2
  COLOR 255 0 0
 END
 CLASS
  COLOR 0 0 0
 END
END</pre><p>一つ目のレイヤはスケールが1:100000以上であるときに使われ、道路タイプが"highway"である道路のみ黒線で表示されます。<code class="varname">FILTER</code>オプションによって、道路タイプが"highway"の場合のみ表示することになります。</p><p>二つ目のレイヤはスケールが1:100000未満である時に使われ、"highway"は赤い二重細線で表示され、他の道路は黒線で表示されます。</p><p>さて、MapServerの機能を使うだけで、二つのおもしろいことを実行しました。しかし、<code class="varname">DATA</code>のSQLステートメントは、単純なままです。道路名が (どういう理由かは知りませんが)他のテーブルに収められていて、それのデータを取得するためにテーブルを連結して、道路のラベルを取る必要がある、とします。</p><pre class="programlisting">LAYER
 CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
 DATA "the_geom FROM (SELECT roads.oid AS oid, roads.the_geom AS the_geom, road_names.name as name
   FROM roads LEFT JOIN road_names ON roads.road_name_id = road_names.road_name_id) AS named_roads
   USING UNIQUE oid USING SRID=-1"
 MAXSCALE 20000
 STATUS ON
 TYPE ANNOTATION
 LABELITEM name
 CLASS
  LABEL
   ANGLE auto
   SIZE 8
   COLOR 0 192 0
   TYPE truetype
   FONT arial
  END
 END
END</pre><p>このANNOTAIONレイヤでは、縮尺が1:20000以下のときに、全ての道路に緑色のラベルを表示します。また、この例は、<code class="varname">DATA</code>定義で、SQLのJOINを使用する方法も示しています。</p></div></div><div class="sect1" title="4.8. Javaクライアント (JDBC)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62459080"></a>4.8. Javaクライアント (JDBC)</h2></div></div></div><p>Javaクライアントは、直接的にテキスト表現として、またはPostGISに同梱されているJDBC拡張オブジェクトを使用して、PostgreSQLデータベース内にある、PostGISの"geometry"オブジェクトにアクセスできます。JDBC拡張オブジェクトを使うためには、"postgis.jar"ファイルを、JDBCドライバパッケージの"postgresql.jar"とともに、 CLASSPATHに置く必要があります。</p><pre class="programlisting">import java.sql.*; 
import java.util.*; 
import java.lang.*; 
import org.postgis.*; 

public class JavaGIS { 
  public static void main(String[] args) 
  { 
    java.sql.Connection conn; 
    try 
    { 
      /* 
      * JDBCドライバをロードして接続を確立します。
      */  
      Class.forName("org.postgresql.Driver"); 
      String url = "jdbc:postgresql://localhost:5432/database"; 
      conn = DriverManager.getConnection(url, "postgres", ""); 
    
      /*
      * ジオメトリ型を接続に追加します。
      * ご注意 : addDateType()を呼ぶ前に
      *   接続をpgsql特有の接続実装にキャストしなければなりません。
      */
      ((org.postgresql.Connection)conn).addDataType("geometry","org.postgis.PGgeometry");
      ((org.postgresql.Connection)conn).addDataType("box3d","org.postgis.PGbox3d");

      /*
      * ステートメントの生成とSELECTクエリの実行を行います。
      */
      Statement s = conn.createStatement(); 
      ResultSet r = s.executeQuery("select AsText(geom) as geom,id from geomtable"); 
      while( r.next() ) 
      { 
        /*
        * ジオメトリをオブジェクトとして検索してジオメトリ型にキャストします。
        * オブジェクトを印字します
        */
        PGgeometry geom = (PGgeometry)r.getObject(1); 
        int id = r.getInt(2);
        System.out.println("Row " + id + ":"); 
        System.out.println(geom.toString()); 
      }
      s.close(); 
      conn.close(); 
    } 
    catch( Exception e ) 
    { 
      e.printStackTrace(); 
    }  
  }
}</pre><p>"PGeometry"オブジェクトは、Point、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygonの各型に依存する、特定のトポロジカルジオメトリオブジェクト ("Geometory"抽象クラスの子クラス)を持つラッパオブジェクトです。</p><pre class="programlisting">PGgeometry geom = (PGgeometry)r.getObject(1); 
if( geom.getType() = Geometry.POLYGON ) 
{ 
  Polygon pl = (Polygon)geom.getGeometry();
  for( int r = 0; r &lt; pl.numRings(); r++ ) 
  { 
    LinearRing rng = pl.getRing(r);
    System.out.println("Ring: " + r); 
    for( int p = 0; p &lt; rng.numPoints(); p++ ) 
    { 
      Point pt = rng.getPoint(p); 
      System.out.println("Point: " + p);
      System.out.println(pt.toString()); 
    } 
  } 
}</pre><p>幾何オブジェクトのさまざまなデータアクセサ関数に関する参照情報については、拡張オブジェクトのJavaDocをご覧下さい。</p></div><div class="sect1" title="4.9. Cクライアント (libpq)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62462024"></a>4.9. Cクライアント (libpq)</h2></div></div></div><p>...</p><div class="sect2" title="4.9.1. テキストカーソル"><div class="titlepage"><div><div><h3 class="title"><a name="idp62463048"></a>4.9.1. テキストカーソル</h3></div></div></div><p>...</p></div><div class="sect2" title="4.9.2. バイナリカーソル"><div class="titlepage"><div><div><h3 class="title"><a name="idp62464200"></a>4.9.2. バイナリカーソル</h3></div></div></div><p>...</p></div></div></div><div class="chapter" title="第5章 性能向上に関する技法"><div class="titlepage"><div><div><h2 class="title"><a name="idp62465608"></a>第5章 性能向上に関する技法</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#idp62466248">5.1. 大きなジオメトリを持つ小さなテーブル</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62479176">5.1.1. 問題の説明</a></span></dt><dt><span class="sect2"><a href="#idp62481352">5.1.2. 応急処置</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62485064">5.2. ジオメトリインデックスでCLUSTERを実行する</a></span></dt><dt><span class="sect1"><a href="#idp62488392">5.3. 次元変換の回避</a></span></dt></dl></div><div class="sect1" title="5.1. 大きなジオメトリを持つ小さなテーブル"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62466248"></a>5.1. 大きなジオメトリを持つ小さなテーブル</h2></div></div></div><div class="sect2" title="5.1.1. 問題の説明"><div class="titlepage"><div><div><h3 class="title"><a name="idp62479176"></a>5.1.1. 問題の説明</h3></div></div></div><p>現版のPostgreSQL (8.0を含む)では、TOASTテーブルに従うクエリオプティマイザの弱さに苦しみます。 TOASTテーブルは、(長いテキスト、イメージ、多数の頂点を持つ複合ジオメトリといった)通常のデータページに適合しない、(データサイズという意味では)巨大な値を納めるための「拡張部屋」の一種です。詳細情報はhttp://www.postgresql.org/docs/8.0/static/storage-toast.htmlをご覧ください。 </p><p>(高解像度で全てのヨーロッパの国の境界を含むテーブルのような)大きなジオメトリがあるうえ、行がそう多くないテーブルを持つようになると、この問題が出てきます。テーブル自体は小さいのですが、多くのTOASTスペースを使います。例として、テーブル自体は概ね80行で3データページしか使わなくてもTOASTテーブルで8225ページを使うとします。 </p><p>ここで、ジオメトリ演算子の&amp;&amp;を使って、ほとんどマッチしないようなバウンダリボックスを検索するクエリを出してみます。クエリオプティマイザにはテーブルは3ページ80行しかないように見えます。オプティマイザは、小さなテーブルを順に走査する方がインデックスを使うよりも早いと見積もります。そして、GiSTインデックスは無視すると決めます。通常なら、この見積もりは正しいです。しかし、この場合は&amp;&amp;演算子が全てのジオメトリをディスクから呼び出しでバウンディングボックスと比較しなければならなくなり、ゆえに、全てのTOASTページもまた呼び出す必要があります。 </p><p>このバグに苦しむかどうかを見るには、PostgreSQLの"EXPLAIN ANALYZE"コマンドを使います。詳しい情報と技術に関する詳細については、postgres performance mailing list のスレッド(http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php)をご覧下さい。 </p></div><div class="sect2" title="5.1.2. 応急処置"><div class="titlepage"><div><div><h3 class="title"><a name="idp62481352"></a>5.1.2. 応急処置</h3></div></div></div><p>PostgreSQLコミュニティでは、TOASTを意識したクエリ見積もりを作ることで、この問題を解決しようとしています。今のところは、二つの応急処置があります。 </p><p>一つは、クエリプランナにインデックスの使用を強制することです。クエリを発行する前に"SET enable_seqscan TO off;"をサーバに送信します。これは基本的にクエリプランナに対して可能な限り順に走査することを避けるよう強制します。そのためGiSTインデックスを通常使うようになります。しかし、このフラグは接続するたびに設定しなければならず、他のケースにおいてはクエリプランナに誤った見積もりをさせることになるので、 "SET enable_seqscan TO on;"をクエリの後に送信すべきです。 </p><p>もう一つは、順に走査することをクエリプランナが考える程度に早くすることです。これは、バウンダリボックスの「キャッシュ」を行う追加カラムを作成し、このカラムにマッチさせるようにすることで達成することができます。ここでの例では次のようになります。 </p><pre class="programlisting">SELECT addGeometryColumn('myschema','mytable','bbox','4326','GEOMETRY','2');

UPDATE mytable set bbox = Envelope(Force_2d(the_geom));
</pre><p>そして、次のように、&amp;&amp;演算子をgeom_columnに対して行っていたものをbboxに変更します。 </p><pre class="programlisting">SELECT geom_column FROM mytable WHERE bbox &amp;&amp; SetSrid('BOX3D(0 0,1 1)'::box3d,4326);
</pre><p>もちろん、mytableの行を変更または追加したら、bboxを「同期」するようにしなければなりません。最もすっきりした方法はトリガです。もしくは、アプリケーションを変更してbboxカラムの現状を保持するか、テーブル更新後にいつもUPDATEクエリを実行するかでも対応できます。 </p></div></div><div class="sect1" title="5.2. ジオメトリインデックスでCLUSTERを実行する"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62485064"></a>5.2. ジオメトリインデックスでCLUSTERを実行する</h2></div></div></div><p>読み込むことがほとんどで、かつほとんどのクエリでひとつのインデックスを使うようなテーブルのために、PostgreSQLはCLUSTERコマンドを提供しています。このコマンドは、全てのデータ行を、インデックス基準にあわせて物理的に再整理するので、二つの性能の利点を生みます。一つは、インデックスの範囲走査のために、データテーブルのシーク回数が劇的に減少することです。もう一つは、いくつかの小さなインデックス間隔に集中する場合には、データ行が分布するデータページがより少なくなるので、より効率的なキャッシュを持つことです (この点で、PostgreSQLマニュアルのCLUSTERコマンドのドキュメントを読むように仕向けられていると感じて下さい)。 </p><p>しかし、GiSTインデックスは単純にNULL値を無視するため現在のところPostGISのGiSTインデックスのクラスタリングはできず、次のようなエラーメッセージを得ます。 </p><pre class="programlisting">lwgeom=# CLUSTER my_geom_index ON my_table;
ERROR:  cannot cluster when index access method does not handle null values
HINT:  You may be able to work around this by marking column "the_geom" NOT NULL.
</pre><p>ヒントメッセージにある通り、テーブルに"not null"制限を追加することで、この欠陥にとりあえず対応できます。例を示します。 </p><pre class="programlisting">lwgeom=# ALTER TABLE my_table ALTER COLUMN the_geom SET not null;
ALTER TABLE
</pre><p>もちろん、ジオメトリカラムで実際にNULL値が必要な場合、この対応はできません。さらには、制限を追加するには上の方法を使わなければならず、"ALTER TABLE blubb ADD CHECK (geometry is not null);"のようなCHECK制限は使えません。 </p></div><div class="sect1" title="5.3. 次元変換の回避"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62488392"></a>5.3. 次元変換の回避</h2></div></div></div><p>ときどき、テーブルで3次元、4次元のデータを持つのに、常にOpenGIS準拠のasText()またはasBinary()関数を使ってアクセスして 2次元ジオメトリを出力させるようなことが起きます。 内部でforce_2d()関数を呼んでいるために発生しますが、 これは、大きなジオメトリでは重大なオーバヘッドを誘引することになります。 このオーバヘッドを回避するには、一度追加された次元を前もって落とし、かつこれを永続化するのが適当かも知れません。 </p><pre class="programlisting">UPDATE mytable SET the_geom = force_2d(the_geom);
VACUUM FULL ANALYZE mytable;
</pre><p>AddGeometryColumn()を使ってジオメトリカラムを追加した場合、ジオメトリの次元に関する制限があることに注意してください。この制限を迂回するには、制限の削除が必要になります。geometry_columnsテーブル内のエントリを更新して、その後で制限を再作成することを忘れないで下さい。 </p><p>In case of large tables, it may be wise to divide this UPDATE into smaller portions by constraining the UPDATE to a part of the table via a WHERE clause and your primary key or another feasible criteria, and running a simple "VACUUM;" between your UPDATEs. This drastically reduces the need for temporary disk space. Additionally, if you have mixed dimension geometries, restricting the UPDATE by "WHERE dimension(the_geom)
&gt;2" skips re-writing of geometries that already are in 2D. </p></div></div><div class="chapter" title="第6章 PostGISリファレンス"><div class="titlepage"><div><div><h2 class="title"><a name="idp62490824"></a>第6章 PostGISリファレンス</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#idp62491848">6.1. OpenGIS関数</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62492488">6.1.1. 管理関数</a></span></dt><dt><span class="sect2"><a href="#idp62498376">6.1.2. 空間関係関数</a></span></dt><dt><span class="sect2"><a href="#idp62587080">6.1.3. ジオメトリ処理関数</a></span></dt><dt><span class="sect2"><a href="#idp62619208">6.1.4. ジオメトリアクセサ</a></span></dt><dt><span class="sect2"><a href="#idp62659912">6.1.5. ジオメトリ コンストラクタ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62713288">6.2. PostGIS独自拡張</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62713928">6.2.1. 管理関数</a></span></dt><dt><span class="sect2"><a href="#idp62735432">6.2.2. 演算子</a></span></dt><dt><span class="sect2"><a href="#idp62767304">6.2.3. 計測関数</a></span></dt><dt><span class="sect2"><a href="#idp62811720">6.2.4. ジオメトリ出力</a></span></dt><dt><span class="sect2"><a href="#idp62820680">6.2.5. ジオメトリ コンストラクタ</a></span></dt><dt><span class="sect2"><a href="#idp62848072">6.2.6. ジオメトリエディタ</a></span></dt><dt><span class="sect2"><a href="#idp62879816">6.2.7. その他の関数</a></span></dt></dl></dd></dl></div><p>ここで示す関数はPostGISユーザが必要とすると思われる関数です。この他に、一般的なユーザが使わないPostGISオブジェクトに対して求められるサポート関数があります。</p><div class="sect1" title="6.1. OpenGIS関数"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62491848"></a>6.1. OpenGIS関数</h2></div></div></div><div class="sect2" title="6.1.1. 管理関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62492488"></a>6.1.1. 管理関数</h3></div></div></div><div class="variablelist"><dl><dt><a name="AddGeometryColumn"></a><span class="term">AddGeometryColumn(varchar, varchar, varchar, integer, varchar, integer)</span></dt><dd><p>構文: AddGeometryColumn(&lt;スキーマ名&gt;, &lt;テーブル名&gt;, &lt;カラム名&gt;, &lt;srid&gt;, &lt;タイプ&gt;, &lt;次元&gt;). 存在する属性テーブル (訳注:ジオメトリカラムが存在しない意と思われますが、ジオメトリカラムが既に存在していても追加できます)」にジオメトリカラムを追加します。スキーマ名は、テーブルスキーマの名前です (プリスキーマ版PostgreSQLの場合は使われません)。 sridは、SPATIAL_REF_SYSテーブルに登録されている整数値でなければなりません。 型は、'POLGYON', 'MULTILINESTRING' などのように、常に大文字の文字列で、ジオメトリ型に対応していなければなりません。</p></dd><dt><span class="term">DropGeometryColumn(varchar, varchar, varchar)</span></dt><dd><p>構文: DropGeometryColumn(&lt;スキーマ名&gt;, &lt;テーブル名&gt;, &lt;カラム名&gt;). ジオメトリカラムを空間テーブルから削除します。 スキーマ名はgeometry_columnsテーブル内にある、そのテーブル名を持つ行のf_schema_nameフィールドと一致しなければならないことに注意して下さい。</p></dd><dt><span class="term">SetSRID(geometry)</span></dt><dd><p>ジオメトリのSRIDを特定の整数値に設定します。クエリのためのバウンディングボックスを生成する際に使います。</p></dd></dl></div></div><div class="sect2" title="6.1.2. 空間関係関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62498376"></a>6.1.2. 空間関係関数</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Distance(geometry,geometry)</span></dt><dd><p>二つのジオメトリ間の2次元距離の最大値を、投影法の単位で返します。</p></dd><dt><span class="term">Equals(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的に等価」であるなら1 (TRUE)を返します。 '='より「良い」回答が得られます。equals('LINESTRING(0 0, 10 10)','LINESTRING(0 0, 5 5, 10 10)')は、TRUEになります。</p><p>GEOSモジュールによって実現しています。</p><p>OGC SPEC s2.1.1.2</p></dd><dt><span class="term">Disjoint(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的に接続されていない」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')</p></dd><dt><span class="term">Intersects(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的にインタセクトしている (訳注:共通領域を持つ)」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 //s2.1.13.3 - Intersects(g1, g2 ) --&gt; Not (Disjoint(g1, g2 ))</p></dd><dt><span class="term">Touches(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的に接触している」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3- a.Touches(b) -&gt; (I(a) intersection I(b) = {empty set} ) and (a intersection b) not empty</p></dd><dt><span class="term">Crosses(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的にクロスしている (訳注:共通領域を持ち、かつ共通領域の次元が引数ジオメトリの最大次元-1」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*T******')</p></dd><dt><span class="term">Within(geometry,geometry)</span></dt><dd><p>ジオメトリAが「空間的に」ジオメトリB「の中にある」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')</p></dd><dt><span class="term">Overlaps(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的にオーバラップしている (訳注:共通領域を持ち、引数の2ジオメトリと共通領域が同次元で、かつ共通領域が引数の2ジオメトリと同一でない)」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3</p></dd><dt><span class="term">Contains(geometry,geometry)</span></dt><dd><p>ジオメトリAがジオメトリBを「空間的に含んでいる」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - same as within(geometry,geometry)</p></dd><dt><span class="term">Intersects(geometry,geometry)</span></dt><dd><p>ジオメトリが「空間的にインタセクトしている (訳注:共通領域を持つ)」なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3 - NOT disjoint(geometry,geometry)</p></dd><dt><span class="term">Relate(geometry,geometry, intersectionPatternMatrix)</span></dt><dd><p>このジオメトリが空間的に、もう一つのジオメトリに関連しているなら1 (TRUE)を返します。 この関連は、intersectionPatternMatrix行列の値によって指定された、 二つのジオメトリの内部、境界、外部の交差要素を見ることで決定されます。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: これは論理値を返して整数を返さないのが「許される」版です。</p><p>OGC SPEC s2.1.1.2 // s2.1.13.3</p></dd><dt><span class="term">Relate(geometry,geometry)</span></dt><dd><p>DE-9IM (次元拡張された9要素行列)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>OGC仕様にはありませんが実装しました。s2.1.13.2をご覧下さい。</p></dd></dl></div></div><div class="sect2" title="6.1.3. ジオメトリ処理関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62587080"></a>6.1.3. ジオメトリ処理関数</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Centroid(geometry)</span></dt><dd><p>ジオメトリの重心をポイントとして返します。</p><p>GEOSモジュールによって実現されている (コンパイル時に指定されます)なら、より正確に計算できます。</p></dd><dt><span class="term">Area(geometry)</span></dt><dd><p>ジオメトリがポリゴンかマルチポリゴンならジオメトリの面積を返します。 </p></dd><dt><span class="term">Length(geometry)</span></dt><dd><p>ジオメトリの、組み込まれている空間参照系での曲線長を返します。</p><p>これはlength2d()の別名です。</p><p>OGC SPEC 2.1.5.1</p></dd><dt><span class="term">PointOnSurface(geometry)</span></dt><dd><p>表面にあることが保障された点を返します。</p><p>GEOSモジュールによって実現しています。</p><p>OGC SPEC 3.2.14.2 and 3.2.18.2 -</p></dd><dt><span class="term">Boundary(geometry)</span></dt><dd><p>ジオメトリの組み合わせ境界の閉包を返します (訳注: ラインストリングは端点、ポリゴンはエッジ、複合オブジェクトは境界のうち奇数番)。組み合わせ境界はOGC仕様の3.12.3.2節に記述されています。結果として出てくる境界は、OGC SPEC 3.12.2で議論されているように、ジオメトリプリミティブを使って表現できます。</p><p>GEOSモジュールによって実現しています。</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">Buffer(geometry,double,[integer])</span></dt><dd><p>ジオメトリからの距離が指定した距離未満となる全てのポイントを示すジオメトリを返します。オプションの第3引数では、4分の1にした円を近似するために使われる弦の数を設定します (デフォルトは8です)。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">ConvexHull(geometry)</span></dt><dd><p>ジオメトリの凸包を表現するジオメトリを返します。</p><p>GEOSモジュールによって実現しています。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">Intersection(geometry,geometry)</span></dt><dd><p>ジオメトリがインタセクトする点を示すジオメトリを返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">SymDifference(geometry,geometry)</span></dt><dd><p>ジオメトリの対称差 (AとBで共通しない部分)を示すジオメトリを返します。対称と呼ばれるのは、ST_SymDifference(A,B) = ST_SymDifference(B,A)となるからです。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">Difference(geometry,geometry)</span></dt><dd><p>ジオメトリの対称差 (AとBで共通しない部分)を示すジオメトリを返します。対称と呼ばれるのは、ST_SymDifference(A,B) = ST_SymDifference(B,A)となるからです。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">GeomUnion(geometry,geometry)</span></dt><dd><p>ジオメトリを結合したポイント集合を示すジオメトリを返します。</p><p>GEOSモジュールによって実現しています。</p><p>ジオメトリコレクションを引数として呼ばないでください。</p><p>ご注意: この関数は"union"から名前を変更しました。SQLの予約語であるためです。</p><p>OGC SPEC s2.1.1.3</p></dd><dt><span class="term">GeomUnion(geometry set)</span></dt><dd><p>与えられた集合の全てのジオメトリを結合したポイント集合を示すジオメトリを返します。</p><p>GEOSモジュールによって実現しています。</p><p>GeometryCollectionを引数集合で呼んではいけません。</p><p>OGC仕様では明示的に定義されていません。</p></dd><dt><span class="term">MemGeomUnion(geometry set)</span></dt><dd><p>上と同じですが、メモリフレンドリ (少ないメモリ使用で長い処理時間)です。</p></dd></dl></div></div><div class="sect2" title="6.1.4. ジオメトリアクセサ"><div class="titlepage"><div><div><h3 class="title"><a name="idp62619208"></a>6.1.4. ジオメトリアクセサ</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">AsText(geometry)</span></dt><dd><p>ジオメトリのWell-Known Text表現を返します。たとえばPOLYGON(0 0,0 1,1 1,1 0,0 0)などです。</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">AsBinary(geometry)</span></dt><dd><p>ジオメトリをOGC"Well-Known Binary"表現で返します。データベースが動いているサーバのエンディアンを使います。これは文字列表現に変換せずにデータをデータベースから引き出すバイナリカーソルに有用です。</p><p>OGC SPEC s2.1.1.1 - asBinary(&lt;geometry&gt;,'XDR') and asBinary(&lt;geometry&gt;,'NDR')も参照して下さい</p></dd><dt><span class="term">SRID(geometry)</span></dt><dd><p>ジオメトリの空間参照系SRIDを整数で返します。</p><p>OGC SPEC s2.1.1.1</p></dd><dt><span class="term">Dimension(geometry)</span></dt><dd><p>このジオメトリオブジェクトの固有の次元です。 ジオメトリオブジェクトは座標の次元以下である必要があります。OGC SPEC s2.1.1.1 - 0ならポイント、1ならライン、2ならポリゴン、ジオメトリコレクションの場合は要素ごとの次元の最大値です。</p><pre class="programlisting">select dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0)'); 
dimension 
-----------
1</pre></dd><dt><span class="term">Envelope(geometry)</span></dt><dd><p>ジオメトリーのバウンディングボックスを表している有効なジオメトリ (POINT、LINESTRINGまたはPOLYGON)を返します。</p><p>OGC SPEC s2.1.1.1 -このジオメトリの最小のバウンディングボックスをジオメトリとして返します。ポリゴンはバウンディングボックスの頂点((MINX, MINY), (MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY))で定義されます。</p><p>ご注意: PostGISはZmin/Zmax座標も同様に加えます。</p></dd><dt><span class="term">IsEmpty(geometry)</span></dt><dd><p>ジオメトリが空ジオメトリなら1 (TRUE)を返します。 TRUEなら、このジオメトリは空のポイント集合を示すジオメトリ、すなわちGEOMETRYCOLLECTION(EMPTY)です。</p><p>OGC SPEC s2.1.1.1</p></dd><dt><a name="IsSimple"></a><span class="term">IsSimple(geometry)</span></dt><dd><p>ジオメトリが、自己交差、自己接触といった異常な幾何学点を持っていないなら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>OGC SPEC s2.1.1.1</p></dd><dt><a name="IsClosed"></a><span class="term">IsClosed(geometry)</span></dt><dd><p>開始点と終了点とが同じになっているジオメトリならTRUEを返します。</p></dd><dt><span class="term">IsRing(geometry)</span></dt><dd><p>この曲線が閉じていて( StartPoint( ) = EndPoint( ) )、この曲線が単純 (2回以上同一点を通過しない)なら1 (TRUE)を返します。</p><p>GEOSモジュールによって実現しています。</p><p>OGC spec 2.1.5.1</p></dd><dt><span class="term">NumGeometries(geometry)</span></dt><dd><p>ジオメトリがGEOMETRYCOLLECTION (または MULTI系)の場合はジオメトリ数を返し、そうでないならNULLを返します。</p></dd><dt><span class="term">GeometryN(geometry,int)</span></dt><dd><p>ジオメトリがGEOMETRYCOLLECTION, MULTIPOINT, MULTILINESTRINGまたはMULTIPOLYGONの場合はN番目のジオメトリを返します。それ以外の場合はNULLを返します。</p><p>1が最初のジオメトリです。</p></dd><dt><span class="term">NumPoints(geometry)</span></dt><dd><p>ジオメトリの最初のラインストリングのポイント数を返します。ジオメトリにラインストリングが無い場合はNULLを返します。</p></dd><dt><span class="term">PointN(geometry,integer)</span></dt><dd><p>ジオメトリの最初のラインストリングにおける、N番目のポイントを返します。ジオメトリにラインストリングが無い場合はNULLを返します。</p></dd><dt><span class="term">ExteriorRing(geometry)</span></dt><dd><p>ポリゴンの外環を返します。ジオメトリがポリゴンでない場合はNULLを返します。</p></dd><dt><span class="term">NumInteriorRings(geometry)</span></dt><dd><p>ジオメトリの最初のポリゴンの内環数を返します。ジオメトリにポリゴンが無い場合はNULLを返します。</p></dd><dt><span class="term">InteriorRingN(geometry,integer)</span></dt><dd><p>ポリゴンのN番目の内環を返します。ジオメトリがポリゴンでないか、N番が範囲外である場合はNULLを返します。</p></dd><dt><span class="term">EndPoint(geometry)</span></dt><dd><p>ラインストリングの最後のポイントをポイントで返します。</p></dd><dt><span class="term">StartPoint(geometry)</span></dt><dd><p>ラインストリングの最初のポイントをポイントで返します。</p></dd><dt><a name="GeometryType"></a><span class="term">GeometryType(geometry)</span></dt><dd><p>ジオメトリタイプを文字列で返します。たとえば'LINESTRING', 'POLYGON', 'MULTIPOINT'等です。</p><p>OGC SPEC s2.1.1.1 - このジオメトリインスタンスがメンバーになっているジオメトリのインスタンス化可能な派生タイプの名前を返します。インスタンス化可能な派生タイプの名前は、文字列として返されます。</p></dd><dt><span class="term">X(geometry)</span></dt><dd><p>ジオメトリの最初のポイントのX値を探索して返します。ジオメトリにポイントが無い場合はNULLを返します。</p></dd><dt><span class="term">Y(geometry)</span></dt><dd><p>ジオメトリの最初のポイントのY値を探索して返します。ジオメトリにポイントが無い場合はNULLを返します。</p></dd><dt><span class="term">Z(geometry)</span></dt><dd><p>ジオメトリの最初のポイントのZ値を探索して返します。ジオメトリにポイントが無い場合はNULLを返します。</p></dd></dl></div></div><div class="sect2" title="6.1.5. ジオメトリ コンストラクタ"><div class="titlepage"><div><div><h3 class="title"><a name="idp62659912"></a>6.1.5. ジオメトリ コンストラクタ</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">GeomFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p></dd><dt><span class="term">PointFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがポイントでない場合はエラーを投げます。</p></dd><dt><span class="term">LineFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p></dd><dt><span class="term">LinestringFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>仕様適合のためです。</p><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p></dd><dt><span class="term">PolyFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">PolygonFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>仕様適合のためです。</p><p>WKTがポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">MPointFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがマルチポイントでない場合はエラーを投げます。</p></dd><dt><span class="term">MLineFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがマルチラインストリングでない場合はエラーを投げます。</p></dd><dt><span class="term">MPolyFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがマルチポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">GeomCollFromText(text,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKTから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKTがジオメトリコレクションでない場合はエラーを投げます。</p></dd><dt><span class="term">GeomFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p></dd><dt><span class="term">GeomFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p></dd><dt><span class="term">PointFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがポイントでない場合はエラーを投げます。</p></dd><dt><span class="term">LineFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがラインストリングでない場合はエラーを投げます。</p></dd><dt><span class="term">LinestringFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>仕様適合のためです。</p><p>WKBがラインストリングでない場合はエラーを投げます。</p></dd><dt><span class="term">PolyFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">PolygonFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>仕様適合のためです。</p><p>WKBがポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">MPointFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがマルチポイントでない場合はエラーを投げます。</p></dd><dt><span class="term">MLineFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがマルチラインストリングでない場合はエラーを投げます。</p></dd><dt><span class="term">MPolyFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがマルチポリゴンでない場合はエラーを投げます。</p></dd><dt><span class="term">GeomCollFromWKB(bytea,[&lt;srid&gt;])</span></dt><dd><p>ジオメトリをWKBから作成し、SRIDを与えます。SRIDが与えられない場合は-1をデフォルトで与えます。</p><p>OGC SPEC 3.2.6.2 - 任意引数SRIDは仕様適合のためです。</p><p>WKBがジオメトリコレクションでない場合はエラーを投げます。</p></dd></dl></div></div></div><div class="sect1" title="6.2. PostGIS独自拡張"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62713288"></a>6.2. PostGIS独自拡張</h2></div></div></div><div class="sect2" title="6.2.1. 管理関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62713928"></a>6.2.1. 管理関数</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">DropGeometryTable([&lt;スキーマ名&gt;], &lt;テーブル名&gt;)</span></dt><dd><p>テーブルとgeometry_columnsからの参照を削除します。 ご注意: スキーマ対応版PostgreSQLでは、スキーマが与えられない場合はcurrent_schema()を使います。</p></dd><dt><span class="term">UpdateGeometrySRID([&lt;schema_name&gt;], &lt;table_name&gt;, &lt;column_name&gt;, &lt;srid&gt;)</span></dt><dd><p>ジオメトリカラムにある全てのフィーチャーのSRIDを更新し、SRIDに関するジオメトリ制限とgeometry_columnsのSRIDを更新します。ご注意: スキーマ対応版PostgreSQLでは、スキーマが与えられない場合はcurrent_schema()を使います。</p></dd><dt><span class="term">update_geometry_stats([&lt;table_name&gt;, &lt;column_name&gt;])</span></dt><dd><p>クエリプランナが使う、空間テーブルの統計情報を更新します。統計情報収集処理を完全にするためにはには"VACUUM ANALYZE [テーブル名] [カラム名]"も実行する必要があります。ご注意: PostgreSQL 8.0からは統計情報の収集は"VACUUM ANALYZE"で自動的に行われます。</p></dd><dt><span class="term">postgis_version()</span></dt><dd><p>このデータベースにインストールされたPostGIS関数の版番号を返します (非推奨です。替わりにpostgis_full_version()を使います)。</p></dd><dt><span class="term">postgis_lib_version()</span></dt><dd><p>PostGISライブラリの版を返します。</p></dd><dt><span class="term">postgis_lib_build_date()</span></dt><dd><p>PostGISライブラリをビルドした日を返します。</p></dd><dt><span class="term">postgis_script_build_date()</span></dt><dd><p>PostGISスクリプトをビルドした日を返します。</p></dd><dt><span class="term">postgis_scripts_installed()</span></dt><dd><p>インストールされたlwpostgis.sqlスクリプトの版番号を返します。</p></dd><dt><span class="term">postgis_scripts_released()</span></dt><dd><p>インストールされたPostGISライブラリからリリースされたlwpostgis.sqlスクリプトの版番号を返します。</p></dd><dt><span class="term">postgis_geos_version()</span></dt><dd><p>GEOSライブラリの版を返します。GEOS対応が有効でないならNULLを返します。</p></dd><dt><span class="term">postgis_proj_version()</span></dt><dd><p>PROJ4ライブラリの版を返します。PROJ4対応が有効でないならNULLを返します。</p></dd><dt><span class="term">postgis_uses_stats()</span></dt><dd><p>STATSの使用が可能になっているならTRUEを返し、そうでないならFALSEを返します。</p></dd><dt><span class="term">postgis_full_version()</span></dt><dd><p>完全なPostGISの版情報とコンフィギュレーション情報を報告します。</p></dd></dl></div></div><div class="sect2" title="6.2.2. 演算子"><div class="titlepage"><div><div><h3 class="title"><a name="idp62735432"></a>6.2.2. 演算子</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">A &amp;&lt; B</span></dt><dd><p>"&amp;&lt;"演算子は、AのバウンディングボックスがBのバウンディングボックスとオーバラップしているか左側にある場合にTRUEを返します。</p></dd><dt><span class="term">A &amp;&gt; B</span></dt><dd><p>"&amp;&gt;"演算子は、AのバウンディングボックスがBのバウンディングボックスとオーバラップしているか右側にある場合にTRUEを返します。</p></dd><dt><span class="term">A &lt;&lt; B</span></dt><dd><p>"&lt;&lt;"演算子は、Aのバウンディングボックスが厳密にBのバウンディングボックスの左側にある場合にTRUEを返します。</p></dd><dt><span class="term">A &gt;&gt; B</span></dt><dd><p>"&gt;&gt;"演算子はAのバウンディングボックスが厳密にBンバウンディングボックスの右側にある場合にTRUEを返します。</p></dd><dt><span class="term">A &amp;&lt;| B</span></dt><dd><p>"&amp;&lt;|"演算子は、AのバウンディングボックスがBのバウンディングボックスとオーバラップしているか下にある場合にTRUEを返します。</p></dd><dt><span class="term">A |&amp;&gt; B</span></dt><dd><p>"|&amp;&gt;"演算子は、AのバウンディングボックスがBのバウンディングボックスとオーバラップしているか上にある場合にTRUEを返します。</p></dd><dt><span class="term">A &lt;&lt;| B</span></dt><dd><p>"&lt;&lt;|"演算子は、Aのバウンディングボックスが厳密にBのバウンディングボックスの下にある場合にTRUEを返します。</p></dd><dt><span class="term">A |&gt;&gt; B</span></dt><dd><p>"|&gt;&gt;"演算子は、Aのバウンディングボックスが厳密にBのバウンディングボックスの上にある場合にTRUEを返します。</p></dd><dt><span class="term">A ~= B</span></dt><dd><p>"~="演算子は、「同じ形のもの」演算子です。 二つのジオメトリが実際に幾何学的に等価であるかどうかを見ます。AとBが頂点ごとに見て同じフィーチャーの場合にTRUEを返します。</p></dd><dt><span class="term">A @ B</span></dt><dd><p>"@"演算子は、Aのバウンディングボックスが完全にBのバウンディングボックスに含まれる場合にTRUEを返します。</p></dd><dt><span class="term">A ~ B</span></dt><dd><p>"~"演算子は、Aのバウンディングボックスが完全にBのバウンディングボックスを含む場合にTRUEを返します。</p></dd><dt><span class="term">A &amp;&amp; B</span></dt><dd><p>"&amp;&amp;"演算子は、オーバラップ演算子です。AのバウンディングボックスがBのバウンディングボックスをオーバラップする場合にTRUEを返します。</p></dd></dl></div></div><div class="sect2" title="6.2.3. 計測関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62767304"></a>6.2.3. 計測関数</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">area2d(geometry)</span></dt><dd><p>ジオメトリがポリゴンかマルチポリゴンならジオメトリの面積を返します。</p></dd><dt><span class="term">distance_sphere(point, point)</span></dt><dd><p>緯度経度で示された二点の直線距離をメートルで返します。半径6370986メートルの球体とします。<a class="link" href="#distance_spheroid">distance_spheroid()</a>より早いですが、精度は落ちます。ポイントについてのみ実装しています。</p></dd><dt><a name="distance_spheroid"></a><span class="term">distance_spheroid(point, point, spheroid)</span></dt><dd><p>指定した楕円体を使って、緯度経度で示された2点の直線距離をメートルで返します。<a class="link" href="#length_spheroid">length_spheroid()</a>にある楕円体の説明をご覧下さい。現在は、ポイントについてのみ実装しています。</p></dd><dt><span class="term">length2d(geometry)</span></dt><dd><p>ラインストリングまたはマルチラインストリングの場合に、ジオメトリの2次元の長さを返します。</p></dd><dt><span class="term">length3d(geometry)</span></dt><dd><p>ラインストリングまたはマルチラインストリングの場合に、ジオメトリの3次元の長さを返します。</p></dd><dt><a name="length_spheroid"></a><span class="term">length_spheroid(geometry,spheroid)</span></dt><dd><p>楕円体上の長さを計算します。この関数は、ジオメトリの座標が緯度経度単位であって、投影変換なしに長さを求めたい場合に有用です。楕円体は別々のデータベースタイプで、次のように構成することができます。</p><div class="literallayout"><p>SPHEROID[&lt;名称&gt;,&lt;長軸半径&gt;,&lt;扁平率の逆数&gt;]</p></div><p>Eg:</p><div class="literallayout"><p>SPHEROID["GRS_1980",6378137,298.257222101]</p></div><p>計算例は次のようになるでしょう。</p><div class="literallayout"><p>SELECT<br>
 length_spheroid(<br>
  geometry_column,<br>
  'SPHEROID["GRS_1980",6378137,298.257222101]'<br>
 )<br>
FROM geometry_table;</p></div></dd><dt><span class="term">length3d_spheroid(geometry,spheroid)</span></dt><dd><p>ジオメトリの楕円体上の長さを、標高を考慮して計算します。この関数は、鉛直変動によって加えられる距離を計算するために鉛直座標 (楕円体の軸と同じ単位です)を使うことを除くと、ちょうどlength_spheroidに似ています。</p></dd><dt><span class="term">distance(geometry, geometry)</span></dt><dd><p>二つのジオメトリ間の最短距離を返します。</p></dd><dt><span class="term">max_distance(linestring,linestring)</span></dt><dd><p>二つのラインストリング間の最長距離を返します。</p></dd><dt><span class="term">perimeter(geometry)</span></dt><dd><p>POLYGONまたはMULTIPOLYGONジオメトリの場合に、2次元周囲長を返します。</p></dd><dt><span class="term">perimeter2d(geometry)</span></dt><dd><p>POLYGONまたはMULTIPOLYGONジオメトリの場合に、2次元周囲長を返します。</p></dd><dt><span class="term">perimeter3d(geometry)</span></dt><dd><p>POLYGONまたはMULTIPOLYGONジオメトリの場合には、3次元周囲長を返します。</p></dd></dl></div></div><div class="sect2" title="6.2.4. ジオメトリ出力"><div class="titlepage"><div><div><h3 class="title"><a name="idp62811720"></a>6.2.4. ジオメトリ出力</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">AsBinary(geometry,{'NDR'|'XDR'})</span></dt><dd><p>リトルエンディアン(NDR)またはビッグエンディアン(XDR)を使ったOGC "Well-known-binary"表現をbytea型で返します。この関数は、データをデータベース外に文字列表現を使わずに持ち出すバイナリカーソルで有用です。</p></dd><dt><span class="term">AsEWKT(geometry)</span></dt><dd><p>ジオメトリのEWKT表現をTEXT型で返します。</p></dd><dt><span class="term">AsEWKB(geometry, {'NDR'|'XDR'})</span></dt><dd><p>リトルエンディアン (NDR)またはビッグエンディアン (XDR)を使ったEWKB表現をbytea型で返します。</p></dd><dt><span class="term">AsSVG(geometry, [rel], [precision])</span></dt><dd><p>ジオメトリをSVGパスデータで返します。第2引数に1を指定すると、相対移動によるパスデータ実装を返します。デフォルト (または0指定)では、絶対移動を使います。第3引数は、出力の十進数の最大桁数を減らすために使います (デフォルトは15です)。'rel'が0のときはポイントはcx/cyに、'rel'が1のときはx/yに、それぞれ出力します。</p></dd><dt><span class="term">AsGML(geometry, [precision])</span></dt><dd><p>ジオメトリをGMLエレメントで返します。第2引数は、出力の最大有効桁数を減らすために使います (デフォルトは15です)。</p></dd></dl></div></div><div class="sect2" title="6.2.5. ジオメトリ コンストラクタ"><div class="titlepage"><div><div><h3 class="title"><a name="idp62820680"></a>6.2.5. ジオメトリ コンストラクタ</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">GeomFromEWKT(text)</span></dt><dd><p>EWKBからジオメトリを生成します。</p></dd><dt><span class="term">GeomFromEWKB(bytea)</span></dt><dd><p>EWKBからジオメトリを生成します。</p></dd><dt><span class="term">MakePoint(&lt;x&gt;, &lt;y&gt;, [&lt;z&gt;], [&lt;m&gt;])</span></dt><dd><p>2次元、3次元、4次元のポイントジオメトリを生成します。</p></dd><dt><span class="term">MakePointM(&lt;x&gt;, &lt;y&gt;, &lt;m&gt;)</span></dt><dd><p>XYMのポイントジオメトリを生成します。</p></dd><dt><span class="term">MakeBox2D(&lt;LL&gt;, &lt;UR&gt;)</span></dt><dd><p>与えられたポイントジオメトリから定義されるBOX2Dを生成します。</p></dd><dt><span class="term">MakeBox3D(&lt;LLB&gt;, &lt;URT&gt;)</span></dt><dd><p>与えられた3次元ポイントジオメトリから定義されるBOX3Dを生成します。</p></dd><dt><span class="term">MakeLine(geometry set)</span></dt><dd><p>ポイントジオメトリの集合からラインストリングをひとつ生成します。この集計関数に渡す前に、副問い合わせでポイントを並べ替えると良いかも知れません。</p></dd><dt><span class="term">MakeLine(geometry, geometry)</span></dt><dd><p>与えられた二つのポイントからラインストリングを生成します。</p></dd><dt><span class="term">LineFromMultiPoint(multipoint)</span></dt><dd><p>マルチポイントジオメトリからラインストリングを生成します。</p></dd><dt><span class="term">AddPoint(linestring, point, [&lt;position&gt;])</span></dt><dd><p>ポイントを、ラインストリングの&lt;pos&gt;の位置に追加します。第3引数を省略するか-1を設定すると、末尾に追加します。 </p></dd><dt><span class="term">MakePolygon(linestring, [linestring[]])</span></dt><dd><p>与えられた外周、穴の配列で形作られるポリゴンを生成します。ジオメトリ配列は<a class="link" href="#Accum">Accum</a>を使って生成します。 入力ジオメトリは閉じたラインストリングである必要があります (<a class="link" href="#IsClosed">IsClosed</a>と<a class="link" href="#GeometryType">GeometryType</a>を参照して下さい)。 </p></dd><dt><span class="term">Polygonize(geometry set)</span></dt><dd><p>Aggregate. Creates a GeometryCollection containing possible polygons formed from the costituent linework of a set of geometries. Only available when compiled against GEOS 
&gt;= 2.1.0.</p></dd><dt><span class="term">Collect(geometry set)</span></dt><dd><p>ジオメトリの集合からジオメトリコレクションまたはマルチ系オブジェクトを返します。collect()関数はPostgreSQLの用語で言うところの「集計関数」です。これは、sum()やmean()関数と同じようにデータの複数行を扱うということを意味します。たとえば、"SELECT COLLECT(GEOM) FROM GEOMTABLE GROUP BY ATTRCOLUMN"は、ATTRCOLUMNの値ごとに分かれたジオメトリコレクションを返します。</p></dd><dt><span class="term">Collect(geometry, geometry)</span></dt><dd><p>二つの入力ジオメトリをまとめたジオメトリを返します。出力タイプはMULTI系またはGEOMETRYCOLLECTIONです。</p></dd><dt><span class="term">Dump(geometry)</span></dt><dd><p>これは集合を返す関数 (SRF=set-returning function)です。ジオメトリ (<code class="varname">geom</code>)と整数配列 (<code class="varname">path</code>)で作られる<code class="varname">geometry_dump</code>行を返します。入力ジオメトリが単純型 (POINT,LINESTRING,POLYGON)の場合は、単一の行で返り、pathには空配列、geomには入力ジオメトリが入ります。入力ジオメトリがジオメトリコレクションまたはMULTI系の場合は、要素ごとの行で返り、pathはコレクション内の要素位置を表します。 </p><p>ご注意: この関数はPostgreSQL 7.2.xでビルドした場合には有効ではありません</p></dd></dl></div></div><div class="sect2" title="6.2.6. ジオメトリエディタ"><div class="titlepage"><div><div><h3 class="title"><a name="idp62848072"></a>6.2.6. ジオメトリエディタ</h3></div></div></div><div class="variablelist"><dl><dt><a name="addbbox"></a><span class="term">AddBBOX(geometry)</span></dt><dd><p>ジオメトリにバウンディングボックスを追加します。これにより、バウンディングボックスに基づく検索が早くなりますが、ジオメトリのサイズが大きくなります。</p></dd><dt><a name="dropbbox"></a><span class="term">DropBBOX(geometry)</span></dt><dd><p>ジオメトリからバウンディングボックスのキャッシュを削除します。この関数は、ジオメトリのサイズを減らしますが、バウンディングボックスを用いたクエリを遅くします。</p></dd><dt><span class="term">Force_collection(geometry)</span></dt><dd><p>ジオメトリをジオメトリコレクションに変換します。これはWKB表現を単純化するのに便利です。</p></dd><dt><a name="force_2d"></a><span class="term">Force_2d(geometry)</span></dt><dd><p>ジオメトリを「2次元モード」に強制させます。全ての出力表現はXY座標値のみを持つことになります。OGC準拠の出力 (OGCは2次元ジオメトリのみ策定しています)に強制するために使われます。</p></dd><dt><a name="force_3dz"></a><span class="term">Force_3dz(geometry), </span><span class="term">Force_3d(geometry)</span></dt><dd><p>ジオメトリをXYZモードに強制します。</p></dd><dt><a name="force_3dm"></a><span class="term">Force_3dm(geometry)</span></dt><dd><p>ジオメトリをXYMモードに強制します。</p></dd><dt><a name="force_4d"></a><span class="term">Force_4d(geometry)</span></dt><dd><p>ジオメトリをXYZMモードに強制します。</p></dd><dt><span class="term">Multi(geometry)</span></dt><dd><p>マルチ系ジオメトリを返します。ジオメトリが既にマルチ系なら変更せずに返します。</p></dd><dt><span class="term">Transform(geometry,integer)</span></dt><dd><p>新しいジオメトリを整数値で参照されるSRIDに座標変換します。変換先SRIDは<code class="varname">SPATIAL_REF_SYS</code>テーブルに存在するものでなければなりません。</p></dd><dt><span class="term">Translate(geometry,float8,float8,float8)</span></dt><dd><p>引数の数値をオフセットとして、ジオメトリを新しい位置に変換するものです。すなわち translate(geom,X,Y,Z) となります。</p></dd><dt><span class="term">Reverse(geometry)</span></dt><dd><p>ジオメトリの頂点の並びを逆順にして返します。</p></dd><dt><span class="term">ForceRHR(geometry)</span></dt><dd><p>コレクションのポリゴンを右回りに従わせます。</p></dd><dt><span class="term">Simplify(geometry, tolerance)</span></dt><dd><p>引数のジオメトリをDouglas-Peukerアルゴリズムを使って「単純化した」ものを返します。(マルチ)ラインと(マルチ)ポリゴンでないと実際には動作しませんが、安全にあらゆる種類のジオメトリを引数にできます。単純化はオブジェクトごとに実行されるものですから、ジオメトリコレクションをこの関数に送ることもできます。返されるジオメトリが単純性を失う可能性もあることにご注意ください(<a class="link" href="#IsSimple">IsSimple</a>を参照して下さい)。</p></dd><dt><span class="term">SnapToGrid(geometry, originX, originY, sizeX, sizeY), </span><span class="term">SnapToGrid(geometry, sizeX, sizeY), </span><span class="term">SnapToGrid(geometry, size)</span></dt><dd><p>引数のジオメトリの全てのポイントを、定義された原点とセルサイズを持つグリッド上にスナップします。 同じセルに落ちた、連続するポイントを削除します。引数ジオメトリのジオメトリタイプを定義できないポイントしか残らなかった場合は、NULLを返します。コレクション内で崩壊したジオメトリはそこから削除されます。返されるジオメトリは単純性を失う可能性がありますのでご注意ください (<a class="link" href="#IsSimple">IsSimple</a>を参照して下さい)。 </p></dd><dt><span class="term">Segmentize(geometry, maxlength)</span></dt><dd><p>与えられた距離を超えるセグメントを持たないように変更されたジオメトリを返します。差し込まれたポイントはZとM値を (必要なら)持ち、値は0に設定されます。距離計算は2次元でのみ行います。</p></dd></dl></div></div><div class="sect2" title="6.2.7. その他の関数"><div class="titlepage"><div><div><h3 class="title"><a name="idp62879816"></a>6.2.7. その他の関数</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Summary(geometry)</span></dt><dd><p>ジオメトリについての要約文を返します。</p></dd><dt><span class="term">box2d(geometry)</span></dt><dd><p>ジオメトリの最大範囲を表すBOX2Dを返します。</p></dd><dt><span class="term">box3d(geometry)</span></dt><dd><p>ジオメトリの最大範囲を表すBOX3Dを返します。</p></dd><dt><span class="term">extent(geometry set)</span></dt><dd><p>extent()関数はPostgreSQL用語で言うところの「集計関数」です。これは、sum()やmean()と同じ方法でデータリストの操作を行うことを意味します。たとえば、"SELECT EXTENT(GEOM) FROM GEOMTABLE"は、テーブル内の全てのフィーチャーの最大範囲を示すBOX3Dを返します。同様に、"SELECT EXTENT(GEOM) FROM GEOMTABLE GROUP BY CATEGORY"は、カテゴリごとの範囲を返します。</p></dd><dt><a name="zmflag"></a><span class="term">zmflag(geometry)</span></dt><dd><p>ジオメトリのZM (次元の意味)フラグをsmall intで返します。値は、0=2次元, 1=M-三次元, 2=Z-3次元, 3=4次元です。 </p></dd><dt><a name="hasbbox"></a><span class="term">HasBBOX(geometry)</span></dt><dd><p>このジオメトリのバウンディングボックスがキャッシュされている場合はTRUEを返し、それ以外の場合はFALSEを返します。キャッシュ制御には<a class="link" href="#addbbox">addBBOX()</a>と<a class="link" href="#dropbbox">dropBBOX()</a>を使います。</p></dd><dt><a name="ndims"></a><span class="term">ndims(geometry)</span></dt><dd><p>ジオメトリの座標次元をsmall intで返します。値は2, 3, 4のいずれかです。</p></dd><dt><span class="term">nrings(geometry)</span></dt><dd><p>ジオメトリがポリゴンまたはマルチポリゴンの場合、リング数を返します。</p></dd><dt><span class="term">npoints(geometry)</span></dt><dd><p>ジオメトリのポイント (頂点)数を返します。</p></dd><dt><a name="IsValid"></a><span class="term">isvalid(geometry)</span></dt><dd><p>ジオメトリが妥当な場合にはTRUEを返します。</p></dd><dt><span class="term">expand(geometry, float)</span></dt><dd><p>入力ジオメトリのバウンディングボックスから、第2引数で指定される量によって、全ての方向に拡大させたバウンディングボックスを返します。 クエリにインデックスフィルタを追加するdistance()クエリにとても便利です。</p></dd><dt><span class="term">estimated_extent([schema], table, geocolumn)</span></dt><dd><p>与えられた空間テーブルの「見積もられた」範囲を返します。ジオメトリカラムの統計情報から見積もります。指定されていない場合は現在のスキーマが使われます。</p><p>PostgreSQL 8.0.0以上では、統計情報はVACUUM ANALYZEで集められ、結果の範囲は実際の約95%です。</p><p>PostgreSQL 8.0.0より前では、統計情報はupdate_geometry_stats()で集められ、範囲は確実です。</p></dd><dt><span class="term">find_srid(varchar,varchar,varchar)</span></dt><dd><p>この関数の書式はfind_srid(a_db_schema, a_table, a_column)です。GEOMETRY_COLUMNSで検索して、指定したカラムのSRID整数値を返します。ジオメトリカラムがAddGeometryColumn()関数で確実に追加していない場合には、確実には動作しません (訳注: GEOMETRY_COLUMNSビューで確実な登録が確認できていれば良いです)。</p></dd><dt><span class="term">mem_size(geometry)</span></dt><dd><p>ジオメトリが取る容量 (バイト単位)を返します。</p></dd><dt><span class="term">numb_sub_objects(geometry)</span></dt><dd><p>ジオメトリに格納されているオブジェクトの数を返します。マルチ系ジオメトリとジオメトリコレクションに使えます。</p></dd><dt><span class="term">point_inside_circle(geometry,float,float,float)</span></dt><dd><p>この関数の書式はpoint_inside_circle(&lt;geometry&gt;,&lt;circle_center_x&gt;,&lt;circle_center_y&gt;,&lt;radius&gt;)です。ジオメトリがポイントで、かつ指定した円内にある場合はTRUEを返し、それ以外はFALSEを返します。</p></dd><dt><span class="term">xmin(box3d) ymin(box3d) zmin(box3d)</span></dt><dd><p>バウンディングボックスの、それぞれX,Y,Z軸の最小値を返します。</p></dd><dt><span class="term">xmax(box3d) ymax(box3d) zmax(box3d)</span></dt><dd><p>バウンディングボックスの、それぞれX,Y,Z軸の最大値を返します。</p></dd><dt><span class="term">line_interpolate_point(geometry, proportion)</span></dt><dd><p>線に沿った内挿点を返します。第1引数はLINESTRINGでなければなりません。 第2引数は、float型で0から1の区間にある数です。ポイントを返します。</p></dd><dt><a name="Accum"></a><span class="term">Accum(geometry set)</span></dt><dd><p>集約関数です。ジオメトリの配列を生成します。</p></dd></dl></div></div></div></div><div class="appendix" title="付録A リリースノート"><div class="titlepage"><div><div><h2 class="title"><a name="idp62934856"></a>付録A リリースノート</h2></div></div></div><div class="toc"><p><b>目次</b></p><dl><dt><span class="sect1"><a href="#idp62935496">A.1. リリース 1.0.0</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62936904">A.1.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62939336">A.1.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62941256">A.1.3. 他の変更追加</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62944840">A.2. リリース 1.0.0RC6</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62946248">A.2.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62948040">A.2.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62949576">A.2.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62950728">A.2.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62952392">A.3. リリース 1.0.0RC5</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62953800">A.3.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62956232">A.3.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62957768">A.3.3. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62959432">A.4. リリース 1.0.0RC4</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62960840">A.4.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62962632">A.4.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62966088">A.4.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62967752">A.4.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62971848">A.5. リリース 1.0.0RC3</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62973256">A.5.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp56482888">A.5.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp56486728">A.5.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp56489032">A.5.4. JDBC変更</a></span></dt><dt><span class="sect2"><a href="#idp56493128">A.5.5. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp56496328">A.6. リリース 1.0.0RC2</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp56497736">A.6.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp56499528">A.6.2. ライブラリの変更</a></span></dt><dt><span class="sect2"><a href="#idp62974664">A.6.3. スクリプトの変更</a></span></dt><dt><span class="sect2"><a href="#idp62976328">A.6.4. 他の変更</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idp62977992">A.7. リリース 1.0.0RC1</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp62979400">A.7.1. アップグレード</a></span></dt><dt><span class="sect2"><a href="#idp62981192">A.7.2. 変更</a></span></dt></dl></dd></dl></div><div class="sect1" title="A.1. リリース 1.0.0"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62935496"></a>A.1. リリース 1.0.0</h2></div></div></div><p>リリース日: 2005/04/19</p><p>最後の1.0.0リリースです。若干の誤り訂正、ローダのいくつかの改良 (古いPostGISへの対応が特筆すべき点)、文書の追加がありました。 </p><div class="sect2" title="A.1.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62936904"></a>A.1.1. アップグレード</h3></div></div></div><p>1.0.0RC6から更新する場合には、ダンプ/リロードは<span class="emphasis"><em>不要です</em></span></p><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.1.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62939336"></a>A.1.2. ライブラリの変更</h3></div></div></div><p>transform()が不規則なメモリアドレスを解放する問題を訂正</p><p>force_3dm()のメモリ確保が必要より小さい問題を訂正</p><p>JOIN選択度見積もりの誤り (デフォルト値、メモリリーク、行カウント、SD)訂正</p></div><div class="sect2" title="A.1.3. 他の変更追加"><div class="titlepage"><div><div><h3 class="title"><a name="idp62941256"></a>A.1.3. 他の変更追加</h3></div></div></div><p>shp2pgsqlがタブまたはシングルクォートで始まる値を読み飛ばす誤りを訂正</p><p>マニュアルへのローダ/ダンパの追加</p><p>古い (HWGEOM)PostGISに対応するshp2gsql</p><p>shp2pgsqlのフラグに -p (prepare)を追加</p><p>マニュアルにOGC互換の強制に関する新章追加</p><p>JTSライブラリに対応する新しいautoconf</p><p>推測器のテストの誤り訂正 (LWGEOMとスキーマの構文解析への対応)</p></div></div><div class="sect1" title="A.2. リリース 1.0.0RC6"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62944840"></a>A.2. リリース 1.0.0RC6</h2></div></div></div><p>リリース日: 2005/03/30</p><p>1.0.0の6番目のリリース候補、若干の誤り訂正と整理を行っています。</p><div class="sect2" title="A.2.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62946248"></a>A.2.1. アップグレード</h3></div></div></div><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.2.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62948040"></a>A.2.2. ライブラリの変更</h3></div></div></div><p>multi()の誤り訂正</p><p>noop時にmulti()からの早い復帰</p></div><div class="sect2" title="A.2.3. スクリプトの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62949576"></a>A.2.3. スクリプトの変更</h3></div></div></div><p>{x,y}{min,max}(box2d)関数の削除</p></div><div class="sect2" title="A.2.4. 他の変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62950728"></a>A.2.4. 他の変更</h3></div></div></div><p>postgis_restore.plスクリプトの誤り訂正</p><p>64ビット対応のダンパの誤り訂正</p></div></div><div class="sect1" title="A.3. リリース 1.0.0RC5"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62952392"></a>A.3. リリース 1.0.0RC5</h2></div></div></div><p>リリース日: 2005/03/25</p><p>1.0.0の5番目のリリース候補、若干の誤り訂正と改善があります</p><div class="sect2" title="A.3.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62953800"></a>A.3.1. アップグレード</h3></div></div></div><p>1.0.0RC4から更新する場合には、ダンプ/リロードは<span class="emphasis"><em>不要です</em></span></p><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.3.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62956232"></a>A.3.2. ライブラリの変更</h3></div></div></div><p>box3d計算の問題 (セグメンテーションフォールト)の訂正 (ほかにもあります)</p><p>estimated_extent()でのセグメンテーションフォールトの訂正</p></div><div class="sect2" title="A.3.3. 他の変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62957768"></a>A.3.3. 他の変更</h3></div></div></div><p>ビルドスクリプトとユーティリティの若干の改良</p><p>性能向上に関する技法の文章の追加</p></div></div><div class="sect1" title="A.4. リリース 1.0.0RC4"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62959432"></a>A.4. リリース 1.0.0RC4</h2></div></div></div><p>リリース日: 2005/03/18</p><p>1.0.0の4番目のリリース候補、誤り訂正と若干の改善があります</p><div class="sect2" title="A.4.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62960840"></a>A.4.1. アップグレード</h3></div></div></div><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.4.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62962632"></a>A.4.2. ライブラリの変更</h3></div></div></div><p>geom_accum()のセグメンテーションフォールトの誤り訂正</p><p>64ビットアーキテクチャ対応の誤り訂正</p><p>コレクションを引数に取るbox3d計算関数の誤りの訂正</p><p>副問い合わせの選択度推定への対応</p><p>force_collectionからの早い復帰</p><p>SnapToGrid()の一貫性検査の訂正</p><p>Box2d出力精度を15桁に後退</p></div><div class="sect2" title="A.4.3. スクリプトの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62966088"></a>A.4.3. スクリプトの変更</h3></div></div></div><p>distance_sphere()の追加</p><p>get_proj4_from_sridの実装をSQLからPL/pgSQLに変更</p></div><div class="sect2" title="A.4.4. 他の変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62967752"></a>A.4.4. 他の変更</h3></div></div></div><p>ローダとダンパのMULTOLINEシェープの処理の問題を訂正</p><p>ローダでポリゴンの最初の穴を読み飛ばす誤りを訂正</p><p>jdbc2: コードの整理、Makefileの改善</p><p>FLEX変数とYACC変数がpgsqlのMakefile.globalが取り込まれた*後*で、pgsqlの*空白を除いた*ものが空文字列と評価された場合に限って設定される</p><p>既に作成されていたパーサの追加</p><p>ビルドスクリプトの改良</p><p>Version.configの改善を中心とした版処理の改善</p><p>postgis_restore.plの改善</p></div></div><div class="sect1" title="A.5. リリース 1.0.0RC3"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62971848"></a>A.5. リリース 1.0.0RC3</h2></div></div></div><p>リリース日: 2005/02/24</p><p>1.0.0の3番目のリリース候補、多数の誤り訂正と改善があります。</p><div class="sect2" title="A.5.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62973256"></a>A.5.1. アップグレード</h3></div></div></div><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.5.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp56482888"></a>A.5.2. ライブラリの変更</h3></div></div></div><p>transform()でSRIDが消える問題を訂正、エラー処理を改善。</p><p>メモリアラインメントのハンドリングに関する誤り訂正</p><p>force_collection()で単純な (単一)ジオメトリ型でMapServerの接続が切れる問題を訂正。</p><p>GeometryFromText()でbboxキャッシュを追加しない誤り訂正。</p><p>box2d出力の精度低下。</p><p>pgsqlで異常終了する問題を避けるため、DEBUGマクロにPGIS_の前置辞を付加</p><p>GEOS2POSTGISコンバータのリークを訂正</p><p>pallocで確保したクエリコンテキストのメモリを早く開放することによるメモリ使用の削減</p></div><div class="sect2" title="A.5.3. スクリプトの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp56486728"></a>A.5.3. スクリプトの変更</h3></div></div></div><p>PostgreSQL 7.2のインデックスのバインディングを訂正しました。</p><p>PG72での動作と、1テーブルに複数カラムの場合への対応のため、probe_geometry_columns()の誤り訂正</p><p>boolからtextへのキャストの更新</p><p>動作効率改善のため、いくつかの関数をSTABLEからIMMUTABLEに変更</p></div><div class="sect2" title="A.5.4. JDBC変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp56489032"></a>A.5.4. JDBC変更</h3></div></div></div><p>jdbc2: 小さなパッチ、box2d/box3dの試験、文書とライセンスの改定</p><p>jdbc2: pgjdbc 8.0の型の自動登録の誤り訂正とテストケース作成</p><p>jdbc2: 古いjdkリリースでの構築を有効にするためためにjdk1.4使用箇所の削除</p><p>jdbc2: pg72jdbc2.jarに対するビルドへの対応の追加</p><p>jdbc2: Makefileの更新と無駄の除去</p><p>jdbc2: JTSジオメトリクラス対応のベータ版を追加</p><p>jdbc2: 古いPostGISサーバに対して失敗するのが判明しているテストをスキップするようにしました。</p><p>jdbc2: EWKTのM値を持つジオメトリの処理の訂正</p></div><div class="sect2" title="A.5.5. 他の変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp56493128"></a>A.5.5. 他の変更</h3></div></div></div><p>性能向上に関する技法の新章追加</p><p>ドキュメント更新: pgsql72に必要なもの、lwpostgis.sql</p><p>autoconfの若干の変更 </p><p>BUILDDATE抽出の移植可能範囲を広げました</p><p>spatial_ref_sys.sqlを訂正してvacuumが全体のデータベースに及ぶのを避けるようにしました。</p><p>spatial_ref_sys: NTF (Paris)を0.xで配布していたものに合うよう変更。</p></div></div><div class="sect1" title="A.6. リリース 1.0.0RC2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp56496328"></a>A.6. リリース 1.0.0RC2</h2></div></div></div><p>リリース日: 2005/01/26</p><p>1.0.0の第2リリース候補版。誤り訂正と若干の改善。</p><div class="sect2" title="A.6.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp56497736"></a>A.6.1. アップグレード</h3></div></div></div><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.6.2. ライブラリの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp56499528"></a>A.6.2. ライブラリの変更</h3></div></div></div><p>ポイント配列からのbox3d計算に関する誤り訂正</p><p>distance_spheroid定義に関する誤り訂正</p><p>bboxキャッシュ更新がtransform()無かったことに関する誤り訂正</p><p>新しいJDBCドライバ (jdbc2)</p><p>後方互換のためのGEOMETRYCOLLECTION(EMPTY)書式への対応</p><p>バイナリ出力の高速化</p><p>OGC WKB/WKTコンストラクタの厳格化</p></div><div class="sect2" title="A.6.3. スクリプトの変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62974664"></a>A.6.3. スクリプトの変更</h3></div></div></div><p>lwpostgis.sql内でのSTABLE, IMMUTABLE, STRICTの訂正</p><p>OGC WKB/WKTコンストラクタの厳格化</p></div><div class="sect2" title="A.6.4. 他の変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62976328"></a>A.6.4. 他の変更</h3></div></div></div><p>ローダ (i18n、非i18nの両方)の高速化と堅牢化</p><p>最初のautoconfスクリプト</p></div></div><div class="sect1" title="A.7. リリース 1.0.0RC1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp62977992"></a>A.7. リリース 1.0.0RC1</h2></div></div></div><p>リリース日: 2005/01/13</p><p>最初のPostGISメジャーリリース候補版。格納領域の低減とインデックス使用クエリの高速化のためのPostGIS型の内部格納の再設計。</p><div class="sect2" title="A.7.1. アップグレード"><div class="titlepage"><div><div><h3 class="title"><a name="idp62979400"></a>A.7.1. アップグレード</h3></div></div></div><p>前のリリースからアップグレードするにはダンプ/リロードが必要です。詳細については<a class="link" href="#upgrading" title="2.2.1. アップグレード">アップグレード</a>をご覧下さい。</p></div><div class="sect2" title="A.7.2. 変更"><div class="titlepage"><div><div><h3 class="title"><a name="idp62981192"></a>A.7.2. 変更</h3></div></div></div><p>標準形式入力パースの高速化。 </p><p>標準形式出力の可逆化。 </p><p>EWKB Canonical binary IO with PG
&gt;73. </p><p>Support for up to 4d coordinates, providing lossless shapefile-&gt;postgis-&gt;shapefile conversion. </p><p>新関数: UpdateGeometrySRID(), AsGML(), SnapToGrid(), ForceRHR(), estimated_extent(), accum(). </p><p>垂直方向位置インデックス演算子。 </p><p>JOIN選択関数。 </p><p>ジオメトリコンストラクタとエディタの強化。 </p><p>PostGISエクステンションAPI。 </p><p>ローダのUTF-8対応。 </p></div></div></div></div></body></html>
