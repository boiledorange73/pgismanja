<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第7章 アプリケーションのビルド</title><link rel="stylesheet" type="text/css" href="docbook.css"><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="PostGIS 3.2.0 マニュアル"><link rel="up" href="index.html" title="PostGIS 3.2.0 マニュアル"><link rel="prev" href="performance_tips.html" title="第6章 性能向上に関する技法"><link rel="next" href="reference.html" title="第8章 PostGISリファレンス"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第7章 アプリケーションのビルド</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="performance_tips.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr></table></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idp53150848"></a>第7章 アプリケーションのビルド</h1></div></div></div><div class="toc"><div class="toc-title">目次</div><dl class="toc"><dt><span class="sect1"><a href="ch07.html#Using_MapServer">7.1. MapServerを使う</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07.html#idp54564736">7.1.1. 基本的な使い方</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54584448">7.1.2. よくある質問</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54600320">7.1.3. 踏み込んだ使用法</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54608768">7.1.4. 例</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07.html#idp54615296">7.2. Javaクライアント (JDBC)</a></span></dt><dt><span class="sect1"><a href="ch07.html#idp54618240">7.3. Cクライアント (libpq)</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07.html#idp54631552">7.3.1. テキストカーソル</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54632704">7.3.2. バイナリカーソル</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Using_MapServer"></a>7.1. MapServerを使う</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ch07.html#idp54564736">7.1.1. 基本的な使い方</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54584448">7.1.2. よくある質問</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54600320">7.1.3. 踏み込んだ使用法</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54608768">7.1.4. 例</a></span></dt></dl></div><p>Minnesota MapServer は、OpenGIS Web Map Service仕様に準拠したインターネットWebマッピングサーバです。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>MapServerのウェブサイトは<a class="ulink" href="http://mapserver.org/" target="_top">http://mapserver.org/</a>です。</p></li><li class="listitem"><p>OpenGIS Web Map Serviceの仕様書は<a class="ulink" href="http://www.opengeospatial.org/standards/wms" target="_top">http://www.opengeospatial.org/standards/wms</a>にあります。</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54564736"></a>7.1.1. 基本的な使い方</h3></div></div></div><p>PostGISとMapServerとを併用するには、MapServerの設定方法を知る必要がありますが、本文書の範囲外です。本節では、PostGIS独特の問題と設定詳細について説明します。</p><p>PostGISをMapServerで使うには、次のものが必要です。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>PostGIS 0.6以上</p></li><li class="listitem"><p>MapServer 3.5以上</p></li></ul></div><p>MapServerは、他のPostgreSQLクライアントと同じくPostGIS/PostgreSQLデータにアクセスします。アクセスには<code class="filename">libpq</code>インタフェースを使います。つまり、MapServerは、PostGISサーバにアクセスするあらゆるネットワークに繋がっている計算機にインストールすることができ、PostGISをデータソースとして利用できます。システム間の接続が速いほど良くなります。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>"--with-postgis"と好きなconfigureオプションを付けてMpaServerのコンパイルとインストールを行います。</p></li><li class="listitem"><p>Mapserverのmapファイルの中に、PostGISレイヤを追加します。たとえば次のようになります。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "widehighways"
  # リモートの空間データベースに接続します
  CONNECTION "user=dbuser dbname=gisdatabase host=bigserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  # 'roads'テーブルの'geom'カラムからラインを取得します
  DATA "geom from roads using srid=4326 using unique gid"
  STATUS ON
  TYPE LINE
  # 範囲内のラインである広い高速道路のみ描画します
  FILTER "type = 'highway' and numlanes &gt;= 4"
  CLASS
    # 非常に広い高速道路はより明るい色かつ2ピクセル幅にします
    EXPRESSION ([numlanes] &gt;= 6)
    STYLE
      COLOR 255 22 22
      WIDTH 2
    END
  END
  CLASS
     # 残りは、暗い色かつ1ピクセル幅です
    EXPRESSION ([numlanes] &lt; 6)
    STYLE
      COLOR 205 92 82
    END
  END
END</pre><p>上の例におけるPostGIS特有のディレクティブは次の通りです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CONNECTIONTYPE</span></dt><dd><p>PostGISレイヤでは常に"postgis"とします。</p></dd><dt><span class="term">CONNECTION</span></dt><dd><p>データベース接続は「接続文字列」によって制御されます。接続文字列は、次に示すような標準的なキーと値からなります(&lt;&gt;内はデフォルト値)。</p><p>user=&lt;ユーザ名&gt; password=&lt;パスワード&gt; dbname=&lt;ユーザ名&gt; hostname=&lt;サーバ&gt; port=&lt;5432&gt;</p><p>空の接続文字列も妥当とされますし、あらゆるキーと値のペアは省略できます。接続するためには一般的にはdbnameとusernameとが最少で与えるものとなります。</p></dd><dt><span class="term">DATA</span></dt><dd><p>このパラメータの形式は "&lt;カラム名&gt; from &lt;テーブル名&gt; using srid=&lt;SRID&gt; using unique &lt;主キー&gt;"となります。ここで、カラム名は地図に描画したい空間カラムを指し、SRIDはそのカラムで使われるSRIDで、主キーはそのテーブルの主キー (またはインデックスを伴う一意の値を持つカラム)です。</p><p>"using srid"と"using unique"節は省略できます。MapServerは可能なら自動的に正しい値を判断しますが、地図を描画するサーバ上で余分なクエリを若干実行するコストがかかります。</p></dd><dt><span class="term">PROCESSING</span></dt><dd><p>接続を閉じずに複数のレイヤで再利用する場合にCLOSE_CONNECTION=DEFERとします。速度が改善します。詳細な説明については<a class="ulink" href="http://blog.cleverelephant.ca/2008/10/mapserverpostgis-performance-tips.html" target="_top">MapServer PostGIS Performance Tips</a>を参照して下さい。 </p></dd><dt><span class="term">FILTER</span></dt><dd><p>フィルタは、妥当なSQL文字列でなければなりません。この文字列は、通常はSQLクエリにおける"WHERE"に続く論理式に対応します。たとえば、6レーン以上の道路だけを描画する場合には、"num_lanes &gt;= 6"というフィルタを使います。</p></dd></dl></div></li><li class="listitem"><p>空間データベースにおいては、空間 (GiST)インデックスを、マップに描かれるレイヤ全てに構築していることを保証して下さい。</p><pre class="programlisting">CREATE INDEX [インデックス名] ON [テーブル名] USING GIST ( [ジオメトリカラム] );</pre></li><li class="listitem"><p>MapServerを使用するレイヤのクエリを実行する場合には、"using unique"節もDATAステートメントに追加しなければなりません。</p><p>MapServerでは、クエリ実行の際には、それぞれの空間レコードを識別するための一意な識別子が必要です。MapServerのPostGISモジュールは、一意な識別子を提供するために、ユーザ指定の一意な値を使います。テーブルの主キーを使うのが最も良い方法です。</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54584448"></a>7.1.2. よくある質問</h3></div></div></div><div class="qandaset"><a name="idp54585088"></a><dl><dt>7.1.2.1. <a href="ch07.html#idp54585344">EXPRESSIONをマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</a></dt><dt>7.1.2.2. <a href="ch07.html#idp54588416">シェープファイルに使用している FILTER が、同じデータを持つPostGISテーブルでは動作しません。</a></dt><dt>7.1.2.3. <a href="ch07.html#idp54590848">PostGISレイヤは、シェープファイルレイヤよりもはるかに遅く描画しますが、これは正常ですか?</a></dt><dt>7.1.2.4. <a href="ch07.html#idp54593664">PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</a></dt><dt>7.1.2.5. <a href="ch07.html#idp54597120">ジオグラフィカラム (PostGIS 1.5で機能追加)をMapServerのレイヤのソースとして使用できますか?</a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idp54585344"></a><a name="idp54585600"></a><p><b>7.1.2.1.</b></p></td><td align="left" valign="top"><p><code class="varname">EXPRESSION</code>をマップファイルで使う時に、値がテーブルにあるのを確認しているのに条件がtrueになりません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>EXPRESIONで使うフィールド名は、シェープファイルと違ってPostGISの場合<span class="emphasis"><em>小文字</em></span>になります。</p><pre class="programlisting">EXPRESSION ([numlanes] &gt;= 6)</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54588416"></a><a name="idp54588672"></a><p><b>7.1.2.2.</b></p></td><td align="left" valign="top"><p>シェープファイルに使用している FILTER が、同じデータを持つPostGISテーブルでは動作しません。</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>シェープファイルと違い、PostGISレイヤのフィルタはSQL構文を使います (PostGISコネクタがMapServerでレイヤを描画するために生成するSQLステートメントに追加されます)。</p><pre class="programlisting">FILTER "type = 'highway' and numlanes &gt;= 4"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54590848"></a><a name="idp54591104"></a><p><b>7.1.2.3.</b></p></td><td align="left" valign="top"><p>PostGISレイヤは、シェープファイルレイヤよりもはるかに遅く描画しますが、これは正常ですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>一般に、与えられた地図に描画する地物が多いほど、PostGISはシェープファイルより遅くなる可能性が高くなります。相対的に地物が少ない (100個台)地図では、PostGISの方が速くなることがしばしばあります。地物が少多い (1000個台)地図では、PostGISは常に遅くなります。 </p><p>重大な描画性能の問題があるようでしたら、テーブルにある空間インデックスを構築していないというのがありそうです。</p><pre class="programlisting">postgis# CREATE INDEX geotable_gix ON geotable USING GIST ( geocolumn );
postgis# VACUUM ANALYZE;</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54593664"></a><a name="idp54593920"></a><p><b>7.1.2.4.</b></p></td><td align="left" valign="top"><p>PostGISレイヤはちゃんと描けましたが、クエリが本当に遅いです。何が問題なのですか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>クエリを早くするには、空間テーブルに一意なキーを持たせ、そのキーにインデックスを持たせなければなりません。</p><p><code class="varname">DATA</code>行の<code class="varname">USING UNIQUE</code>節で、MapServerで使用する一意なキーをどれにするか指定することができます。</p><pre class="programlisting">DATA "geom FROM geotable USING UNIQUE gid"</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idp54597120"></a><a name="idp54597376"></a><p><b>7.1.2.5.</b></p></td><td align="left" valign="top"><p>ジオグラフィカラム (PostGIS 1.5で機能追加)をMapServerのレイヤのソースとして使用できますか?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>できます!MapServerはジオグラフィカラムをジオメトリカラムと同じに認識します。しかし、常にSRIDを4326とします。"using srid=4326"節を<code class="varname">DATA</code>ステートメントに入れて下さい。他の部分はジオメトリの場合と同じです。</p><pre class="programlisting">DATA "geog FROM geogtable USING SRID=4326 USING UNIQUE gid"</pre></td></tr></tbody></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54600320"></a>7.1.3. 踏み込んだ使用法</h3></div></div></div><p><code class="varname">USING</code>疑似SQL節を使ってMapServerがより複雑なクエリの結果を理解できるようにするための情報を追加します。より詳しく言うと、ビューまたは副問い合わせが元テーブル (<code class="varname">DATA</code>定義で"FROM"の右にあるもの)として使われる時、MapServerが自動的に一意な識別子がそれぞれの行にあるか、また、SRIDがテーブルにあるかを判別するのは困難です。<code class="varname">USING</code>節によって、MapServerがこれらの情報を得ることができます。例を次に挙げます。</p><pre class="programlisting">DATA "geom FROM (
  SELECT
    table1.geom AS geom,
    table1.gid AS gid,
    table2.data AS data
  FROM table1
  LEFT JOIN table2
  ON table1.id = table2.id
) AS new_table USING UNIQUE gid USING SRID=4326"</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">USING UNIQUE &lt;uniqueid&gt;</span></dt><dd><p>MapServerは、マップクエリを実行する際、行識別のために、それぞれの行に一意な識別子を求めます。通常ならシステムテーブルから主キーを識別しますが、ビューや副問い合わせでは、一意性のあるカラムを自動的に知ることができません。MapServerのクエリ機能を使いたいなら、一意性のあるカラムをビューまたは副問い合わせに追加する必要があり、<code class="varname">USING UNIQUE</code>宣言を付ける必要があります。たとえば、この目的のための主キー値のテーブルでのカラム名や、結果セットで一意性が保障されたカラムを明示的にSELECTに入れることができます。</p><div class="note"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注記]" src="images/note.png"></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>「マップクエリ」はマップ上でクリックして、その場所におけるフィーチャーに関する情報を問い合わせる動作です。「マップクエリ」と<code class="varname">DATA</code>定義におけるSQLクエリと混同しないで下さい。</p></td></tr></table></div></dd><dt><span class="term">USING SRID=&lt;srid&gt;</span></dt><dd><p>PostGISは、MapServerに正しいデータを返すために、ジオメトリがどの空間参照系を使っているかを知る必要があります。通常は、この情報はPostGISデータベースの"geometry_columns"テーブルから得ることができます。しかし、副問い合わせやビューのような一時テーブルでは、この方法は不可能です。そこで、 <code class="varname">USING SRID=</code>オプションを使って、正しいSRIDが<code class="varname">DATA</code>定義で使われるように指定します。</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54608768"></a>7.1.4. 例</h3></div></div></div><p>簡単な例から始めて、ステップアップしていきましょう。次のMapServerレイヤ定義を考えて下さい。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  NAME "roads"
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  DATA "geom from roads"
  STATUS ON
  TYPE LINE
  CLASS
    STYLE
      COLOR 0 0 0
    END
  END
END</pre><p>このレイヤは"roads"テーブルにある道路ジオメトリの全部を黒線で表示するものです。</p><p>では、少なくとも1:100000にズームするまでは高速道路だけを表示したい、としましょう。次の二つのレイヤで、その効果が実現できます。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  DATA "geom from roads"
  MINSCALE 100000
  STATUS ON
  TYPE LINE
  FILTER "road_type = 'highway'"
  CLASS
    COLOR 0 0 0
  END
END
LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  PROCESSING "CLOSE_CONNECTION=DEFER"
  DATA "geom from roads"
  MAXSCALE 100000
  STATUS ON
  TYPE LINE
  CLASSITEM road_type
  CLASS
    EXPRESSION "highway"
    STYLE
      WIDTH 2
      COLOR 255 0 0
    END
  END
  CLASS
    STYLE
      COLOR 0 0 0
    END
  END
END</pre><p>一つ目のレイヤはスケールが1:100000以上であるときに使われ、道路タイプが"highway"である道路のみ黒線で表示されます。<code class="varname">FILTER</code>オプションによって、道路タイプが"highway"の場合のみ表示することになります。</p><p>二つ目のレイヤはスケールが1:100000未満である時に使われ、"highway"は赤い二重細線で表示され、他の道路は黒線で表示されます。</p><p>さて、MapServerの機能を使うだけで、二つのおもしろいことを実行しました。しかし、<code class="varname">DATA</code>のSQLステートメントは、単純なままです。道路名が (どういう理由かは知りませんが)他のテーブルに収められていて、それのデータを取得するためにテーブルを連結して、道路のラベルを取る必要がある、とします。</p><pre class="programlisting">LAYER
  CONNECTIONTYPE postgis
  CONNECTION "user=theuser password=thepass dbname=thedb host=theserver"
  DATA "geom FROM (SELECT roads.gid AS gid, roads.geom AS geom,
        road_names.name as name FROM roads LEFT JOIN road_names ON
        roads.road_name_id = road_names.road_name_id)
        AS named_roads USING UNIQUE gid USING SRID=4326"
  MAXSCALE 20000
  STATUS ON
  TYPE ANNOTATION
  LABELITEM name
  CLASS
    LABEL
      ANGLE auto
      SIZE 8
      COLOR 0 192 0
      TYPE truetype
      FONT arial
    END
  END
END</pre><p>このANNOTAIONレイヤでは、縮尺が1:20000以下のときに、全ての道路に緑色のラベルを表示します。また、この例は、 <code class="varname">DATA</code>定義で、SQLのJOINを使用する方法も示しています。</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54615296"></a>7.2. Javaクライアント (JDBC)</h2></div></div></div><p>Javaクライアントは、直接的にテキスト表現として、またはPostGISに同梱されているJDBC拡張オブジェクトを使用して、PostgreSQLデータベース内にある、PostGISの"geometry"オブジェクトにアクセスできます。JDBC拡張オブジェクトを使うためには、"postgis.jar"ファイルを、JDBCドライバパッケージの"postgresql.jar"とともに、 CLASSPATHに置く必要があります。</p><pre class="programlisting">import java.sql.*;
import java.util.*;
import java.lang.*;
import org.postgis.*;

public class JavaGIS {

public static void main(String[] args) {

  java.sql.Connection conn;

  try {
    /*
    * JDBCドライバをロードして接続を確立します。
    */
    Class.forName("org.postgresql.Driver");
    String url = "jdbc:postgresql://localhost:5432/database";
    conn = DriverManager.getConnection(url, "postgres", "");
    /*
    * ジオメトリ型を接続に追加します。
    * ご注意 : addDateType()を呼ぶ前に
    *   接続をpgsql特有の接続実装にキャストしなければなりません。
    */
    ((org.postgresql.PGConnection)conn).addDataType("geometry",Class.forName("org.postgis.PGgeometry"));
    ((org.postgresql.PGConnection)conn).addDataType("box3d",Class.forName("org.postgis.PGbox3d"));
    /*
    * ステートメントの生成とSELECTクエリの実行を行います。
    */
    Statement s = conn.createStatement();
    ResultSet r = s.executeQuery("select geom,id from geomtable");
    while( r.next() ) {
      /*
      * ジオメトリをオブジェクトとして検索してジオメトリ型にキャストします。
      * オブジェクトを印字します
      */
      PGgeometry geom = (PGgeometry)r.getObject(1);
      int id = r.getInt(2);
      System.out.println("Row " + id + ":");
      System.out.println(geom.toString());
    }
    s.close();
    conn.close();
  }
catch( Exception e ) {
  e.printStackTrace();
  }
}
}</pre><p>"PGeometry"オブジェクトは、Point、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygonの各型に依存する、特定のトポロジカルジオメトリオブジェクト ("Geometory"抽象クラスの子クラス)を持つラッパオブジェクトです。</p><pre class="programlisting">PGgeometry geom = (PGgeometry)r.getObject(1);
if( geom.getType() == Geometry.POLYGON ) {
  Polygon pl = (Polygon)geom.getGeometry();
  for( int r = 0; r &lt; pl.numRings(); r++) {
    LinearRing rng = pl.getRing(r);
    System.out.println("Ring: " + r);
    for( int p = 0; p &lt; rng.numPoints(); p++ ) {
      Point pt = rng.getPoint(p);
      System.out.println("Point: " + p);
      System.out.println(pt.toString());
    }
  }
}</pre><p>幾何オブジェクトのさまざまなデータアクセサ関数に関する参照情報については、拡張オブジェクトのJavaDocをご覧下さい。</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54618240"></a>7.3. Cクライアント (libpq)</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ch07.html#idp54631552">7.3.1. テキストカーソル</a></span></dt><dt><span class="sect2"><a href="ch07.html#idp54632704">7.3.2. バイナリカーソル</a></span></dt></dl></div><p>...</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54631552"></a>7.3.1. テキストカーソル</h3></div></div></div><p>...</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp54632704"></a>7.3.2. バイナリカーソル</h3></div></div></div><p>...</p></div></div></div><div class="navfooter"><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="performance_tips.html">戻る</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="reference.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第6章 性能向上に関する技法 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第8章 PostGISリファレンス</td></tr></table></div></body></html>
